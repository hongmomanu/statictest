// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles

// eslint-disable-next-line no-global-assign
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  for (var i = 0; i < entry.length; i++) {
    newRequire(entry[i]);
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  return newRequire;
})({"src/constants.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MESSAGE_CODE_UNKONOWN = exports.MESSAGE_CODE_STREAM = exports.MESSAGE_CODE_ROOM = exports.MESSAGE_CODE_INIT = exports.TENCENT_APP_TYPE = exports.TENCENT_APP_ID = exports.APP_ID = exports.VIDEO_CHANEL_ZEGO = exports.VIDEO_CHANEL_TENCENT2 = exports.VIDEO_CHANEL_TENCENT1 = exports.VIDEO_CHANEL_ZMRTC = exports.VIDEO_CHANEL_TALKCLOUD = exports.VIDEO_CHANEL_AGORA = void 0;
var VIDEO_CHANEL_AGORA = 'agora';
exports.VIDEO_CHANEL_AGORA = VIDEO_CHANEL_AGORA;
var VIDEO_CHANEL_TALKCLOUD = 'talkcloud';
exports.VIDEO_CHANEL_TALKCLOUD = VIDEO_CHANEL_TALKCLOUD;
var VIDEO_CHANEL_ZMRTC = 'zmrtc';
exports.VIDEO_CHANEL_ZMRTC = VIDEO_CHANEL_ZMRTC;
var VIDEO_CHANEL_TENCENT1 = 'tencent1';
exports.VIDEO_CHANEL_TENCENT1 = VIDEO_CHANEL_TENCENT1;
var VIDEO_CHANEL_TENCENT2 = 'tencent2';
exports.VIDEO_CHANEL_TENCENT2 = VIDEO_CHANEL_TENCENT2;
var VIDEO_CHANEL_ZEGO = 'zego';
exports.VIDEO_CHANEL_ZEGO = VIDEO_CHANEL_ZEGO;
var APP_ID = '0368433925644e9b83eeff9fff26b61e';
exports.APP_ID = APP_ID;
var TENCENT_APP_ID = '1400029101';
exports.TENCENT_APP_ID = TENCENT_APP_ID;
var TENCENT_APP_TYPE = '12108'; //消息相关类型码

exports.TENCENT_APP_TYPE = TENCENT_APP_TYPE;
var MESSAGE_CODE_INIT = 101; //初始化相关消息

exports.MESSAGE_CODE_INIT = MESSAGE_CODE_INIT;
var MESSAGE_CODE_ROOM = 202; //房间连接状态相关消息

exports.MESSAGE_CODE_ROOM = MESSAGE_CODE_ROOM;
var MESSAGE_CODE_STREAM = 303; //音视频流相关消息

exports.MESSAGE_CODE_STREAM = MESSAGE_CODE_STREAM;
var MESSAGE_CODE_UNKONOWN = 404; //其它未知错误

exports.MESSAGE_CODE_UNKONOWN = MESSAGE_CODE_UNKONOWN;
},{}],"src/rtcKit.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RtcKit = void 0;

var _constants = require("./constants");

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var RtcKit =
/*#__PURE__*/
function () {
  function RtcKit(options) {
    _classCallCheck(this, RtcKit);

    var uid = options.uid,
        roomId = options.roomId,
        isWatcher = options.isWatcher,
        role = options.role,
        duration = options.duration,
        channel = options.channel,
        mobile = options.mobile,
        lessonId = options.lessonId,
        isFace = options.isFace,
        docroot = options.docroot,
        _options$rtcCb = options.rtcCb,
        rtcCb = _options$rtcCb === void 0 ? function () {} : _options$rtcCb;
    this.uid = uid;
    this.roomId = roomId;
    this.isSupportBeauty = false;
    this.isWatcher = isWatcher;
    this.role = role;
    this.duration = duration;
    this.channel = channel;
    this.mobile = mobile;
    this.lessonId = lessonId;
    this.isFace = isFace;
    this.rtcName = '';
    this.document = docroot || window.document;
    this.rtcCb = rtcCb;
    this.loggerColor = 'black';
    this.microphoneId = null;
    this.cameraId = null;
    this._client_ = null;
    this._code_enum_ = {
      MESSAGE_CODE_INIT: _constants.MESSAGE_CODE_INIT,
      MESSAGE_CODE_ROOM: _constants.MESSAGE_CODE_ROOM,
      MESSAGE_CODE_STREAM: _constants.MESSAGE_CODE_STREAM,
      MESSAGE_CODE_UNKONOWN: _constants.MESSAGE_CODE_UNKONOWN
    };
    this.init = this.init.bind(this);
  }

  _createClass(RtcKit, [{
    key: "init",
    value: function init() {}
  }, {
    key: "joinRoom",
    value: function joinRoom() {}
  }, {
    key: "leaveRoom",
    value: function leaveRoom() {}
  }, {
    key: "playById",
    value: function playById(id) {}
  }, {
    key: "disableVideo",
    value: function disableVideo(_ref) {
      var id = _ref.id,
          flag = _ref.flag;
    }
  }, {
    key: "disableAudio",
    value: function disableAudio(_ref2) {
      var id = _ref2.id,
          flag = _ref2.flag;
    }
  }, {
    key: "hideVideoById",
    value: function hideVideoById(id) {}
  }, {
    key: "showVideoById",
    value: function showVideoById(id) {}
  }, {
    key: "setFaceValue",
    value: function setFaceValue(val) {}
  }, {
    key: "logger",
    value: function logger() {
      var _console;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_console = console).log.apply(_console, ["%c ".concat(this.rtcName, " zmRtcKit\uFF1A") + new Date(), "color: ".concat(this.loggerColor)].concat(args));
    }
  }, {
    key: "switchDevice",
    value: function switchDevice(deviceType, deviceId) {}
  }]);

  return RtcKit;
}();

exports.RtcKit = RtcKit;
},{"./constants":"src/constants.js"}],"src/util.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.waitFor = waitFor;
exports.showErrorMsg = showErrorMsg;
exports.getRoleType = getRoleType;
exports.getChanelType = getChanelType;
exports.makeUid = makeUid;

var _constants = require("./constants");

function waitFor(conditionFunction) {
  var poll = function poll(resolve) {
    if (conditionFunction()) resolve();else setTimeout(function (_) {
      return poll(resolve);
    }, 200);
  };

  return new Promise(poll);
}

function showErrorMsg() {
  var err = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return err.reason || err.info || err.msg || '';
}

function getRoleType(role, isWatcher) {
  if (isWatcher) return 1;

  switch (role) {
    case 'teacher':
      return 0;

    case 'student':
      return 2;

    case 'seller':
      return 0;

    case 'watcher':
      return 1;

    default:
      return 4;
  }
}

function getChanelType(name) {
  switch (name) {
    case _constants.VIDEO_CHANEL_ZMRTC:
      return 4;

    case _constants.VIDEO_CHANEL_AGORA:
      return 1;

    case _constants.VIDEO_CHANEL_TENCENT1:
      return 2;

    case _constants.VIDEO_CHANEL_TALKCLOUD:
      return 5;

    case _constants.VIDEO_CHANEL_ZEGO:
      return 6;

    case _constants.VIDEO_CHANEL_TENCENT2:
      return 7;

    default:
      return 0;
  }
}

function makeUid(mobile) {
  if (!mobile) return '';
  var uid = mobile % 1000000000;
  if (uid < 100000000) uid += 100000000;
  return uid;
}
},{"./constants":"src/constants.js"}],"src/libs/AgoraRTCSDK-2.8.0.js":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! AgoraRTC|BUILD v2.8.0-0-g0d6a3be */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("AgoraRTC", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.AgoraRTC = t() : e.AgoraRTC = t();
}(window, function () {
  return function (e) {
    var t = {};

    function n(i) {
      if (t[i]) return t[i].exports;
      var o = t[i] = {
        i: i,
        l: !1,
        exports: {}
      };
      return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
    }

    return n.m = e, n.c = t, n.d = function (e, t, i) {
      n.o(e, t) || Object.defineProperty(e, t, {
        enumerable: !0,
        get: i
      });
    }, n.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }, n.t = function (e, t) {
      if (1 & t && (e = n(e)), 8 & t) return e;
      if (4 & t && "object" == _typeof(e) && e && e.__esModule) return e;
      var i = Object.create(null);
      if (n.r(i), Object.defineProperty(i, "default", {
        enumerable: !0,
        value: e
      }), 2 & t && "string" != typeof e) for (var o in e) {
        n.d(i, o, function (t) {
          return e[t];
        }.bind(null, o));
      }
      return i;
    }, n.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };
      return n.d(t, "a", t), t;
    }, n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, n.p = "", n(n.s = 22);
  }([function (e, t, n) {
    "use strict";

    n.r(t);
    var i = n(5),
        o = n.n(i),
        r = n(6),
        a = n(2),
        s = n(1),
        c = 0,
        d = "free",
        u = [],
        l = [],
        p = 0;
    setInterval(function () {
      Object(a.getParameter)("UPLOAD_LOG") && f.info("console log upload");
    }, 9e5);

    var f = function () {
      var e,
          t,
          n,
          i,
          f,
          m,
          g = "https://".concat(Object(a.getParameter)("LOG_UPLOAD_SERVER"), "/upload/v1"),
          v = ["DEBUG", "INFO", "WARNING", "ERROR", "NONE"],
          S = 0,
          I = function e(t) {
        d = "uploading", setTimeout(function () {
          !function (e, t, n) {
            var i;
            Array.isArray(e) || (e = [e]), e = e.map(function (e) {
              return {
                log_item_id: c++,
                log_level: e.log_level,
                payload_str: e.payload
              };
            }), i = {
              sdk_version: a.VERSION,
              process_id: Object(s.a)(),
              payload: JSON.stringify(e)
            };

            try {
              Object(r.c)(g, i, function (e) {
                "OK" === e ? t && t(e) : n && n(e);
              }, function (e) {
                n && n(e);
              }, {
                withCredentials: !0
              });
            } catch (e) {
              n && n(e);
            }
          }(t, function () {
            p = 0, 0 !== u.length ? (l = u.length < 10 ? u.splice(0, u.length) : u.splice(0, 10), e(l)) : d = "free";
          }, function () {
            setTimeout(function () {
              e(l);
            }, p++ < 2 ? 200 : 1e4);
          });
        }, 3e3);
      };

      t = function t() {
        for (var t = [0], n = 0; n < arguments.length; n++) {
          t.push(arguments[n]);
        }

        e.apply(this, t);
      }, n = function n() {
        for (var t = [1], n = 0; n < arguments.length; n++) {
          t.push(arguments[n]);
        }

        e.apply(this, t);
      }, i = function i() {
        for (var t = [2], n = 0; n < arguments.length; n++) {
          t.push(arguments[n]);
        }

        e.apply(this, t);
      }, f = function f() {
        for (var t = [3], n = 0; n < arguments.length; n++) {
          t.push(arguments[n]);
        }

        e.apply(this, t);
      };
      var h = {};
      return m = function m(e) {
        h[e] || (i.apply(void 0, arguments), h[e] = !0);
      }, {
        DEBUG: 0,
        INFO: 1,
        WARNING: 2,
        ERROR: 3,
        NONE: 4,
        enableLogUpload: function enableLogUpload() {
          Object(a.setParameter)("UPLOAD_LOG", !0);
        },
        disableLogUpload: function disableLogUpload() {
          Object(a.setParameter)("UPLOAD_LOG", !1);
        },
        setProxyServer: function setProxyServer(e) {
          g = e ? "https://".concat(e, "/ls/?h=").concat(Object(a.getParameter)("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(Object(a.getParameter)("LOG_UPLOAD_SERVER"), "/upload/v1");
        },
        setLogLevel: function setLogLevel(e) {
          e > 4 ? e = 4 : e < 0 && (e = 0), S = e;
        },
        log: e = function e() {
          var e,
              t = arguments[0],
              n = arguments;
          if (n[0] = (e = new Date()).toTimeString().split(" ")[0] + ":" + e.getMilliseconds() + " Agora-SDK [" + (v[t] || "DEFAULT") + "]:", function (e, t) {
            if (Object(a.getParameter)("UPLOAD_LOG")) try {
              t = Array.prototype.slice.call(t);
              var n = "";
              t.forEach(function (e) {
                "object" === o()(e) && (e = JSON.stringify(e)), n = n + e + " ";
              }), u.push({
                payload: n,
                log_level: e
              }), "free" === d && (l = u.length < 10 ? u.splice(0, u.length) : u.splice(0, 10), I(l));
            } catch (e) {}
          }(t, n), !(t < S)) switch (t) {
            case 0:
            case 1:
              console.log.apply(console, n);
              break;

            case 2:
              console.warn.apply(console, n);
              break;

            case 3:
              console.error.apply(console, n);
              break;

            default:
              return void console.log.apply(console, n);
          }
        },
        debug: t,
        info: n,
        warning: i,
        deprecate: m,
        error: f
      };
    }();

    t.default = f;
  }, function (e, t, n) {
    "use strict";

    var i = n(9),
        o = n.n(i),
        r = n(4),
        a = n.n(r),
        s = n(2),
        c = n(0),
        d = n(6),
        u = n(11),
        l = n.n(u);
    n.d(t, "b", function () {
      return g;
    }), n.d(t, "a", function () {
      return m;
    });

    var p = {
      eventType: null,
      sid: null,
      lts: null,
      success: null,
      cname: null,
      uid: null,
      peer: null,
      cid: null,
      elapse: null,
      extend: null,
      vid: 0
    },
        f = null,
        m = function m() {
      return f || (f = "process-" + l()(), c.default.info("processId: " + f)), f;
    },
        g = function () {
      var e = {
        list: {}
      };
      e.url = Object(d.e)() ? "https://".concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), ":6443/events/message") : "http://".concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), ":6080/events/message"), e.urlBackup = Object(d.e)() ? "https://".concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), ":6443/events/message") : "http://".concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), ":6080/events/message"), e.setProxyServer = function (t) {
        t ? (e.url = Object(d.e)() ? "https://".concat(t, "/rs/?h=").concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), "&p=6443&d=events/message") : "http://".concat(t, "/rs/?h=").concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), "&p=6080&d=events/message"), e.urlBackup = Object(d.e)() ? "https://".concat(t, "/rs/?h=").concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), "&p=6443&d=events/message") : "http://".concat(t, "/rs/?h=").concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), "&p=6080&d=events/message"), c.default.debug("reportProxyServerURL: ".concat(e.url)), c.default.debug("reportProxyServerBackupURL: ".concat(e.urlBackup))) : (e.url = Object(d.e)() ? "https://".concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), ":6443/events/message") : "http://".concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), ":6080/events/message"), e.urlBackup = Object(d.e)() ? "https://".concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), ":6443/events/message") : "http://".concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), ":6080/events/message"));
      }, e.sessionInit = function (t, n) {
        var i = a()({}, p);
        i.startTime = +new Date(), i.sid = t, i.cname = n.cname, e.list[t] = i;
        var o = a()({}, {
          willUploadConsoleLog: Object(s.getParameter)("UPLOAD_LOG")
        }, n.extend),
            r = a()({}, i);
        r.eventType = "session_init", r.appid = n.appid, r.browser = navigator.userAgent, r.build = s.BUILD, r.lts = +new Date(), r.elapse = r.lts - r.startTime, r.extend = JSON.stringify(o), r.mode = n.mode, r.process = m(), r.success = n.succ, r.version = s.VERSION, delete r.startTime, e.send({
          type: "io.agora.pb.Wrtc.Session",
          data: r
        }), e._flushInvokeReport(t);
      }, e.joinChooseServer = function (t, n, i) {
        n.uid && (e.list[t].uid = parseInt(n.uid)), n.cid && (e.list[t].cid = parseInt(n.cid));
        var o = a()({}, e.list[t]);
        o.eventType = "join_choose_server";
        var r = n.lts;
        o.lts = Date.now(), o.eventElapse = o.lts - r, o.chooseServerAddr = n.csAddr, o.errorCode = n.ec, o.elapse = o.lts - o.startTime, o.success = n.succ, o.chooseServerAddrList = JSON.stringify(n.serverList), delete o.startTime, e.send({
          type: "io.agora.pb.Wrtc.JoinChooseServer",
          data: o
        });
      }, e.reqUserAccount = function (t, n) {
        n.vid && (e.list[t].vid = n.vid);
        var i = a()({}, e.list[t]),
            o = n.lts;
        i.eventType = "req_user_account", i.lts = Date.now(), i.success = n.success, i.serverAddress = n.serverAddress, i.stringUid = n.stringUid, i.uid = n.uid, i.errorCode = n.errorCode, i.elapse = i.lts - i.startTime, i.eventElapse = i.lts - o, i.extend = "string" == typeof n.extend ? n.extend : JSON.stringify(n.extend), delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.ReqUserAccount",
          data: i
        });
      }, e.joinGateway = function (t, n) {
        n.vid && (e.list[t].vid = n.vid);
        var i = a()({}, e.list[t]),
            o = n.lts;
        i.eventType = "join_gateway", i.lts = Date.now(), i.gatewayAddr = n.addr, i.success = n.succ, i.errorCode = n.ec, i.elapse = i.lts - i.startTime, i.eventElapse = i.lts - o, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.JoinGateway",
          data: i
        });
      }, e.publish = function (t, n) {
        var i = a()({}, e.list[t]);
        i.eventType = "publish";
        var o = n.lts;
        i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.success = n.succ, i.errorCode = n.ec, n.videoName && (i.videoName = n.videoName), n.audioName && (i.audioName = n.audioName), n.screenName && (i.screenName = n.screenName), delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.Publish",
          data: i
        }), e._flushInvokeReport(t);
      }, e.subscribe = function (t, n) {
        var i = a()({}, e.list[t]);
        i.eventType = "subscribe";
        var o = n.lts;
        i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.errorCode = n.ec, i.success = n.succ, isFinite(n.peerid) ? i.peer = n.peerid : i.peerSuid = "" + n.peerid, "boolean" == typeof n.video && (i.video = n.video), "boolean" == typeof n.audio && (i.audio = n.audio), delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.Subscribe",
          data: i
        }), e._flushInvokeReport(t);
      }, e.firstRemoteFrame = function (t, n) {
        var i = a()({}, e.list[t]);
        i.eventType = "first_remote_frame";
        var o = n.lts;
        i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.width = n.width, i.height = n.height, i.success = n.succ, i.errorCode = n.ec, isFinite(n.peerid) ? i.peer = n.peerid : i.peerSuid = "" + n.peerid, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.FirstFrame",
          data: i
        });
      }, e.streamSwitch = function (t, n) {
        var i = a()({}, e.list[t]);
        i.eventType = "stream_switch", i.lts = Date.now(), i.isDual = n.isdual, i.elapse = i.lts - i.startTime, i.success = i.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.StreamSwitch",
          data: i
        });
      }, e.audioSendingStopped = function (t, n) {
        var i = a()({}, e.list[t]);
        i.eventType = "audio_sending_stopped", i.lts = Date.now(), i.elapse = i.lts - i.startTime, i.reason = n.reason, i.success = n.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.AudioSendingStopped",
          data: i
        });
      }, e.videoSendingStopped = function (t, n) {
        var i = a()({}, e.list[t]);
        i.eventType = "video_sending_stopped", i.lts = Date.now(), i.elapse = i.lts - i.startTime, i.reson = n.reason, i.success = n.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.VideoSendingStopped",
          data: i
        });
      }, e.requestProxyAppCenter = function (t, n) {
        var i = a()({}, e.list[t]),
            o = n.lts;
        i.eventType = "request_proxy_appcenter", i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.extend = n.extend + "", i.APAddr = n.APAddr, i.workerManagerList = n.workerManagerList, i.response = n.response, i.errorCode = n.ec, i.success = n.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.RequestProxyAppCenter",
          data: i
        });
      }, e.requestProxyWorkerManager = function (t, n) {
        var i = a()({}, e.list[t]),
            o = n.lts;
        i.eventType = "request_proxy_worker_manager", i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.extend = n.extend, i.workerManagerAddr = n.workerManagerAddr, i.response = n.response, i.errorCode = n.ec, i.success = n.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.RequestProxyWorkerManager",
          data: i
        });
      };
      var t = 0;
      return e.reportApiInvoke = function (e, n) {
        var i = n.tag,
            r = n.name,
            a = n.getStates,
            s = n.options,
            c = n.timeout,
            d = void 0 === c ? 6e4 : c,
            u = n.callback,
            l = n.reportResult,
            p = void 0 === l || l,
            f = Date.now(),
            m = 0,
            v = t++,
            S = function S() {
          return o()({
            tag: i,
            invokeId: v,
            sid: e,
            name: r,
            apiInvokeTime: f,
            options: s
          }, a && {
            states: (t = a(), Object.keys(t).reduce(function (e, n) {
              var i = e;
              return null != t[n] && (i[n] = t[n]), i;
            }, {}))
          });
          var t;
        },
            I = setTimeout(function () {
          g._sendApiInvoke(o()({}, S(), {
            error: "API_INVOKE_TIMEOUT",
            success: !1
          }));
        }, d);

        return function (e, t) {
          if (clearTimeout(I), ++m > 1 && (e = "EXECUTOR_INVOKE_".concat(m)), e) return g._sendApiInvoke(o()({}, S(), {
            success: !1,
            error: e
          }, a && {
            states: a()
          })), u && u(e);
          g._sendApiInvoke(o()({}, S(), {
            success: !0
          }, p && {
            result: t
          }, a && {
            states: a()
          })), u && u(null, t);
        };
      }, e._cachedItems = [], e._cacheInvokeReport = function (t) {
        t.lts || (t.lts = Date.now()), e._cachedItems.push(t), e._cachedItems.length > 50 && e._cachedItems.shift();
      }, e._flushInvokeReport = function (t) {
        if (e._cachedItems.length) {
          var n = e._cachedItems;
          e._cachedItems = [], c.default.debug("Flush cached event reporting:", n.length), n.forEach(function (n, i) {
            n.sid = t, setTimeout(function () {
              e._sendApiInvoke(n);
            }, 5e3 + 500 * i);
          });
        }
      }, e._sendApiInvoke = function (t) {
        var n = t.tag,
            i = t.invokeId,
            r = t.sid,
            a = t.name,
            c = t.result,
            d = t.states,
            u = t.options,
            l = t.error,
            p = t.success,
            f = t.apiInvokeTime,
            m = t.lts,
            g = Object(s.getParameter)("NOT_REPORT_EVENT");
        if (!(n && g instanceof Array && -1 !== g.indexOf(n))) if (e.list[r]) {
          var v = e.list[r],
              S = v.startTime,
              I = v.cname,
              h = v.uid,
              y = v.cid,
              _ = (m = m || Date.now()) - S,
              E = m - f,
              b = o()({
            invokeId: i,
            sid: r,
            cname: I,
            cid: y,
            lts: m,
            uid: h,
            success: p,
            elapse: _,
            apiName: a,
            execElapse: E
          }, void 0 !== u && {
            options: JSON.stringify(u)
          }, void 0 !== d && {
            execStates: JSON.stringify(d)
          }, void 0 !== l && {
            errorCode: JSON.stringify(l)
          }, void 0 !== c && {
            execResult: JSON.stringify(c)
          });

          e.send({
            type: "io.agora.pb.Wrtc.ApiInvoke",
            data: b
          });
        } else e._cacheInvokeReport(arguments[0]);
      }, e._send = function (t) {
        try {
          var n = [];
          t && t.data && t.data.apiName ? n.push(["apiName", "" + t.data.apiName]) : t && t.data && t.data.eventType && n.push(["eventType", t.data.eventType]);
          var i = n.map(function (e) {
            return "".concat(e[0], "=").concat(encodeURIComponent(e[1]));
          }).join("&"),
              o = -1 === e.url.indexOf("?") ? "".concat(e.url, "?").concat(i) : e.url;
          Object(d.c)(o, t, null, function (n) {
            var o = -1 === e.urlBackup.indexOf("?") ? "".concat(e.urlBackup, "?").concat(i) : e.urlBackup;
            Object(d.c)(o, t, null, function (e) {}, {
              timeout: 1e4
            });
          }, {
            timeout: 1e4
          });
        } catch (e) {}
      }, e.sendCache = [], e.sendTimer = null, e.send = function (t) {
        if (e.sendCache.push(t), null === e.sendTimer) {
          return function t() {
            e.sendTimer = setTimeout(function () {
              if (0 !== e.sendCache.length) return e._send(e.sendCache.shift()), t();
              e.sendTimer = null;
            }, Object(s.getParameter)("EVENT_REPORT_SEND_INTERVAL"));
          }();
        }
      }, e;
    }();
  }, function (e, t, n) {
    "use strict";

    t.__esModule = !0;
    t.BUILD = "v2.8.0-0-g0d6a3be";
    t.VERSION = "2.8.0";
    t.SUPPORT_RESOLUTION_LIST = {
      "90p_1": [160, 90, null, null, null, null],
      "120p_1": [160, 120, 15, 15, 30, 65],
      "120p_3": [120, 120, 15, 15, 30, 50],
      "120p_4": [212, 120, null, null, null, null],
      "180p_1": [320, 180, 15, 15, 30, 140],
      "180p_3": [180, 180, 15, 15, 30, 100],
      "180p_4": [240, 180, 15, 15, 30, 120],
      "240p_1": [320, 240, 15, 15, 40, 200],
      "240p_3": [240, 240, 15, 15, 40, 140],
      "240p_4": [424, 240, 15, 15, 40, 220],
      "360p_1": [640, 360, 15, 15, 80, 400],
      "360p_3": [360, 360, 15, 15, 80, 260],
      "360p_4": [640, 360, 30, 30, 80, 600],
      "360p_6": [360, 360, 30, 30, 80, 400],
      "360p_7": [480, 360, 15, 15, 80, 320],
      "360p_8": [480, 360, 30, 30, 80, 490],
      "360p_9": [640, 360, 15, 15, 80, 800],
      "360p_10": [640, 360, 24, 24, 80, 800],
      "360p_11": [640, 360, 24, 24, 80, 1e3],
      "480p_1": [640, 480, 15, 15, 20, 500, 1, 5],
      "480p_2": [640, 480, 30, 30, 100, 1e3, 25, 30],
      "480p_3": [480, 480, 15, 15, 100, 400],
      "480p_4": [640, 480, 30, 30, 100, 750],
      "480p_6": [480, 480, 30, 30, 100, 600],
      "480p_8": [848, 480, 15, 15, 100, 610],
      "480p_9": [848, 480, 30, 30, 100, 930],
      "480p_10": [640, 480, 10, 10, 100, 400],
      "720p_1": [1280, 720, 15, 15, 120, 1130, 1, 5],
      "720p_2": [1280, 720, 30, 30, 120, 2e3, 25, 30],
      "720p_3": [1280, 720, 30, 30, 120, 1710],
      "720p_5": [960, 720, 15, 15, 120, 910],
      "720p_6": [960, 720, 30, 30, 120, 1380],
      "1080p_1": [1920, 1080, 15, 15, 120, 2080, 1, 5],
      "1080p_2": [1920, 1080, 30, 30, 120, 3e3, 25, 30],
      "1080p_3": [1920, 1080, 30, 30, 120, 3150],
      "1080p_5": [1920, 1080, 60, 60, 120, 4780],
      "1440p_1": [2560, 1440, 30, 30, 120, 4850],
      "1440p_2": [2560, 1440, 60, 60, 120, 7350],
      "4k_1": [3840, 2160, 30, 30, 120, 8910],
      "4k_3": [3840, 2160, 60, 60, 120, 13500]
    };
    t.AUDIO_PROFILE_SETTINGS = {
      speech_low_quality: [!1, !1, !0, !0],
      speech_standard: [!1, !1, !0, !1],
      music_standard: [!1, !1, !1, !1],
      standard_stereo: [!1, !0, !1, !1],
      high_quality: [!0, !1, !1, !1],
      high_quality_stereo: [!0, !0, !1, !1],
      default: [!1, !1, !1, !1]
    };
    var i = {
      WEBCS_DOMAIN: ["ap-web-1.agora.io", "ap-web-2.agoraio.cn"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-3.agora.io", "ap-web-4.agoraio.cn"],
      PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"],
      ACCOUNT_REGISTER: ["ap-web-1.agora.io", "ap-web-2.agoraio.cn", "ap-web-3.agora.io", "ap-web-4.agoraio.cn"],
      ACCOUNT_REGISTER_RETRY_TIMEOUT: 1,
      ACCOUNT_REGISTER_RETRY_RATIO: 2,
      ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX: 6e4,
      ACCOUNT_REGISTER_RETRY_COUNT_MAX: 1e5,
      AUDIO_CONTEXT: null,
      LOG_UPLOAD_SERVER: "logservice.agora.io",
      EVENT_REPORT_DOMAIN: "webcollector-1.agora.io",
      EVENT_REPORT_BACKUP_DOMAIN: "webcollector-2.agoraio.cn",
      WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3,
      HTTP_CONNECT_TIMEOUT: 5e3,
      PLAYER_STATE_DEFER: 2e3,
      UPLOAD_LOG: !1,
      NOT_REPORT_EVENT: [],
      FILEPATH_LENMAX: 255,
      SUBSCRIBE_TCC: !1,
      PING_PONG_TIME_OUT: 10,
      WEBSOCKET_TIMEOUT_MIN: 1e4,
      EVENT_REPORT_SEND_INTERVAL: 1e3,
      MEDIA_ELEMENT_EXISTS_DEPTH: 3,
      CANDIDATE_TIMEOUT: 2e3,
      SHIM_CANDIDATE: !1,
      LEAVE_MSG_TIMEOUT: 2e3
    };

    t.setParameter = function (e, t) {
      return void 0 !== i[e] && (i[e] = t, !0);
    };

    t.getParameter = function (e) {
      return void 0 !== i[e] ? i[e] : null;
    };
  }, function (e, t, n) {
    "use strict";

    n.r(t), n.d(t, "getBrowserInfo", function () {
      return I;
    }), n.d(t, "getBrowserVersion", function () {
      return p;
    }), n.d(t, "getBrowserOS", function () {
      return f;
    }), n.d(t, "isChrome", function () {
      return i;
    }), n.d(t, "isSafari", function () {
      return o;
    }), n.d(t, "isFireFox", function () {
      return a;
    }), n.d(t, "isOpera", function () {
      return s;
    }), n.d(t, "isEdge", function () {
      return r;
    }), n.d(t, "isQQBrowser", function () {
      return c;
    }), n.d(t, "isWeChatBrowser", function () {
      return d;
    }), n.d(t, "isLegacyChrome", function () {
      return g;
    }), n.d(t, "isSupportedPC", function () {
      return u;
    }), n.d(t, "isSupportedMobile", function () {
      return l;
    }), n.d(t, "getChromeKernelVersion", function () {
      return S;
    }), n.d(t, "isChromeKernel", function () {
      return m;
    });

    var i = function i() {
      var e = I();
      return e.name && "Chrome" === e.name;
    },
        o = function o() {
      var e = I();
      return e.name && "Safari" === e.name;
    },
        r = function r() {
      var e = I();
      return e.name && "Edge" === e.name;
    },
        a = function a() {
      var e = I();
      return e.name && "Firefox" === e.name;
    },
        s = function s() {
      var e = I();
      return e.name && "OPR" === e.name;
    },
        c = function c() {
      var e = I();
      return e.name && "QQBrowser" === e.name;
    },
        d = function d() {
      var e = I();
      return e.name && "MicroMessenger" === e.name;
    },
        u = function u() {
      var e = f();
      return "Linux" === e || "Mac OS X" === e || "Mac OS" === e || -1 !== e.indexOf("Windows");
    },
        l = function l() {
      var e = f();
      return "Android" === e || "iOS" === e;
    },
        p = function p() {
      return I().version;
    },
        f = function f() {
      return I().os;
    },
        m = function m() {
      return !!navigator.userAgent.match(/chrome\/[\d]./i);
    };

    function g() {
      return window.navigator.appVersion && null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35;
    }

    var v,
        S = function S() {
      var e = navigator.userAgent.match(/chrome\/[\d]./i);
      return e && e[0] && e[0].split("/")[1];
    },
        I = (v = function () {
      var e,
          t = navigator.userAgent,
          n = t.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
      "Chrome" === n[1] && null != (e = t.match(/(OPR(?=\/))\/?(\d+)/i)) && (n = e), "Safari" === n[1] && null != (e = t.match(/version\/(\d+)/i)) && (n[2] = e[1]), ~t.toLowerCase().indexOf("qqbrowser") && null != (e = t.match(/(qqbrowser(?=\/))\/?(\d+)/i)) && (n = e), ~t.toLowerCase().indexOf("micromessenger") && null != (e = t.match(/(micromessenger(?=\/))\/?(\d+)/i)) && (n = e), ~t.toLowerCase().indexOf("edge") && null != (e = t.match(/(edge(?=\/))\/?(\d+)/i)) && (n = e), ~t.toLowerCase().indexOf("trident") && null != (e = /\brv[ :]+(\d+)/g.exec(t) || []) && (n = [null, "IE", e[1]]);
      var i = void 0,
          o = [{
        s: "Windows 10",
        r: /(Windows 10.0|Windows NT 10.0)/
      }, {
        s: "Windows 8.1",
        r: /(Windows 8.1|Windows NT 6.3)/
      }, {
        s: "Windows 8",
        r: /(Windows 8|Windows NT 6.2)/
      }, {
        s: "Windows 7",
        r: /(Windows 7|Windows NT 6.1)/
      }, {
        s: "Windows Vista",
        r: /Windows NT 6.0/
      }, {
        s: "Windows Server 2003",
        r: /Windows NT 5.2/
      }, {
        s: "Windows XP",
        r: /(Windows NT 5.1|Windows XP)/
      }, {
        s: "Windows 2000",
        r: /(Windows NT 5.0|Windows 2000)/
      }, {
        s: "Windows ME",
        r: /(Win 9x 4.90|Windows ME)/
      }, {
        s: "Windows 98",
        r: /(Windows 98|Win98)/
      }, {
        s: "Windows 95",
        r: /(Windows 95|Win95|Windows_95)/
      }, {
        s: "Windows NT 4.0",
        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
      }, {
        s: "Windows CE",
        r: /Windows CE/
      }, {
        s: "Windows 3.11",
        r: /Win16/
      }, {
        s: "Android",
        r: /Android/
      }, {
        s: "Open BSD",
        r: /OpenBSD/
      }, {
        s: "Sun OS",
        r: /SunOS/
      }, {
        s: "Linux",
        r: /(Linux|X11)/
      }, {
        s: "iOS",
        r: /(iPhone|iPad|iPod)/
      }, {
        s: "Mac OS X",
        r: /Mac OS X/
      }, {
        s: "Mac OS",
        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
      }, {
        s: "QNX",
        r: /QNX/
      }, {
        s: "UNIX",
        r: /UNIX/
      }, {
        s: "BeOS",
        r: /BeOS/
      }, {
        s: "OS/2",
        r: /OS\/2/
      }, {
        s: "Search Bot",
        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
      }];

      for (var r in o) {
        var a = o[r];

        if (a.r.test(navigator.userAgent)) {
          i = a.s;
          break;
        }
      }

      return {
        name: n[1],
        version: n[2],
        os: i
      };
    }(), function () {
      return v;
    });
  }, function (e, t) {
    function n() {
      return e.exports = n = Object.assign || function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];

          for (var i in n) {
            Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
          }
        }

        return e;
      }, n.apply(this, arguments);
    }

    e.exports = n;
  }, function (e, t) {
    function n(e) {
      return (n = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
      })(e);
    }

    function i(t) {
      return "function" == typeof Symbol && "symbol" === n(Symbol.iterator) ? e.exports = i = function i(e) {
        return n(e);
      } : e.exports = i = function i(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : n(e);
      }, i(t);
    }

    e.exports = i;
  }, function (e, t, n) {
    "use strict";

    n.d(t, "c", function () {
      return u;
    }), n.d(t, "e", function () {
      return l;
    }), n.d(t, "b", function () {
      return s;
    }), n.d(t, "a", function () {
      return c;
    }), n.d(t, "d", function () {
      return d;
    });

    var i = n(2),
        o = n(7),
        r = 0,
        a = 0,
        s = function s() {
      return r;
    },
        c = function c() {
      return a;
    },
        d = function d() {
      r = 0, a = 0;
    },
        u = function u(e, t, n, s, c) {
      var d = new XMLHttpRequest();
      if (d.timeout = t.timeout || Object(i.getParameter)("HTTP_CONNECT_TIMEOUT"), d.open("POST", e, !0), d.setRequestHeader("Content-type", "application/json; charset=utf-8"), c) for (var u in c) {
        "withCredentials" == u ? d.withCredentials = !0 : d.setRequestHeader(u, c[u]);
      }
      d.onload = function (e) {
        a += Object(o.e)(d.responseText), n && n(d.responseText);
      }, d.onerror = function (t) {
        s && s(t, e);
      }, d.ontimeout = function (t) {
        s && s(t, e);
      };
      var l = JSON.stringify(t);
      r += Object(o.e)(l), d.send(l);
    },
        l = function l() {
      return "https:" == document.location.protocol;
    };
  }, function (e, t, n) {
    "use strict";

    n.d(t, "d", function () {
      return g;
    }), n.d(t, "b", function () {
      return p;
    }), n.d(t, "a", function () {
      return l;
    }), n.d(t, "h", function () {
      return f;
    }), n.d(t, "c", function () {
      return m;
    }), n.d(t, "g", function () {
      return S;
    }), n.d(t, "f", function () {
      return h;
    }), n.d(t, "e", function () {
      return I;
    });

    var i = n(5),
        o = n.n(i),
        r = n(3),
        a = n(0),
        s = n(11),
        c = n.n(s),
        d = n(12),
        u = n(8),
        l = function l(e) {
      return this.audioContext = Object(d.a)(), this.sourceNode = e.otWebkitAudioSource || this.audioContext.createMediaStreamSource(e), this.analyser = this.audioContext.createAnalyser(), this.timeDomainData = new Uint8Array(this.analyser.frequencyBinCount), this.sourceNode.connect(this.analyser), this.getAudioLevel = function () {
        if (this.analyser) {
          this.analyser.getByteTimeDomainData(this.timeDomainData);

          for (var e = 0, t = 0; t < this.timeDomainData.length; t++) {
            e = Math.max(e, Math.abs(this.timeDomainData[t] - 128));
          }

          return e / 128;
        }

        return a.default.warning("can't find analyser in audioLevelHelper"), 0;
      }, this;
    };

    function p() {
      return c()().replace(/-/g, "").toUpperCase();
    }

    var f = function f(e, t, n) {
      try {
        var i = document.createElement("video");
        i.setAttribute("autoplay", ""), i.setAttribute("muted", ""), i.muted = !0, i.setAttribute("playsinline", ""), i.setAttribute("style", "position: absolute; top: 0; left: 0; width:1px; high:1px;"), document.body.appendChild(i), i.addEventListener("playing", function (e) {
          r.isFireFox() ? i.videoWidth && (t(i.videoWidth, i.videoHeight), document.body.removeChild(i)) : (t(i.videoWidth, i.videoHeight), document.body.removeChild(i));
        }), Object(u.setSrcObject)(i, e);
      } catch (e) {
        n(e);
      }
    },
        m = function m(e) {
      return "number" == typeof e && 0 <= e && e <= 4294967295;
    },
        g = function g(e) {
      var t = ["lowLatency", "userConfigExtraInfo", "transcodingUsers"];

      for (var n in e) {
        if ("lowLatency" === n && "boolean" != typeof e[n] || "userConfigExtraInfo" === n && "object" !== o()(e[n]) || "transcodingUsers" === n && !v(e[n]) || !~t.indexOf(n) && "number" != typeof e[n]) throw new Error("Param [" + n + "] is inValid");
      }

      return !0;
    },
        v = function v(e) {
      for (var t = 0; t < e.length; t++) {
        for (var n in e[t]) {
          if ("number" != typeof e[t][n]) throw new Error("Param user[" + t + "] - [" + n + "] is inValid");
        }
      }

      return !0;
    },
        S = function S(e) {
      isNaN(e) && (e = 1e3);
      var t = +new Date(),
          n = (t = (9301 * t + 49297) % 233280) / 233280;
      return Math.ceil(n * e);
    },
        I = function I(e) {
      var t = encodeURIComponent(e).match(/%[89ABab]/g);
      return e.length + (t ? t.length : 0);
    },
        h = function h() {
      if (!document.getElementById("agora-ban-tip")) {
        var e = document.createElement("div");
        e.id = "agora-ban-tip", e.style = "position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: #fff;", document.querySelector("body").prepend(e);
        var t = document.createElement("div");
        t.style = "background: #000; width: 346px; height: 116px; z-index: 100000; opacity: 0.6; border-radius: 10px; box-shadow: 0 2px 4px #000;", e.append(t);
        var n = document.createElement("div");
        n.style = "height: 76px; display: flex; justify-content: center; align-items: center;";
        var i = document.createElement("span");
        i.style = "height: 28px; width: 28px; color: #000; text-align: center; line-height: 30px; background: #fff; border-radius: 50%; font-weight: 600; font-size: 20px;margin-right: 5px;", i.innerText = "!";
        var o = document.createElement("span");
        o.innerText = "This browser does not support webRTC", n.append(i), n.append(o);
        var r = document.createElement("div");
        r.style = "height: 38px; display: flex; border-top: #fff 1px solid; justify-content: center; align-items: center;", r.innerText = "OK", t.append(n), t.append(r), r.onclick = function () {
          var e = document.getElementById("agora-ban-tip");
          e.parentNode.removeChild(e);
        };
      }
    };
  }, function (e, t, n) {
    "use strict";

    n.r(t), n.d(t, "RTCPeerConnection", function () {
      return E;
    }), n.d(t, "getUserMedia", function () {
      return r;
    }), n.d(t, "attachMediaStream", function () {
      return a;
    }), n.d(t, "reattachMediaStream", function () {
      return s;
    }), n.d(t, "setSrcObject", function () {
      return p;
    }), n.d(t, "getSrcObject", function () {
      return f;
    }), n.d(t, "webrtcDetectedBrowser", function () {
      return c;
    }), n.d(t, "webrtcDetectedVersion", function () {
      return d;
    }), n.d(t, "webrtcMinimumVersion", function () {
      return u;
    }), n.d(t, "webrtcTesting", function () {
      return b;
    }), n.d(t, "webrtcUtils", function () {
      return v;
    });
    var i = n(5),
        o = n.n(i),
        r = null,
        a = null,
        s = null,
        c = null,
        d = null,
        u = null,
        l = null,
        p = null,
        f = null,
        m = null,
        g = {
      addStream: null
    },
        v = {
      log: function log() {},
      extractVersion: function extractVersion(e, t, n) {
        var i = e.match(t);
        return i && i.length >= n && parseInt(i[n]);
      }
    };
    if ("object" == ("undefined" == typeof window ? "undefined" : o()(window)) ? (!window.HTMLMediaElement || "srcObject" in window.HTMLMediaElement.prototype ? (p = function p(e, t) {
      e.srcObject = t;
    }, f = function f(e) {
      return e.srcObject;
    }) : (p = function p(e, t) {
      "mozSrcObject" in e ? e.mozSrcObject = t : (e._srcObject = t, e.src = t ? URL.createObjectURL(t) : null);
    }, f = function f(e) {
      return "mozSrcObject" in e ? e.mozSrcObject : e._srcObject;
    }), r = window.navigator && window.navigator.getUserMedia) : (p = function p(e, t) {
      e.srcObject = t;
    }, f = function f(e) {
      return e.srcObject;
    }), a = function a(e, t) {
      p(e, t);
    }, s = function s(e, t) {
      p(e, f(t));
    }, "undefined" != typeof window && window.navigator) {
      if (navigator.mozGetUserMedia && window.mozRTCPeerConnection) {
        for (var S in v.log("This appears to be Firefox"), c = "firefox", d = v.extractVersion(navigator.userAgent, /Firefox\/([0-9]+)\./, 1), u = 31, m = mozRTCPeerConnection, g) {
          g[S] = m.prototype[S];
        }

        if (l = function l(e, t) {
          if (d < 38 && e && e.iceServers) {
            for (var n = [], i = 0; i < e.iceServers.length; i++) {
              var o = e.iceServers[i];
              if (o.hasOwnProperty("urls")) for (var r = 0; r < o.urls.length; r++) {
                var a = {
                  url: o.urls[r]
                };
                0 === o.urls[r].indexOf("turn") && (a.username = o.username, a.credential = o.credential), n.push(a);
              } else n.push(e.iceServers[i]);
            }

            e.iceServers = n;
          }

          var s = new m(e, t);

          for (var c in g) {
            s[c] = g[c];
          }

          return s;
        }, window.RTCSessionDescription || (window.RTCSessionDescription = mozRTCSessionDescription), window.RTCIceCandidate || (window.RTCIceCandidate = mozRTCIceCandidate), r = function r(e, t, n) {
          var i = function i(e) {
            if ("object" !== o()(e) || e.require) return e;
            var t = [];
            return Object.keys(e).forEach(function (n) {
              if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
                var i = e[n] = "object" === o()(e[n]) ? e[n] : {
                  ideal: e[n]
                };

                if (void 0 === i.min && void 0 === i.max && void 0 === i.exact || t.push(n), void 0 !== i.exact && ("number" == typeof i.exact ? i.min = i.max = i.exact : e[n] = i.exact, delete i.exact), void 0 !== i.ideal) {
                  e.advanced = e.advanced || [];
                  var r = {};
                  "number" == typeof i.ideal ? r[n] = {
                    min: i.ideal,
                    max: i.ideal
                  } : r[n] = i.ideal, e.advanced.push(r), delete i.ideal, Object.keys(i).length || delete e[n];
                }
              }
            }), t.length && (e.require = t), e;
          };

          return d < 38 && (v.log("spec: " + JSON.stringify(e)), e.audio && (e.audio = i(e.audio)), e.video && (e.video = i(e.video)), v.log("ff37: " + JSON.stringify(e))), navigator.mozGetUserMedia(e, t, n);
        }, navigator.getUserMedia = r, navigator.mediaDevices || (navigator.mediaDevices = {
          getUserMedia: _,
          addEventListener: function addEventListener() {},
          removeEventListener: function removeEventListener() {}
        }), navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function () {
          return new Promise(function (e) {
            e([{
              kind: "audioinput",
              deviceId: "default",
              label: "",
              groupId: ""
            }, {
              kind: "videoinput",
              deviceId: "default",
              label: "",
              groupId: ""
            }]);
          });
        }, d < 41) {
          var I = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);

          navigator.mediaDevices.enumerateDevices = function () {
            return I().then(void 0, function (e) {
              if ("NotFoundError" === e.name) return [];
              throw e;
            });
          };
        }
      } else if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection) {
        for (var S in v.log("This appears to be Chrome"), c = "chrome", d = v.extractVersion(navigator.userAgent, /Chrom(e|ium)\/([0-9]+)\./, 2), u = 38, m = webkitRTCPeerConnection, g) {
          g[S] = m.prototype[S];
        }

        l = function l(e, t) {
          e && e.iceTransportPolicy && (e.iceTransports = e.iceTransportPolicy);
          var n = new m(e, t);

          for (var i in g) {
            n[i] = g[i];
          }

          var o = n.getStats.bind(n);
          return n.getStats = function (e, t, n) {
            var i = this,
                r = arguments;
            r.length > 0 && "function" == typeof e && (t ? (n = t, t = e, r = [e = null, t, n]) : (t = e, r = [e = null, t]));

            var a = function a(e) {
              var t = {};
              return e.result().forEach(function (e) {
                var n = {
                  id: e.id,
                  timestamp: e.timestamp,
                  type: e.type
                };
                e.names().forEach(function (t) {
                  n[t] = e.stat(t);
                }), t[n.id] = n;
              }), t;
            };

            if (r.length >= 2) {
              return o.apply(this, [function (e) {
                r[1](a(e));
              }, r[0]]);
            }

            return new Promise(function (t, n) {
              1 === r.length && null === e ? o.apply(i, [function (e) {
                t.apply(null, [a(e)]);
              }, n]) : o.apply(i, [t, n]);
            });
          }, n;
        }, ["createOffer", "createAnswer"].forEach(function (e) {
          var t = webkitRTCPeerConnection.prototype[e];

          webkitRTCPeerConnection.prototype[e] = function () {
            var e = this;

            if (arguments.length < 1 || 1 === arguments.length && "object" === o()(arguments[0])) {
              var n = 1 === arguments.length ? arguments[0] : void 0;
              return new Promise(function (i, o) {
                t.apply(e, [i, o, n]);
              });
            }

            return t.apply(this, arguments);
          };
        }), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (e) {
          var t = webkitRTCPeerConnection.prototype[e];

          webkitRTCPeerConnection.prototype[e] = function () {
            var e = arguments,
                n = this;
            return new Promise(function (i, o) {
              t.apply(n, [e[0], function () {
                i(), e.length >= 2 && e[1].apply(null, []);
              }, function (t) {
                o(t), e.length >= 3 && e[2].apply(null, [t]);
              }]);
            });
          };
        });

        var h = function h(e) {
          if ("object" !== o()(e) || e.mandatory || e.optional) return e;
          var t = {};
          return Object.keys(e).forEach(function (n) {
            if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
              var i = "object" === o()(e[n]) ? e[n] : {
                ideal: e[n]
              };
              void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact);

              var r = function r(e, t) {
                return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t;
              };

              if (void 0 !== i.ideal) {
                t.optional = t.optional || [];
                var a = {};
                "number" == typeof i.ideal ? (a[r("min", n)] = i.ideal, t.optional.push(a), (a = {})[r("max", n)] = i.ideal, t.optional.push(a)) : (a[r("", n)] = i.ideal, t.optional.push(a));
              }

              void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[r("", n)] = i.exact) : ["min", "max"].forEach(function (e) {
                void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[r(e, n)] = i[e]);
              });
            }
          }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t;
        };

        if (r = function r(e, t, n) {
          return e.audio && (e.audio = h(e.audio)), e.video && (e.video = h(e.video)), v.log("chrome: " + JSON.stringify(e)), navigator.webkitGetUserMedia(e, t, n);
        }, navigator.getUserMedia = r, navigator.mediaDevices || (navigator.mediaDevices = {
          getUserMedia: _,
          enumerateDevices: function enumerateDevices() {
            return new Promise(function (e) {
              var t = {
                audio: "audioinput",
                video: "videoinput"
              };
              return MediaStreamTrack.getSources(function (n) {
                e(n.map(function (e) {
                  return {
                    label: e.label,
                    kind: t[e.kind],
                    deviceId: e.id,
                    groupId: ""
                  };
                }));
              });
            });
          }
        }), navigator.mediaDevices.getUserMedia) {
          var y = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

          navigator.mediaDevices.getUserMedia = function (e) {
            return v.log("spec:   " + JSON.stringify(e)), e.audio = h(e.audio), e.video = h(e.video), v.log("chrome: " + JSON.stringify(e)), y(e);
          };
        } else navigator.mediaDevices.getUserMedia = function (e) {
          return _(e);
        };

        void 0 === navigator.mediaDevices.addEventListener && (navigator.mediaDevices.addEventListener = function () {
          v.log("Dummy mediaDevices.addEventListener called.");
        }), void 0 === navigator.mediaDevices.removeEventListener && (navigator.mediaDevices.removeEventListener = function () {
          v.log("Dummy mediaDevices.removeEventListener called.");
        }), a = function a(e, t) {
          d >= 43 ? p(e, t) : void 0 !== e.src ? e.src = t ? URL.createObjectURL(t) : null : v.log("Error attaching stream to element.");
        }, s = function s(e, t) {
          d >= 43 ? p(e, f(t)) : e.src = t.src;
        };
      } else navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/) ? (v.log("This appears to be Edge"), c = "edge", d = v.extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2), u = 12) : v.log("Browser does not appear to be WebRTC-capable");
    } else v.log("This does not appear to be a browser"), c = "not a browser";

    function _(e) {
      return new Promise(function (t, n) {
        r(e, t, n);
      });
    }

    var E,
        b = {};

    try {
      Object.defineProperty(b, "version", {
        set: function set(e) {
          d = e;
        }
      });
    } catch (e) {}

    l ? E = l : "undefined" != typeof window && (E = window.RTCPeerConnection);
  }, function (e, t, n) {
    var i = n(18);

    e.exports = function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {},
            o = Object.keys(n);
        "function" == typeof Object.getOwnPropertySymbols && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function (e) {
          return Object.getOwnPropertyDescriptor(n, e).enumerable;
        }))), o.forEach(function (t) {
          i(e, t, n[t]);
        });
      }

      return e;
    };
  }, function (e, t, n) {
    e.exports = n(20);
  }, function (e, t, n) {
    var i = n(16),
        o = n(17);

    e.exports = function (e, t, n) {
      var r = t && n || 0;
      "string" == typeof e && (t = "binary" === e ? new Array(16) : null, e = null);
      var a = (e = e || {}).random || (e.rng || i)();
      if (a[6] = 15 & a[6] | 64, a[8] = 63 & a[8] | 128, t) for (var s = 0; s < 16; ++s) {
        t[r + s] = a[s];
      }
      return t || o(a);
    };
  }, function (e, t, n) {
    "use strict";

    n.d(t, "a", function () {
      return s;
    });

    var i = window.AudioContext || window.webkitAudioContext,
        o = n(2),
        r = o.getParameter,
        a = o.setParameter,
        s = function s() {
      return r("AUDIO_CONTEXT") || (console.log("Creating Audio Context"), a("AUDIO_CONTEXT", function () {
        if (i) return new i();
        throw new Error("AUDIO_CONTEXT_NOT_SUPPORTED");
      }())), r("AUDIO_CONTEXT");
    };
  }, function (e, t, n) {
    "use strict";

    t.__esModule = !0;
    var i,
        o = n(0),
        r = n(8);
    !function (e) {
      e.NEW = "new", e.PREPARING_OFFER = "preparing-offer", e.OFFER_SENT = "offer-sent", e.ESTABLISHED = "established", e.CLOSED = "closed";
    }(i || (i = {}));

    var a = function () {
      function e(e) {
        this.candidate = null, this.state = i.NEW, this.config = e, this.isSubscriber = this.config.isSubscriber, this.peerConnection = this.initPeecConnection(e), this.peerConnection.onicecandidate = this._onicecandidate.bind(this), this.peerConnection.oniceconnectionstatechange = this._oniceconnectionstatechange.bind(this), this.peerConnection.onaddstream = this._onaddstream.bind(this), this.peerConnection.ontrack = this._ontrack.bind(this), this.processSignalingMessage = this.setAnswer.bind(this), this.peerConnection.createOffer({
          offerToReceiveAudio: !0,
          offerToReceiveVideo: !0
        }).then(this.setLocalSDP.bind(this)), this.sendVideoStats = {
          id: "",
          type: "",
          mediaType: "",
          googCodecName: "h264" === this.config.codec ? "H264" : "VP8",
          bytesSent: "0",
          packetsLost: "0",
          packetsSent: "0",
          googAdaptationChanges: "0",
          googAvgEncodeMs: "0",
          googEncodeUsagePercent: "0",
          googFirsReceived: "0",
          googFrameHeightSent: "0",
          googFrameHeightInput: "0",
          googFrameRateInput: "0",
          googFrameRateSent: "0",
          googFrameWidthSent: "0",
          googFrameWidthInput: "0",
          googNacksReceived: "0",
          googPlisReceived: "0",
          googRtt: "0",
          googFramesEncoded: "0"
        }, this.sendAudioStats = {
          id: "",
          type: "",
          mediaType: "",
          googCodecName: "opus",
          aecDivergentFilterFraction: "0",
          audioInputLevel: "0",
          bytesSent: "0",
          packetsSent: "0",
          googEchoCancellationReturnLoss: "0",
          googEchoCancellationReturnLossEnhancement: "0"
        }, this.receiveAudioStats = {
          id: "",
          type: "",
          mediaType: "",
          audioOutputLevel: "0",
          bytesReceived: "0",
          packetsLost: "0",
          packetsReceived: "0",
          googAccelerateRate: "0",
          googCurrentDelayMs: "0",
          googDecodingCNG: "0",
          googDecodingCTN: "0",
          googDecodingCTSG: "0",
          googDecodingNormal: "0",
          googDecodingPLC: "0",
          googDecodingPLCCNG: "0",
          googExpandRate: "0",
          googJitterBufferMs: "0",
          googJitterReceived: "0",
          googPreemptiveExpandRate: "0",
          googPreferredJitterBufferMs: "0",
          googSecondaryDecodedRate: "0",
          googSpeechExpandRate: "0"
        }, this.receiveVideoStats = {
          id: "",
          type: "",
          mediaType: "",
          googTargetDelayMs: "0",
          packetsLost: "0",
          googDecodeMs: "0",
          googMaxDecodeMs: "0",
          googRenderDelayMs: "0",
          googFrameWidthReceived: "0",
          googFrameHeightReceived: "0",
          googFrameRateReceived: "0",
          googFrameRateDecoded: "0",
          googFrameRateOutput: "0",
          googFramesDecoded: "0",
          googFrameReceived: "0",
          googJitterBufferMs: "0",
          googCurrentDelayMs: "0",
          googMinPlayoutDelayMs: "0",
          googNacksSent: "0",
          googPlisSent: "0",
          googFirsSent: "0",
          bytesReceived: "0",
          packetsReceived: "0"
        };
      }

      return e.prototype.addStream = function (e) {
        this.peerConnection.addStream(e);
      }, e.prototype.setAnswer = function (e) {
        var t = JSON.parse(e);
        this.peerConnection.setRemoteDescription(new RTCSessionDescription({
          sdp: t.sdp,
          type: "answer"
        })), this.onsignalingmessage && this.onsignalingmessage("");
      }, e.prototype.close = function () {
        this.peerConnection.close();
      }, e.prototype.getStats = function (e, t) {
        if (void 0 === t && (t = 500), t = t > 500 ? 500 : t, Date.now() - this.lastTimeGetStats < t) {
          var n = [];
          this.config.isSubscriber ? (n.push(this.receiveVideoStats), n.push(this.receiveAudioStats)) : (n.push(this.sendAudioStats), n.push(this.sendVideoStats)), n.push({
            id: "time",
            startTime: this.connectedTime,
            timestamp: Date.now()
          }), e && e(n);
        } else this._getStats(e);
      }, e.prototype._getStats = function (e) {
        var t = this,
            n = [];
        this.peerConnection.getStats(null).then(function (i) {
          t.lastTimeGetStats = Date.now(), Object.keys(i).map(function (e) {
            var n = i[e];
            t.config.isSubscriber ? n.type && "inboundrtp" === n.type && n.mediaType && "audio" === n.mediaType ? (t.receiveAudioStats.id = n.id + "recv", t.receiveAudioStats.type = n.type + "", t.receiveAudioStats.mediaType = n.mediaType + "", t.receiveAudioStats.packetsReceived = n.packetsReceived + "", t.receiveAudioStats.bytesReceived = n.bytesReceived + "", t.receiveAudioStats.packetsLost = n.packetsLost + "", t.receiveAudioStats.googJitterReceived = n.jitter + "") : n.type && "inboundrtp" === n.type && n.mediaType && "video" === n.mediaType ? (t.receiveVideoStats.id = n.id + "recv", t.receiveVideoStats.type = n.type + "", t.receiveVideoStats.mediaType = n.mediaType + "", t.receiveVideoStats.packetsReceived = n.packetsReceived + "", t.receiveVideoStats.bytesReceived = n.bytesReceived + "", t.receiveVideoStats.packetsLost = n.packetsLost + "", t.receiveVideoStats.googJitterBufferMs = n.jitter + "", t.receiveVideoStats.googPlisSent = n.pliCount + "", t.receiveVideoStats.googFirsSent = n.firCount + "", t.receiveVideoStats.googNacksSent = n.nackCount + "") : n.remoteSource && n.type && "track" === n.type && n.trackIdentifier && -1 !== n.trackIdentifier.indexOf("v") ? (t.receiveVideoStats.googFrameHeightReceived = n.frameHeight + "", t.receiveVideoStats.googFrameWidthReceived = n.frameWidth + "", t.receiveVideoStats.googFrameRateDecoded = n.framesPerSecond + "", t.receiveVideoStats.googFrameRateOutput = n.framesPerSecond + "", t.receiveVideoStats.googFrameRateReceived = n.framesPerSecond + "", t.receiveVideoStats.googFramesDecoded = n.framesDecoded + "", t.receiveVideoStats.googFrameReceived = n.framesReceived + "") : n.remoteSource && n.type && "track" === n.type && n.trackIdentifier && -1 !== n.trackIdentifier.indexOf("a") && (t.receiveAudioStats.audioOutputLevel = n.audioLevel + "") : !n.isRemote && n.type && "outboundrtp" === n.type && n.mediaType && "audio" === n.mediaType ? (t.sendAudioStats.id = n.id + "send", t.sendAudioStats.type = n.type + "", t.sendAudioStats.mediaType = n.mediaType + "", t.sendAudioStats.packetsSent = n.packetsSent + "", t.sendAudioStats.bytesSent = n.bytesSent + "") : !n.isRemote && n.type && "outboundrtp" === n.type && n.mediaType && "video" === n.mediaType ? (t.sendVideoStats.id = n.id + "send", t.sendVideoStats.type = n.type + "", t.sendVideoStats.mediaType = n.mediaType + "", t.sendVideoStats.packetsSent = n.packetsSent + "", t.sendVideoStats.bytesSent = n.bytesSent + "", t.sendVideoStats.googRtt = n.roundTripTime + "", t.sendVideoStats.googPlisReceived = n.pliCount + "", t.sendVideoStats.googFirsReceived = n.firCount + "", t.sendVideoStats.googNacksReceived = n.nackCount + "") : !n.remoteSource && n.type && "track" === n.type && n.framesSent && 0 !== n.framesSent && (t.sendVideoStats.googFrameHeightSent = n.frameHeight + "", t.sendVideoStats.googFrameHeightInput = n.frameHeight + "", t.sendVideoStats.googFrameWidthSent = n.frameWidth + "", t.sendVideoStats.googFrameWidthInput = n.frameWidth + "", t.sendVideoStats.googFramesEncoded = n.framesSent + "", t.sendVideoStats.googFrameRateSent = n.framesPerSecond + "");
          }), t.config.isSubscriber ? (n.push(t.receiveVideoStats), n.push(t.receiveAudioStats)) : (n.push(t.sendAudioStats), n.push(t.sendVideoStats)), n.push({
            id: "time",
            startTime: t.connectedTime,
            timestamp: Date.now()
          }), e && e(n);
        });
      }, e.prototype.getStatsRate = function (e) {
        this.getStats(e);
      }, e.prototype.initPeecConnection = function (e) {
        var t = e.stunServerUrl,
            n = e.turnServer,
            i = e.iceServers;
        return this.pcConfig = {
          iceServers: [{
            urls: "stun:webcs.agora.io:3478"
          }]
        }, i instanceof Array ? this.pcConfig.iceServers = e.iceServers : t && (t instanceof Array ? t.map(function (e) {
          "string" == typeof e && "" !== e && this.pcConfig.iceServers.push({
            urls: e
          });
        }) : "string" == typeof t && "" !== t && this.pcConfig.iceServers.push({
          urls: t
        })), n && (n instanceof Array ? n.map(function (e) {
          "string" == typeof e.url && "" !== e.url && this.pcConfig.iceServers.push({
            username: e.username,
            credential: e.credential,
            url: e.url
          });
        }) : "string" == typeof n.url && "" !== n.url && (this.pcConfig.iceServers.push({
          username: n.username,
          credential: n.credential,
          credentialType: "password",
          urls: "turn:" + n.url + ":" + n.udpport + "?transport=udp"
        }), "string" == typeof n.tcpport && "" !== n.tcpport && this.pcConfig.iceServers.push({
          username: n.username,
          credential: n.credential,
          credentialType: "password",
          urls: "turn:" + n.url + ":" + n.tcpport + "?transport=tcp"
        }), !0 === n.forceturn && (this.pcConfig.iceTransportPolicy = "relay"))), new r.RTCPeerConnection(this.pcConfig);
      }, e.prototype._ontrack = function (e) {
        this.onaddstream && this.onaddstream(e, "ontrack");
      }, e.prototype._onaddstream = function (e) {
        this.onaddstream && this.onaddstream(e, "onaddstream");
      }, e.prototype._oniceconnectionstatechange = function (e) {
        "connected" === e.currentTarget.iceConnectionState && (this.state = i.ESTABLISHED, this.connectedTime = Date.now()), this.oniceconnectionstatechange && this.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      }, e.prototype._onicecandidate = function (e) {
        !this.candidate && e && (this.candidate = e.candidate, this.peerConnection.createOffer({
          offerToReceiveAudio: !0,
          offerToReceiveVideo: !0
        }).then(this.editLocalSDP.bind(this)).then(this.setLocalSDP.bind(this)).then(this.sendOffer.bind(this)).catch());
      }, e.prototype.setLocalSDP = function (e) {
        return this.peerConnection.setLocalDescription(new RTCSessionDescription({
          sdp: e.sdp,
          type: "offer"
        })), this.state = i.PREPARING_OFFER, e;
      }, e.prototype.editLocalSDP = function (e) {
        return e.sdp = this.setBandWidth(e.sdp), e.sdp = this.reviseOpus(e.sdp), e.sdp = this.addCandidate(e.sdp), e;
      }, e.prototype.setSendRecv = function (e) {
        return e = (e = (e = e.replace(/a=recvonly\r\n/g, "a=sendrecv\r\n")).replace(/a=sendonly\r\n/g, "a=sendrecv\r\n")).replace(/a=inactive\r\n/g, "a=sendrecv\r\n");
      }, e.prototype.setBandWidth = function (e) {
        var t,
            n,
            i = this.config,
            r = i.codec,
            a = i.minVideoBW,
            s = i.maxVideoBW,
            c = i.maxAudioBW,
            d = i.clientId;

        if ((t = e.match(/m=video.*\r\n/)) && a && s) {
          n = t[0] + "b=AS:" + s + "\r\n";
          var u = 0,
              l = 0;
          "h264" === r ? (u = e.search(/a=rtpmap:(\d+) H264\/90000\r\n/), l = e.search(/H264\/90000\r\n/)) : "vp8" === r && (u = e.search(/a=rtpmap:(\d+) VP8\/90000\r\n/), l = e.search(/VP8\/90000\r\n/)), -1 !== u && -1 !== l && l - u > 10 && (n = n + "a=fmtp:" + e.slice(u + 9, l - 1) + " x-google-min-bitrate=" + a + "\r\n"), e = e.replace(t[0], n), o.default.debug("[" + d + "]Set Video Bitrate - min:" + a + " max:" + s);
        }

        return (t = e.match(/m=audio.*\r\n/)) && c && (n = t[0] + "b=AS:" + c + "\r\n", e = e.replace(t[0], n)), e;
      }, e.prototype.reviseOpus = function (e) {
        return e = (e = e.replace(/a=rtpmap:102 opus\/48000\/2/g, "a=rtpmap:111 opus/48000/2")).replace(/m=audio 9 UDP\/TLS\/RTP\/SAVPF 102 0 8 97 13 118 101/g, "m=audio 9 UDP/TLS/RTP/SAVPF 111 0 8 97 13 118 101");
      }, e.prototype.addCandidate = function (e) {
        return e += "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n";
      }, e.prototype.sendOffer = function (e) {
        this.config.callback(JSON.stringify({
          sdp: e.sdp,
          messageType: "OFFER",
          tiebreaker: Math.floor(429496723 * Math.random() + 1)
        })), this.state = i.OFFER_SENT;
      }, e;
    }();

    t.default = a;
  }, function (e, t, n) {
    "use strict";

    var i = this && this.__awaiter || function (e, t, n, i) {
      return new (n || (n = Promise))(function (o, r) {
        function a(e) {
          try {
            c(i.next(e));
          } catch (e) {
            r(e);
          }
        }

        function s(e) {
          try {
            c(i.throw(e));
          } catch (e) {
            r(e);
          }
        }

        function c(e) {
          e.done ? o(e.value) : new n(function (t) {
            t(e.value);
          }).then(a, s);
        }

        c((i = i.apply(e, t || [])).next());
      });
    },
        o = this && this.__generator || function (e, t) {
      var n,
          i,
          o,
          r,
          a = {
        label: 0,
        sent: function sent() {
          if (1 & o[0]) throw o[1];
          return o[1];
        },
        trys: [],
        ops: []
      };
      return r = {
        next: s(0),
        throw: s(1),
        return: s(2)
      }, "function" == typeof Symbol && (r[Symbol.iterator] = function () {
        return this;
      }), r;

      function s(r) {
        return function (s) {
          return function (r) {
            if (n) throw new TypeError("Generator is already executing.");

            for (; a;) {
              try {
                if (n = 1, i && (o = 2 & r[0] ? i.return : r[0] ? i.throw || ((o = i.return) && o.call(i), 0) : i.next) && !(o = o.call(i, r[1])).done) return o;

                switch (i = 0, o && (r = [2 & r[0], o.value]), r[0]) {
                  case 0:
                  case 1:
                    o = r;
                    break;

                  case 4:
                    return a.label++, {
                      value: r[1],
                      done: !1
                    };

                  case 5:
                    a.label++, i = r[1], r = [0];
                    continue;

                  case 7:
                    r = a.ops.pop(), a.trys.pop();
                    continue;

                  default:
                    if (!(o = (o = a.trys).length > 0 && o[o.length - 1]) && (6 === r[0] || 2 === r[0])) {
                      a = 0;
                      continue;
                    }

                    if (3 === r[0] && (!o || r[1] > o[0] && r[1] < o[3])) {
                      a.label = r[1];
                      break;
                    }

                    if (6 === r[0] && a.label < o[1]) {
                      a.label = o[1], o = r;
                      break;
                    }

                    if (o && a.label < o[2]) {
                      a.label = o[2], a.ops.push(r);
                      break;
                    }

                    o[2] && a.ops.pop(), a.trys.pop();
                    continue;
                }

                r = t.call(e, a);
              } catch (e) {
                r = [6, e], i = 0;
              } finally {
                n = o = 0;
              }
            }

            if (5 & r[0]) throw r[1];
            return {
              value: r[0] ? r[1] : void 0,
              done: !0
            };
          }([r, s]);
        };
      }
    },
        r = this;

    t.__esModule = !0;
    var a = n(19),
        s = n(3),
        c = n(0);

    t.getSupportedCodec = function (e) {
      return i(r, void 0, void 0, function () {
        var t, n, i, r, u;
        return o(this, function (o) {
          switch (o.label) {
            case 0:
              return t = {
                video: [],
                audio: []
              }, "undefined" != typeof window ? [3, 1] : (c.default.error("getSupportedCodec: NOT_BROWSER_ENV"), [2, Promise.reject("NOT_BROWSER_ENV")]);

            case 1:
              try {
                n = a.createRTCPeerConnection({
                  iceServers: []
                });
              } catch (e) {
                return c.default.error("Failed to init RTCPeerConnection", e), [2, Promise.reject(e)];
              }

              return n ? [3, 2] : (c.default.warning("getSupportedCodec: no RTCPeerConnection constructor is detected"), [2, Promise.resolve(t)]);

            case 2:
              return e && e.stream ? [3, 7] : (i = {
                mandatory: {
                  OfferToReceiveAudio: !0,
                  OfferToReceiveVideo: !0
                }
              }, r = void 0, (s.isSafari() || s.isFireFox() || s.isWeChatBrowser()) && n.addTransceiver ? (n.addTransceiver("audio"), n.addTransceiver("video"), [4, n.createOffer()]) : [3, 4]);

            case 3:
              return r = o.sent(), [3, 6];

            case 4:
              return [4, new Promise(function (e, t) {
                var o = setTimeout(function () {
                  t("CREATEOFFER_TIMEOUT");
                }, 3e3);
                n.createOffer(function (t) {
                  clearTimeout(o), e(t);
                }, function (e) {
                  clearTimeout(o), t(e);
                }, i);
              })];

            case 5:
              r = o.sent(), o.label = 6;

            case 6:
              return n.close(), u = r.sdp, [2, d(u)];

            case 7:
              return e.stream.getTracks && n.addTrack ? e.stream.getTracks().forEach(function (t) {
                n.addTrack(t, e.stream);
              }) : n.addStream(e.stream), r = void 0, s.isSafari() || s.isFireFox() ? [4, n.createOffer()] : [3, 9];

            case 8:
              return r = o.sent(), [3, 11];

            case 9:
              return [4, new Promise(function (e, t) {
                n.createOffer(e, t);
              })];

            case 10:
              r = o.sent(), o.label = 11;

            case 11:
              return n.close(), u = r.sdp, [2, d(u)];
          }
        });
      });
    };

    var d = function d(e) {
      var t = {
        video: [],
        audio: []
      };
      return e.match(/ VP8/i) && t.video.push("VP8"), e.match(/ H264/i) && t.video.push("H264"), e.match(/ opus/i) && t.audio.push("OPUS"), Promise.resolve(t);
    };
  }, function (e, t) {
    function n(e, t, n, i, o, r, a) {
      try {
        var s = e[r](a),
            c = s.value;
      } catch (e) {
        return void n(e);
      }

      s.done ? t(c) : Promise.resolve(c).then(i, o);
    }

    e.exports = function (e) {
      return function () {
        var t = this,
            i = arguments;
        return new Promise(function (o, r) {
          var a = e.apply(t, i);

          function s(e) {
            n(a, o, r, s, c, "next", e);
          }

          function c(e) {
            n(a, o, r, s, c, "throw", e);
          }

          s(void 0);
        });
      };
    };
  }, function (e, t) {
    var n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);

    if (n) {
      var i = new Uint8Array(16);

      e.exports = function () {
        return n(i), i;
      };
    } else {
      var o = new Array(16);

      e.exports = function () {
        for (var e, t = 0; t < 16; t++) {
          0 == (3 & t) && (e = 4294967296 * Math.random()), o[t] = e >>> ((3 & t) << 3) & 255;
        }

        return o;
      };
    }
  }, function (e, t) {
    for (var n = [], i = 0; i < 256; ++i) {
      n[i] = (i + 256).toString(16).substr(1);
    }

    e.exports = function (e, t) {
      var i = t || 0,
          o = n;
      return [o[e[i++]], o[e[i++]], o[e[i++]], o[e[i++]], "-", o[e[i++]], o[e[i++]], "-", o[e[i++]], o[e[i++]], "-", o[e[i++]], o[e[i++]], "-", o[e[i++]], o[e[i++]], o[e[i++]], o[e[i++]], o[e[i++]], o[e[i++]]].join("");
    };
  }, function (e, t) {
    e.exports = function (e, t, n) {
      return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : e[t] = n, e;
    };
  }, function (e, t, n) {
    "use strict";

    t.__esModule = !0;
    var i = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.RTCPeerConnection,
        o = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.webkitRTCPeerConnection,
        r = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.mozRTCPeerConnection;

    t.createRTCPeerConnection = function (e) {
      var t = i || o || r;
      return t ? new t(e) : null;
    };
  }, function (e, t, n) {
    var i = function () {
      return this || "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self;
    }() || Function("return this")(),
        o = i.regeneratorRuntime && Object.getOwnPropertyNames(i).indexOf("regeneratorRuntime") >= 0,
        r = o && i.regeneratorRuntime;

    if (i.regeneratorRuntime = void 0, e.exports = n(21), o) i.regeneratorRuntime = r;else try {
      delete i.regeneratorRuntime;
    } catch (e) {
      i.regeneratorRuntime = void 0;
    }
  }, function (e, t) {
    !function (t) {
      "use strict";

      var n,
          i = Object.prototype,
          o = i.hasOwnProperty,
          r = "function" == typeof Symbol ? Symbol : {},
          a = r.iterator || "@@iterator",
          s = r.asyncIterator || "@@asyncIterator",
          c = r.toStringTag || "@@toStringTag",
          d = "object" == _typeof(e),
          u = t.regeneratorRuntime;

      if (u) d && (e.exports = u);else {
        (u = t.regeneratorRuntime = d ? e.exports : {}).wrap = y;
        var l = "suspendedStart",
            p = "suspendedYield",
            f = "executing",
            m = "completed",
            g = {},
            v = {};

        v[a] = function () {
          return this;
        };

        var S = Object.getPrototypeOf,
            I = S && S(S(D([])));
        I && I !== i && o.call(I, a) && (v = I);
        var h = T.prototype = E.prototype = Object.create(v);
        b.prototype = h.constructor = T, T.constructor = b, T[c] = b.displayName = "GeneratorFunction", u.isGeneratorFunction = function (e) {
          var t = "function" == typeof e && e.constructor;
          return !!t && (t === b || "GeneratorFunction" === (t.displayName || t.name));
        }, u.mark = function (e) {
          return Object.setPrototypeOf ? Object.setPrototypeOf(e, T) : (e.__proto__ = T, c in e || (e[c] = "GeneratorFunction")), e.prototype = Object.create(h), e;
        }, u.awrap = function (e) {
          return {
            __await: e
          };
        }, A(R.prototype), R.prototype[s] = function () {
          return this;
        }, u.AsyncIterator = R, u.async = function (e, t, n, i) {
          var o = new R(y(e, t, n, i));
          return u.isGeneratorFunction(t) ? o : o.next().then(function (e) {
            return e.done ? e.value : o.next();
          });
        }, A(h), h[c] = "Generator", h[a] = function () {
          return this;
        }, h.toString = function () {
          return "[object Generator]";
        }, u.keys = function (e) {
          var t = [];

          for (var n in e) {
            t.push(n);
          }

          return t.reverse(), function n() {
            for (; t.length;) {
              var i = t.pop();
              if (i in e) return n.value = i, n.done = !1, n;
            }

            return n.done = !0, n;
          };
        }, u.values = D, N.prototype = {
          constructor: N,
          reset: function reset(e) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = n, this.done = !1, this.delegate = null, this.method = "next", this.arg = n, this.tryEntries.forEach(w), !e) for (var t in this) {
              "t" === t.charAt(0) && o.call(this, t) && !isNaN(+t.slice(1)) && (this[t] = n);
            }
          },
          stop: function stop() {
            this.done = !0;
            var e = this.tryEntries[0].completion;
            if ("throw" === e.type) throw e.arg;
            return this.rval;
          },
          dispatchException: function dispatchException(e) {
            if (this.done) throw e;
            var t = this;

            function i(i, o) {
              return s.type = "throw", s.arg = e, t.next = i, o && (t.method = "next", t.arg = n), !!o;
            }

            for (var r = this.tryEntries.length - 1; r >= 0; --r) {
              var a = this.tryEntries[r],
                  s = a.completion;
              if ("root" === a.tryLoc) return i("end");

              if (a.tryLoc <= this.prev) {
                var c = o.call(a, "catchLoc"),
                    d = o.call(a, "finallyLoc");

                if (c && d) {
                  if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                  if (this.prev < a.finallyLoc) return i(a.finallyLoc);
                } else if (c) {
                  if (this.prev < a.catchLoc) return i(a.catchLoc, !0);
                } else {
                  if (!d) throw new Error("try statement without catch or finally");
                  if (this.prev < a.finallyLoc) return i(a.finallyLoc);
                }
              }
            }
          },
          abrupt: function abrupt(e, t) {
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var i = this.tryEntries[n];

              if (i.tryLoc <= this.prev && o.call(i, "finallyLoc") && this.prev < i.finallyLoc) {
                var r = i;
                break;
              }
            }

            r && ("break" === e || "continue" === e) && r.tryLoc <= t && t <= r.finallyLoc && (r = null);
            var a = r ? r.completion : {};
            return a.type = e, a.arg = t, r ? (this.method = "next", this.next = r.finallyLoc, g) : this.complete(a);
          },
          complete: function complete(e, t) {
            if ("throw" === e.type) throw e.arg;
            return "break" === e.type || "continue" === e.type ? this.next = e.arg : "return" === e.type ? (this.rval = this.arg = e.arg, this.method = "return", this.next = "end") : "normal" === e.type && t && (this.next = t), g;
          },
          finish: function finish(e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];
              if (n.finallyLoc === e) return this.complete(n.completion, n.afterLoc), w(n), g;
            }
          },
          catch: function _catch(e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var n = this.tryEntries[t];

              if (n.tryLoc === e) {
                var i = n.completion;

                if ("throw" === i.type) {
                  var o = i.arg;
                  w(n);
                }

                return o;
              }
            }

            throw new Error("illegal catch attempt");
          },
          delegateYield: function delegateYield(e, t, i) {
            return this.delegate = {
              iterator: D(e),
              resultName: t,
              nextLoc: i
            }, "next" === this.method && (this.arg = n), g;
          }
        };
      }

      function y(e, t, n, i) {
        var o = t && t.prototype instanceof E ? t : E,
            r = Object.create(o.prototype),
            a = new N(i || []);
        return r._invoke = function (e, t, n) {
          var i = l;
          return function (o, r) {
            if (i === f) throw new Error("Generator is already running");

            if (i === m) {
              if ("throw" === o) throw r;
              return k();
            }

            for (n.method = o, n.arg = r;;) {
              var a = n.delegate;

              if (a) {
                var s = C(a, n);

                if (s) {
                  if (s === g) continue;
                  return s;
                }
              }

              if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
                if (i === l) throw i = m, n.arg;
                n.dispatchException(n.arg);
              } else "return" === n.method && n.abrupt("return", n.arg);
              i = f;

              var c = _(e, t, n);

              if ("normal" === c.type) {
                if (i = n.done ? m : p, c.arg === g) continue;
                return {
                  value: c.arg,
                  done: n.done
                };
              }

              "throw" === c.type && (i = m, n.method = "throw", n.arg = c.arg);
            }
          };
        }(e, n, a), r;
      }

      function _(e, t, n) {
        try {
          return {
            type: "normal",
            arg: e.call(t, n)
          };
        } catch (e) {
          return {
            type: "throw",
            arg: e
          };
        }
      }

      function E() {}

      function b() {}

      function T() {}

      function A(e) {
        ["next", "throw", "return"].forEach(function (t) {
          e[t] = function (e) {
            return this._invoke(t, e);
          };
        });
      }

      function R(e) {
        var t;

        this._invoke = function (n, i) {
          function r() {
            return new Promise(function (t, r) {
              !function t(n, i, r, a) {
                var s = _(e[n], e, i);

                if ("throw" !== s.type) {
                  var c = s.arg,
                      d = c.value;
                  return d && "object" == _typeof(d) && o.call(d, "__await") ? Promise.resolve(d.__await).then(function (e) {
                    t("next", e, r, a);
                  }, function (e) {
                    t("throw", e, r, a);
                  }) : Promise.resolve(d).then(function (e) {
                    c.value = e, r(c);
                  }, function (e) {
                    return t("throw", e, r, a);
                  });
                }

                a(s.arg);
              }(n, i, t, r);
            });
          }

          return t = t ? t.then(r, r) : r();
        };
      }

      function C(e, t) {
        var i = e.iterator[t.method];

        if (i === n) {
          if (t.delegate = null, "throw" === t.method) {
            if (e.iterator.return && (t.method = "return", t.arg = n, C(e, t), "throw" === t.method)) return g;
            t.method = "throw", t.arg = new TypeError("The iterator does not provide a 'throw' method");
          }

          return g;
        }

        var o = _(i, e.iterator, t.arg);

        if ("throw" === o.type) return t.method = "throw", t.arg = o.arg, t.delegate = null, g;
        var r = o.arg;
        return r ? r.done ? (t[e.resultName] = r.value, t.next = e.nextLoc, "return" !== t.method && (t.method = "next", t.arg = n), t.delegate = null, g) : r : (t.method = "throw", t.arg = new TypeError("iterator result is not an object"), t.delegate = null, g);
      }

      function O(e) {
        var t = {
          tryLoc: e[0]
        };
        1 in e && (t.catchLoc = e[1]), 2 in e && (t.finallyLoc = e[2], t.afterLoc = e[3]), this.tryEntries.push(t);
      }

      function w(e) {
        var t = e.completion || {};
        t.type = "normal", delete t.arg, e.completion = t;
      }

      function N(e) {
        this.tryEntries = [{
          tryLoc: "root"
        }], e.forEach(O, this), this.reset(!0);
      }

      function D(e) {
        if (e) {
          var t = e[a];
          if (t) return t.call(e);
          if ("function" == typeof e.next) return e;

          if (!isNaN(e.length)) {
            var i = -1,
                r = function t() {
              for (; ++i < e.length;) {
                if (o.call(e, i)) return t.value = e[i], t.done = !1, t;
              }

              return t.value = n, t.done = !0, t;
            };

            return r.next = r;
          }
        }

        return {
          next: k
        };
      }

      function k() {
        return {
          value: n,
          done: !0
        };
      }
    }(function () {
      return this || "object" == (typeof self === "undefined" ? "undefined" : _typeof(self)) && self;
    }() || Function("return this")());
  }, function (e, t, n) {
    "use strict";

    n.r(t);

    var o = n(2),
        r = n(0),
        a = n(1),
        s = function s() {
      var e = {
        dispatcher: {}
      };
      return e.dispatcher.eventListeners = {}, e.addEventListener = function (t, n) {
        void 0 === e.dispatcher.eventListeners[t] && (e.dispatcher.eventListeners[t] = []), e.dispatcher.eventListeners[t].push(n);
      }, e.hasListeners = function (t) {
        return !(!e.dispatcher.eventListeners[t] || !e.dispatcher.eventListeners[t].length);
      }, e.on = e.addEventListener, e.removeEventListener = function (t, n) {
        var i;
        -1 !== (i = e.dispatcher.eventListeners[t].indexOf(n)) && e.dispatcher.eventListeners[t].splice(i, 1);
      }, e.dispatchEvent = function (t) {
        var n;

        for (n in e.dispatcher.eventListeners[t.type]) {
          e.dispatcher.eventListeners[t.type] && e.dispatcher.eventListeners[t.type].hasOwnProperty(n) && "function" == typeof e.dispatcher.eventListeners[t.type][n] && e.dispatcher.eventListeners[t.type][n](t);
        }
      }, e.dispatchSocketEvent = function (t) {
        var n;

        for (n in e.dispatcher.eventListeners[t.type]) {
          e.dispatcher.eventListeners[t.type] && e.dispatcher.eventListeners[t.type].hasOwnProperty(n) && "function" == typeof e.dispatcher.eventListeners[t.type][n] && e.dispatcher.eventListeners[t.type][n](t.msg);
        }
      }, e;
    },
        c = function c(e) {
      var t = {};
      return t.type = e.type, t;
    },
        d = function d(e) {
      var t = c(e);
      return t.stream = e.stream, t.reason = e.reason, t.msg = e.msg, t;
    },
        u = function u(e) {
      var t = c(e);
      return t.uid = e.uid, t.attr = e.attr, t.stream = e.stream, t;
    },
        l = function l(e) {
      var t = c(e);
      return t.msg = e.msg, t;
    },
        p = function p(e) {
      var t = c(e);
      return t.url = e.url, t.uid = e.uid, t.status = e.status, t.reason = e.reason, t;
    },
        f = n(3),
        m = function m() {};

    m.prototype.set = function (e, t) {
      ["BatteryLevel"].indexOf(e) > -1 && (this[e] = t);
    };

    var g = new function () {
      var e = s();
      return e.states = {
        UNINIT: "UNINIT",
        INITING: "INITING",
        INITED: "INITED"
      }, e.state = e.states.UNINIT, e.batteryManager = null, e._init = function (t, n) {
        e.state = e.states.INITING, navigator.getBattery ? navigator.getBattery().then(function (n) {
          e.batteryManager = n, t && setTimeout(function () {
            t();
          }, 0);
        }).catch(function (e) {
          r.default.debug("navigator.getBattery is disabled", e), t && t();
        }) : (e.state = e.states.INITED, t && t());
      }, e._getBatteryStats = function () {
        var t = {};
        return e.batteryManager && e.batteryManager.level ? t.BatteryLevel = Math.floor(100 * e.batteryManager.level) : t.BatteryLevel = "UNSUPPORTED", t;
      }, e.getStats = function (t, n) {
        var i = new m(),
            o = e._getBatteryStats();

        o && o.BatteryLevel && i.set("BatteryLevel", o.BatteryLevel), t && t(i);
      }, e._init(), e;
    }(),
        v = n(4),
        S = n.n(v),
        I = function I(e) {
      var t = s();
      return t.url = ".", t;
    },
        h = n(8),
        y = {
      101100: "NO_FLAG_SET",
      101101: "FLAG_SET_BUT_EMPTY",
      101102: "INVALID_FALG_SET",
      101203: "NO_SERVICE_AVIABLE",
      0: "OK_CODE",
      5: "INVALID_VENDOR_KEY",
      7: "INVALID_CHANNEL_NAME",
      8: "INTERNAL_ERROR",
      9: "NO_AUTHORIZED",
      10: "DYNAMIC_KEY_TIMEOUT",
      11: "NO_ACTIVE_STATUS",
      13: "DYNAMIC_KEY_EXPIRED",
      14: "STATIC_USE_DYANMIC_KEY",
      15: "DYNAMIC_USE_STATIC_KEY"
    },
        _ = {
      2000: "ERR_NO_VOCS_AVAILABLE",
      2001: "ERR_NO_VOS_AVAILABLE",
      2002: "ERR_JOIN_CHANNEL_TIMEOUT",
      2003: "WARN_REPEAT_JOIN",
      2004: "ERR_JOIN_BY_MULTI_IP",
      101: "ERR_INVALID_VENDOR_KEY",
      102: "ERR_INVALID_CHANNEL_NAME",
      103: "WARN_NO_AVAILABLE_CHANNEL",
      104: "WARN_LOOKUP_CHANNEL_TIMEOUT",
      105: "WARN_LOOKUP_CHANNEL_REJECTED",
      106: "WARN_OPEN_CHANNEL_TIMEOUT",
      107: "WARN_OPEN_CHANNEL_REJECTED",
      108: "WARN_REQUEST_DEFERRED",
      109: "ERR_DYNAMIC_KEY_TIMEOUT",
      110: "ERR_NO_AUTHORIZED",
      111: "ERR_VOM_SERVICE_UNAVAILABLE",
      112: "ERR_NO_CHANNEL_AVAILABLE_CODE",
      113: "ERR_TOO_MANY_USERS",
      114: "ERR_MASTER_VOCS_UNAVAILABLE",
      115: "ERR_INTERNAL_ERROR",
      116: "ERR_NO_ACTIVE_STATUS",
      117: "ERR_INVALID_UID",
      118: "ERR_DYNAMIC_KEY_EXPIRED",
      119: "ERR_STATIC_USE_DYANMIC_KE",
      120: "ERR_DYNAMIC_USE_STATIC_KE",
      2: "K_TIMESTAMP_EXPIRED",
      3: "K_CHANNEL_PERMISSION_INVALID",
      4: "K_CERTIFICATE_INVALID",
      5: "K_CHANNEL_NAME_EMPTY",
      6: "K_CHANNEL_NOT_FOUND",
      7: "K_TICKET_INVALID",
      8: "K_CHANNEL_CONFLICTED",
      9: "K_SERVICE_NOT_READY",
      10: "K_SERVICE_TOO_HEAVY",
      14: "K_UID_BANNED",
      15: "K_IP_BANNED",
      16: "K_CHANNEL_BANNED"
    },
        E = {
      1: "ERROR_ILLEAGAL_APPID",
      2: "ERROR_ILLEAGAL_UID",
      3: "INTERNAL_SERVER_ERROR"
    },
        b = ["NO_SERVICE_AVIABLE"],
        T = {
      19: "ERR_ALREADY_IN_USE",
      10: "ERR_TIMEDOUT",
      3: "ERR_NOT_READY",
      9: "ERR_NO_PERMISSION",
      0: "UNKNOW_ERROR"
    },
        A = {
      FAILED: "FAILED",
      INVALID_KEY: "INVALID_KEY",
      INVALID_CLIENT_MODE: "INVALID_CLIENT_MODE",
      INVALID_CLIENT_CODEC: "INVALID_CLIENT_CODEC",
      CLIENT_MODE_CODEC_MISMATCH: "CLIENT_MODE_CODEC_MISMATCH",
      WEB_API_NOT_SUPPORTED: "WEB_API_NOT_SUPPORTED",
      INVALID_PARAMETER: "INVALID_PARAMETER",
      INVALID_OPERATION: "INVALID_OPERATION",
      INVALID_LOCAL_STREAM: "INVALID_LOCAL_STREAM",
      INVALID_REMOTE_STREAM: "INVALID_REMOTE_STREAM",
      INVALID_DYNAMIC_KEY: "INVALID_DYNAMIC_KEY",
      DYNAMIC_KEY_TIMEOUT: "DYNAMIC_KEY_TIMEOUT",
      NO_VOCS_AVAILABLE: "NO_VOCS_AVAILABLE",
      NO_VOS_AVAILABLE: "ERR_NO_VOS_AVAILABLE",
      JOIN_CHANNEL_TIMEOUT: "ERR_JOIN_CHANNEL_TIMEOUT",
      NO_AVAILABLE_CHANNEL: "NO_AVAILABLE_CHANNEL",
      LOOKUP_CHANNEL_TIMEOUT: "LOOKUP_CHANNEL_TIMEOUT",
      LOOKUP_CHANNEL_REJECTED: "LOOKUP_CHANNEL_REJECTED",
      OPEN_CHANNEL_TIMEOUT: "OPEN_CHANNEL_TIMEOUT",
      OPEN_CHANNEL_REJECTED: "OPEN_CHANNEL_REJECTED",
      REQUEST_DEFERRED: "REQUEST_DEFERRED",
      STREAM_ALREADY_PUBLISHED: "STREAM_ALREADY_PUBLISHED",
      STREAM_NOT_YET_PUBLISHED: "STREAM_NOT_YET_PUBLISHED",
      JOIN_TOO_FREQUENT: "JOIN_TOO_FREQUENT",
      SOCKET_ERROR: "SOCKET_ERROR",
      SOCKET_DISCONNECTED: "SOCKET_DISCONNECTED",
      PEERCONNECTION_FAILED: "PEERCONNECTION_FAILED",
      CONNECT_GATEWAY_ERROR: "CONNECT_GATEWAY_ERROR",
      SERVICE_NOT_AVAILABLE: "SERVICE_NOT_AVAILABLE",
      JOIN_CHANNEL_FAILED: "JOIN_CHANNEL_FAILED",
      PUBLISH_STREAM_FAILED: "PUBLISH_STREAM_FAILED",
      UNPUBLISH_STREAM_FAILED: "UNPUBLISH_STREAM_FAILED",
      SUBSCRIBE_STREAM_FAILED: "SUBSCRIBE_STREAM_FAILED",
      UNSUBSCRIBE_STREAM_FAILED: "UNSUBSCRIBE_STREAM_FAILED",
      NO_SUCH_REMOTE_STREAM: "NO_SUCH_REMOTE_STREAM",
      ERR_FAILED: "1",
      ERR_INVALID_VENDOR_KEY: "101",
      ERR_INVALID_CHANNEL_NAME: "102",
      WARN_NO_AVAILABLE_CHANNEL: "103",
      WARN_LOOKUP_CHANNEL_TIMEOUT: "104",
      WARN_LOOKUP_CHANNEL_REJECTED: "105",
      WARN_OPEN_CHANNEL_TIMEOUT: "106",
      WARN_OPEN_CHANNEL_REJECTED: "107",
      WARN_REQUEST_DEFERRED: "108",
      ERR_DYNAMIC_KEY_TIMEOUT: "109",
      ERR_INVALID_DYNAMIC_KEY: "110",
      ERR_NO_VOCS_AVAILABLE: "2000",
      ERR_NO_VOS_AVAILABLE: "2001",
      ERR_JOIN_CHANNEL_TIMEOUT: "2002",
      IOS_NOT_SUPPORT: "IOS_NOT_SUPPORT",
      WECHAT_NOT_SUPPORT: "WECHAT_NOT_SUPPORT",
      SHARING_SCREEN_NOT_SUPPORT: "SHARING_SCREEN_NOT_SUPPORT",
      STILL_ON_PUBLISHING: "STILL_ON_PUBLISHING",
      LOW_STREAM_ALREADY_PUBLISHED: "LOW_STREAM_ALREADY_PUBLISHED",
      LOW_STREAM_NOT_YET_PUBLISHED: "LOW_STREAM_ALREADY_PUBLISHED",
      HIGH_STREAM_NOT_VIDEO_TRACE: "HIGH_STREAM_NOT_VIDEO_TRACE",
      NOT_FIND_DEVICE_BY_LABEL: "NOT_FIND_DEVICE_BY_LABEL",
      ENABLE_DUALSTREAM_FAILED: "ENABLE_DUALSTREAM_FAILED",
      DISABLE_DUALSTREAM_FAILED: "DISABLE_DUALSTREAM_FAILED",
      PLAYER_NOT_FOUND: "PLAYER_NOT_FOUND",
      ELECTRON_NOT_SUPPORT_SHARING_SCREEN: "ELECTRON_NOT_SUPPORT_SHARING_SCREEN",
      BAD_ENVIRONMENT: "BAD_ENVIRONMENT"
    },
        R = 0,
        C = function C(e) {
      var t = I({});
      t.id = e.id, t.playerId = R++, t.fit = e.options && e.options.fit, "contain" !== t.fit && "cover" !== t.fit && (t.fit = null), t.url = e.url, t.stream = e.stream.stream, t.elementID = e.elementID, t.setAudioOutput = function (e, n, i) {
        var o = t.video || t.audio;
        return o ? o.setSinkId ? void o.setSinkId(e).then(function () {
          return r.default.debug("[" + t.id + "] " + "video ".concat(t.id, " setAudioOutput ").concat(e, " SUCCESS")), o == t.video && t.audio ? t.audio.setSinkId(e) : Promise.resolve();
        }).then(function () {
          return r.default.debug("[" + t.id + "] " + "audio ".concat(t.id, " setAudioOutput ").concat(e, " SUCCESS")), n && n();
        }).catch(function (e) {
          return r.default.error("[" + t.id + "] VideoPlayer.setAudioOutput", e), i && i(e);
        }) : (r.default.error("[" + t.id + "] ", A.WEB_API_NOT_SUPPORTED), i && i(A.WEB_API_NOT_SUPPORTED)) : (r.default.error("[" + t.id + "] ", A.PLAYER_NOT_FOUND), i && i(A.PLAYER_NOT_FOUND));
      }, t.destroy = function () {
        r.default.debug("destroy ".concat(e.stream.local ? "local" : "remote", " Player ").concat(t.id)), Object(h.setSrcObject)(t.video, null), Object(h.setSrcObject)(t.audio, null), t.video.pause(), delete t.resizer, clearInterval(t.mediaPlayerTimer), t.mediaPlayerTimer = null, document.getElementById(t.div.id) && t.parentNode.contains(t.div) && t.parentNode.removeChild(t.div), ["video", "audio"].forEach(function (n) {
          t[n];
          var i = s[n];
          clearTimeout(i.playDeferTimeout), i.formerMediaState = null;
          var o = {
            playerId: t.playerId,
            stateId: i.stateId + 1,
            playDeferTimeout: null,
            error: !1,
            status: "aborted",
            reason: "stop",
            updatedAt: Date.now()
          };
          s[n] = o;
          var c = {
            type: "player-status-change",
            playerId: t.playerId,
            mediaType: n,
            status: o.status,
            reason: o.reason,
            isErrorState: !1
          };
          r.default.debug("Media Player Status Change Triggered by destroy()", c), e.stream.dispatchEvent(c), a.b.reportApiInvoke(e.stream.sid, {
            name: "Stream.playerStatusChange",
            options: c,
            tag: "tracer"
          })();
        });
      }, t.div = document.createElement("div"), t.div.setAttribute("id", "player_" + t.id), e.stream.video ? t.div.setAttribute("style", "width: 100%; height: 100%; position: relative; background-color: black; overflow: hidden;") : t.div.setAttribute("style", "width: 100%; height: 100%; position: relative; overflow: hidden;"), t.video = document.createElement("video"), t.video.setAttribute("id", "video" + t.id), e.stream.local && !e.stream.screen ? e.stream.mirror ? t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; transform: rotateY(180deg); object-fit: ".concat(t.fit || "cover", ";")) : t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; object-fit: ".concat(t.fit || "cover", ";")) : e.stream.video ? t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; object-fit: ".concat(t.fit || "cover", ";")) : e.stream.screen ? t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; object-fit: ".concat(t.fit || "contain")) : t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; display: none; object-fit: ".concat(t.fit || "cover"));
      var n = {
        autoplay: !0,
        muted: !!e.stream.local || !(!f.isSafari() && "iOS" !== f.getBrowserOS()) && "video_element_muted",
        playsinline: !0,
        controls: !(!f.isSafari() && "iOS" !== f.getBrowserOS() || e.stream.local),
        volume: null
      },
          i = S()({}, n, e.options);
      !0 !== i.muted || i.volume || (i.volume = 0), i.autoplay && t.video.setAttribute("autoplay", ""), !0 !== i.muted && "video_element_muted" !== i.muted || (t.video.setAttribute("muted", ""), t.video.muted = !0), i.playsinline && t.video.setAttribute("playsinline", ""), i.controls && t.video.setAttribute("controls", ""), Number.isFinite(i.volume) && (t.video.volume = i.volume), t.audio = document.createElement("audio"), t.audio.setAttribute("id", "audio" + t.id), i.autoplay && t.audio.setAttribute("autoplay", ""), !0 === i.muted && t.audio.setAttribute("muted", ""), !0 === i.muted && (t.audio.muted = !0), i.playsinline && t.audio.setAttribute("playsinline", ""), Number.isFinite(i.volume) && (t.audio.volume = i.volume), void 0 !== t.elementID ? (document.getElementById(t.elementID).appendChild(t.div), t.container = document.getElementById(t.elementID)) : (document.body.appendChild(t.div), t.container = document.body), t.parentNode = t.div.parentNode;
      var s = {
        video: {
          playerId: t.playerId,
          stateId: 0,
          playDeferTimeout: null,
          error: !1,
          status: "init",
          reason: null,
          updatedAt: Date.now()
        },
        audio: {
          playerId: t.playerId,
          stateId: 0,
          playDeferTimeout: null,
          error: !1,
          status: "init",
          reason: null,
          updatedAt: Date.now()
        }
      };

      t.mediaElemExists = function (e) {
        for (var t = e, n = 0; n < Object(o.getParameter)("MEDIA_ELEMENT_EXISTS_DEPTH") && t; n++) {
          t = t.parentNode;
        }

        return !!t;
      };

      var c = function c(e) {
        return t.mediaElemExists(e) ? e.paused ? "paused" : "play" : "aborted";
      },
          d = function d(e, t, n) {
        var i = c(e),
            o = !0;
        return "paused" === i ? ("audio" === t && !0 === n.muted && (o = !1), n.autoplay || (o = !1)) : "play" === i ? "video" === t ? o = !1 : !0 === n.muted ? e.muted && (o = !1) : e.muted || (o = !1) : "aborted" === i && (o = !1), o;
      },
          u = function u(n) {
        var u,
            l = this;

        if (l === t.video ? u = "video" : l === t.audio && (u = "audio"), u) {
          n.type || r.default.error("Unexpected evt", n);
          var p = c(l);
          clearTimeout(s[u].playDeferTimeout), s[u].playDeferTimeout = setTimeout(function () {
            s[u].playDeferTimeout = null;
            var o = s[u],
                f = c(l);

            if (p === f) {
              var m = {
                playerId: t.playerId,
                stateId: o.stateId + 1,
                playDeferTimeout: null,
                error: d(l, u, i),
                status: c(l),
                reason: n.type,
                updatedAt: Date.now()
              };

              if (o.status !== m.status) {
                s[u] = m;
                var g = {
                  type: "player-status-change",
                  playerId: t.playerId,
                  mediaType: u,
                  status: m.status,
                  reason: m.reason,
                  isErrorState: m.error
                };
                r.default.debug("Media Player Status Change", g), e.stream.dispatchEvent(g), a.b.reportApiInvoke(e.stream.sid, {
                  name: "Stream.playerStatusChange",
                  options: g,
                  tag: "tracer"
                })();
              }
            } else r.default.debug("Status Change after event Triggered." + "Stream ".concat(t.id, " PlayerId ").concat(t.playerId, " mediaType ").concat(u, " Status ").concat(p, "=>").concat(f));
          }, Object(o.getParameter)("PLAYER_STATE_DEFER"));
        } else r.default.error("Unknown media element", l);
      };

      if (t.mediaPlayerTimer = setInterval(function () {
        ["video", "audio"].forEach(function (n) {
          var o = t[n],
              u = s[n];

          if (!u.playDeferTimeout) {
            var l = {
              playerId: t.playerId,
              stateId: u.stateId + 1,
              playDeferTimeout: null,
              error: d(o, n, i),
              status: c(o),
              reason: "timer",
              updatedAt: Date.now()
            };

            if (u.status !== l.status) {
              r.default.debug("Player ".concat(t.playerId, " ").concat(n, " Status Changed Detected by Timer: ").concat(u.status, "=>").concat(l.status)), s[n] = l;
              var p = {
                type: "player-status-change",
                playerId: t.playerId,
                mediaType: n,
                status: l.status,
                reason: l.reason,
                isErrorState: l.error
              };
              r.default.debug("Media Player Status Change", p), e.stream.dispatchEvent(p), a.b.reportApiInvoke(e.stream.sid, {
                name: "Stream.playerStatusChange",
                options: p,
                tag: "tracer"
              })();
            }
          }
        });
      }, Object(o.getParameter)("PLAYER_STATE_DEFER")), t.video.addEventListener("playing", function (e) {
        !function e() {
          t.video.videoWidth * t.video.videoHeight > 4 ? r.default.debug("[" + t.id + "] video dimensions:", t.video.videoWidth, t.video.videoHeight) : setTimeout(e, 50);
        }();
      }), t.video.addEventListener("playing", u), t.video.addEventListener("canplay", u), t.video.addEventListener("abort", u), t.video.addEventListener("onerror", u), t.video.addEventListener("suspend", u), t.video.addEventListener("stalled", u), t.video.addEventListener("pause", u), t.audio.addEventListener("playing", u), t.audio.addEventListener("canplay", u), t.audio.addEventListener("abort", u), t.audio.addEventListener("onerror", u), t.audio.addEventListener("suspend", u), t.audio.addEventListener("stalled", u), t.audio.addEventListener("pause", u), e.stream.hasVideo() || e.stream.hasScreen()) t.div.appendChild(t.video), t.div.appendChild(t.audio), f.isEdge() ? t.video.srcObject = e.stream.stream : (Object(h.attachMediaStream)(t.video, e.stream.stream), Object(h.attachMediaStream)(t.audio, e.stream.stream));else if (!1 !== i.muted && "video_element_muted" !== i.muted || (t.video.removeAttribute("muted"), t.video.muted = !1), t.div.appendChild(t.video), window.MediaStream && f.isSafari()) {
        var l = new MediaStream(e.stream.stream.getAudioTracks());
        Object(h.setSrcObject)(t.video, l);
      } else Object(h.setSrcObject)(t.video, e.stream.stream);
      return t.setAudioVolume = function (e) {
        var n = parseInt(e) / 100;
        isFinite(n) && (n < 0 ? n = 0 : n > 1 && (n = 1), t.video && (t.video.volume = n), t.audio && (t.audio.volume = n));
      }, t;
    },
        O = function O(e) {
      var t = {},
          n = h.RTCPeerConnection;
      t.uid = e.uid, t.isVideoMute = e.isVideoMute, t.isAudioMute = e.isAudioMute, t.isSubscriber = e.isSubscriber, t.clientId = e.clientId, t.filterStatsCache = [], t.originStatsCache = [], t.lastTimeGetStats = null, t.pc_config = {
        iceServers: [{
          url: "stun:webcs.agora.io:3478"
        }]
      }, t.con = {
        optional: [{
          DtlsSrtpKeyAgreement: !0
        }]
      }, e.iceServers instanceof Array ? t.pc_config.iceServers = e.iceServers : (e.stunServerUrl && (e.stunServerUrl instanceof Array ? e.stunServerUrl.map(function (e) {
        "string" == typeof e && "" !== e && t.pc_config.iceServers.push({
          url: e
        });
      }) : "string" == typeof e.stunServerUrl && "" !== e.stunServerUrl && t.pc_config.iceServers.push({
        url: e.stunServerUrl
      })), e.turnServer && (e.turnServer instanceof Array ? e.turnServer.map(function (e) {
        "string" == typeof e.url && "" !== e.url && t.pc_config.iceServers.push({
          username: e.username,
          credential: e.credential,
          url: e.url
        });
      }) : "string" == typeof e.turnServer.url && "" !== e.turnServer.url && (t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.udpport + "?transport=udp"
      }), "string" == typeof e.turnServer.tcpport && "" !== e.turnServer.tcpport && t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.tcpport + "?transport=tcp"
      }), !0 === e.turnServer.forceturn && (t.pc_config.iceTransportPolicy = "relay")))), void 0 === e.audio && (e.audio = !0), void 0 === e.video && (e.video = !0), t.mediaConstraints = {
        mandatory: {
          OfferToReceiveVideo: e.video,
          OfferToReceiveAudio: e.audio
        }
      }, t.roapSessionId = 103;

      try {
        t.pc_config.sdpSemantics = "plan-b", t.peerConnection = new n(t.pc_config, t.con);
      } catch (e) {
        delete t.pc_config.sdpSemantics, t.peerConnection = new n(t.pc_config, t.con);
      }

      t.iceCandidateTimer = setTimeout(function () {
        t.iceCandidateTimer = null, r.default.debug("[".concat(t.clientId, "]Candidates collected: ").concat(t.iceCandidateCount)), t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded());
      }, Object(o.getParameter)("CANDIDATE_TIMEOUT")), t.peerConnection.onicecandidate = function (e) {
        var n, i, o, a;
        i = (n = t.peerConnection.localDescription.sdp).match(/a=candidate:.+typ\ssrflx.+\r\n/), o = n.match(/a=candidate:.+typ\shost.+\r\n/), a = n.match(/a=candidate:.+typ\srelay.+\r\n/), null === i && null === o && null === a || void 0 !== t.ice || !t.iceCandidateTimer || (r.default.debug("[" + t.clientId + "]srflx candidate : " + i + " relay candidate: " + a + " host candidate : " + o), clearTimeout(t.iceCandidateTimer), t.iceCandidateTimer = null, t.ice = 0, t.moreIceComing = !1, t.markActionNeeded()), t.iceCandidateCount = t.iceCandidateCount + 1;
      }, r.default.debug("[" + t.clientId + ']Created webkitRTCPeerConnnection with config "' + JSON.stringify(t.pc_config) + '".');

      var i = function i(t) {
        return e.screen && (t = t.replace("a=x-google-flag:conference\r\n", "")), t;
      },
          a = function a(n) {
        var i, o;

        if ((i = n.match(/m=video.*\r\n/)) && e.minVideoBW && e.maxVideoBW) {
          o = i[0] + "b=AS:" + e.maxVideoBW + "\r\n";
          var a = 0,
              s = 0;
          "h264" === e.codec ? (a = n.search(/a=rtpmap:(\d+) H264\/90000\r\n/), s = n.search(/H264\/90000\r\n/)) : "vp8" === e.codec && (a = n.search(/a=rtpmap:(\d+) VP8\/90000\r\n/), s = n.search(/VP8\/90000\r\n/)), -1 !== a && -1 !== s && s - a > 10 && (o = o + "a=fmtp:" + n.slice(a + 9, s - 1) + " x-google-min-bitrate=" + e.minVideoBW + "\r\n"), n = n.replace(i[0], o), r.default.debug("[" + t.clientId + "]Set Video Bitrate - min:" + e.minVideoBW + " max:" + e.maxVideoBW);
        }

        return (i = n.match(/m=audio.*\r\n/)) && e.maxAudioBW && (o = i[0] + "b=AS:" + e.maxAudioBW + "\r\n", n = n.replace(i[0], o)), n;
      };

      return t.processSignalingMessage = function (e) {
        var n,
            o = JSON.parse(e);
        t.incomingMessage = o, "new" === t.state ? "OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "offer-sent" === t.state ? "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), n.sdp = a(n.sdp), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.sendOK(), t.state = "established") : "pr-answer" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "pr-answer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : "offer" === o.messageType ? t.error("Not written yet") : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "established" === t.state && ("OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), n.sdp = a(n.sdp), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state));
      }, t.getVideoRelatedStats = function (e) {
        t.peerConnection.getStats(function (n) {
          Object.keys(n).forEach(function (i) {
            var o = n[i];
            t.isSubscriber ? "video" === o.mediaType && o.id && ~o.id.indexOf("recv") && e && e({
              mediaType: "video",
              peerId: t.uid,
              isVideoMute: t.isVideoMute,
              frameRateReceived: o.googFrameRateReceived,
              frameRateDecoded: o.googFrameRateDecoded,
              bytesReceived: o.bytesReceived,
              packetsReceived: o.packetsReceived,
              packetsLost: o.packetsLost
            }) : "video" === o.mediaType && o.id && ~o.id.indexOf("send") && e && e({
              mediaType: "video",
              isVideoMute: t.isVideoMute,
              frameRateInput: o.googFrameRateInput,
              frameRateSent: o.googFrameRateSent,
              googRtt: o.googRtt
            });
          });
        });
      }, t.getAudioRelatedStats = function (e) {
        t.peerConnection.getStats(function (n) {
          Object.keys(n).forEach(function (i) {
            var o = n[i];
            t.isSubscriber && "audio" === o.mediaType && o.id && ~o.id.indexOf("recv") && e && e({
              mediaType: "audio",
              peerId: t.uid,
              isAudioMute: t.isAudioMute,
              frameDropped: parseInt(o.googDecodingPLC) + parseInt(o.googDecodingPLCCNG) + "",
              frameReceived: o.googDecodingCTN,
              googJitterReceived: o.googJitterReceived,
              bytesReceived: o.bytesReceived,
              packetsReceived: o.packetsReceived,
              packetsLost: o.packetsLost
            });
          });
        });
      }, t.getStatsRate = function (e) {
        t.getStats(function (t) {
          e(t);
        });
      }, t.getStats = function (e, n) {
        n = (n = n || 500) > 500 ? 500 : n, t.lastTimeGetStats && Date.now() - t.lastTimeGetStats < n ? e && e(t.filterStatsCache, t.originStatsCache) : this._getStats(function (n, i) {
          t.filterStatsCache = n, t.originStatsCache = i, t.lastTimeGetStats = Date.now(), e && e(n, i);
        });
      }, t._getStats = function (e) {
        t.peerConnection.getStats(function (n) {
          var i = [],
              o = [],
              r = null;
          Object.keys(n).forEach(function (e) {
            var t = n[e];
            o.push(t), "ssrc" !== t.type && "VideoBwe" !== t.type || (r = t.timestamp, i.push(t));
          }), i.push({
            id: "time",
            startTime: t.connectedTime,
            timestamp: r || new Date()
          }), e(i, o);
        });
      }, t.addTrack = function (e, n) {
        t.peerConnection.addTrack(e, n);
      }, t.removeTrack = function (e, n) {
        t.peerConnection.removeTrack(t.peerConnection.getSenders().find(function (t) {
          return t.track == e;
        }));
      }, t.addStream = function (e) {
        t.peerConnection.addStream(e), t.markActionNeeded();
      }, t.removeStream = function () {
        t.markActionNeeded();
      }, t.close = function () {
        t.state = "closed", t.peerConnection.close();
      }, t.markActionNeeded = function () {
        t.actionNeeded = !0, t.doLater(function () {
          t.onstablestate();
        });
      }, t.doLater = function (e) {
        window.setTimeout(e, 1);
      }, t.onstablestate = function () {
        var e;

        if (t.actionNeeded) {
          if ("new" === t.state || "established" === t.state) t.peerConnection.createOffer(function (e) {
            if (e.sdp !== t.prevOffer) return t.peerConnection.setLocalDescription(e), t.state = "preparing-offer", void t.markActionNeeded();
            r.default.debug("[" + t.clientId + "]Not sending a new offer");
          }, function (e) {
            r.default.debug("[" + t.clientId + "]peer connection create offer failed ", e);
          }, t.mediaConstraints);else if ("preparing-offer" === t.state) {
            if (t.moreIceComing) return;
            t.prevOffer = t.peerConnection.localDescription.sdp, t.offerCandidates = t.prevOffer.match(/a=candidate.+\r\n/g) || [], t.offerCandidates.length || (r.default.warning("[".concat(t.clientId, "]No Ice Candidate generated")), Object(o.getParameter)("SHIM_CANDIDATE") ? (r.default.debug("Shimming fake candidate"), t.prevOffer += "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n") : r.default.error("[".concat(t.clientId, "]None Ice Candidate not allowed"))), t.prevOffer = t.prevOffer.replace(/a=candidate:.+typ\shost.+\r\n/g, "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n"), t.sendMessage("OFFER", t.prevOffer), t.state = "offer-sent";
          } else if ("offer-received" === t.state) t.peerConnection.createAnswer(function (e) {
            if (t.peerConnection.setLocalDescription(e), t.state = "offer-received-preparing-answer", t.iceStarted) t.markActionNeeded();else {
              var n = new Date();
              r.default.debug("[" + t.clientId + "]" + n.getTime() + ": Starting ICE in responder"), t.iceStarted = !0;
            }
          }, function (e) {
            r.default.debug("[" + t.clientId + "]peer connection create answer failed ", e);
          }, t.mediaConstraints);else if ("offer-received-preparing-answer" === t.state) {
            if (t.moreIceComing) return;
            e = t.peerConnection.localDescription.sdp, t.sendMessage("ANSWER", e), t.state = "established";
          } else t.error("Dazed and confused in state " + t.state + ", stopping here");
          t.actionNeeded = !1;
        }
      }, t.sendOK = function () {
        t.sendMessage("OK");
      }, t.sendMessage = function (e, n) {
        var i = {};
        i.messageType = e, i.sdp = n, "OFFER" === e ? (i.offererSessionId = t.sessionId, i.answererSessionId = t.otherSessionId, i.seq = t.sequenceNumber += 1, i.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (i.offererSessionId = t.incomingMessage.offererSessionId, i.answererSessionId = t.sessionId, i.seq = t.incomingMessage.seq), t.onsignalingmessage(JSON.stringify(i));
      }, t._getSender = function (e) {
        if (t.peerConnection && t.peerConnection.getSenders) {
          var n = t.peerConnection.getSenders().find(function (t) {
            return t.track.kind == e;
          });
          if (n) return n;
        }

        return null;
      }, t.hasSender = function (e) {
        return !!t._getSender(e);
      }, t.replaceTrack = function (e, n, i) {
        var o = t._getSender(e.kind);

        if (!o) return i("NO_SENDER_FOUND");

        try {
          o.replaceTrack(e);
        } catch (e) {
          return i && i(e);
        }

        setTimeout(function () {
          return n && n();
        }, 50);
      }, t.error = function (e) {
        throw "Error in RoapOnJsep: " + e;
      }, t.sessionId = t.roapSessionId += 1, t.sequenceNumber = 0, t.actionNeeded = !1, t.iceStarted = !1, t.moreIceComing = !0, t.iceCandidateCount = 0, t.onsignalingmessage = e.callback, t.peerConnection.ontrack = function (e) {
        t.onaddstream && (t.onaddstream(e, "ontrack"), t.peerConnection.onaddstream = null);
      }, t.peerConnection.onaddstream = function (e) {
        t.onaddstream && (t.onaddstream(e, "onaddstream"), t.peerConnection.ontrack = null);
      }, t.peerConnection.onremovestream = function (e) {
        t.onremovestream && t.onremovestream(e);
      }, t.peerConnection.oniceconnectionstatechange = function (e) {
        "connected" === e.currentTarget.iceConnectionState && (t.connectedTime = new Date()), t.oniceconnectionstatechange && t.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      }, t.renegotiate = function () {
        void 0 !== t.prevOffer && t.peerConnection.createOffer().then(function (e) {
          return e.sdp = e.sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n"), e.sdp = i(e.sdp), e.sdp = a(e.sdp), t.peerConnection.setLocalDescription(e);
        }).then(function () {
          t.onnegotiationneeded && t.onnegotiationneeded(t.peerConnection.localDescription.sdp);
        }).catch(function (e) {
          console.log("createOffer error: ", e);
        });
      }, t.peerConnection.onnegotiationneeded = t.renegotiate, t.onaddstream = null, t.onremovestream = null, t.onnegotiationneeded = null, t.state = "new", t.markActionNeeded(), t;
    },
        w = function w(e) {
      var t = {},
          n = h.RTCPeerConnection;
      t.uid = e.uid, t.isVideoMute = e.isVideoMute, t.isAudioMute = e.isAudioMute, t.isSubscriber = e.isSubscriber, t.clientId = e.clientId, t.filterStatsCache = [], t.originStatsCache = [], t.lastTimeGetStats = null, t.pc_config = {
        iceServers: [{
          urls: ["stun:webcs.agora.io:3478", "stun:stun.l.google.com:19302"]
        }],
        bundlePolicy: "max-bundle"
      }, t.con = {
        optional: [{
          DtlsSrtpKeyAgreement: !0
        }]
      }, e.iceServers instanceof Array ? t.pc_config.iceServers = e.iceServers : (e.stunServerUrl && (e.stunServerUrl instanceof Array ? e.stunServerUrl.map(function (e) {
        "string" == typeof e && "" !== e && t.pc_config.iceServers.push({
          url: e
        });
      }) : "string" == typeof e.stunServerUrl && "" !== e.stunServerUrl && t.pc_config.iceServers.push({
        url: e.stunServerUrl
      })), e.turnServer && (e.turnServer instanceof Array ? e.turnServer.map(function (e) {
        "string" == typeof e.url && "" !== e.url && t.pc_config.iceServers.push({
          username: e.username,
          credential: e.credential,
          url: e.url
        });
      }) : "string" == typeof e.turnServer.url && "" !== e.turnServer.url && (t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: ["turn:" + e.turnServer.url + ":" + e.turnServer.udpport + "?transport=udp"]
      }), "string" == typeof e.turnServer.tcpport && "" !== e.turnServer.tcpport && t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: ["turn:" + e.turnServer.url + ":" + e.turnServer.tcpport + "?transport=tcp"]
      }), !0 === e.turnServer.forceturn && (t.pc_config.iceTransportPolicy = "relay")))), void 0 === e.audio && (e.audio = !0), void 0 === e.video && (e.video = !0), t.mediaConstraints = {
        mandatory: {
          OfferToReceiveVideo: e.video,
          OfferToReceiveAudio: e.audio
        }
      }, t.roapSessionId = 103;

      try {
        t.pc_config.sdpSemantics = "plan-b", t.peerConnection = new n(t.pc_config, t.con);
      } catch (e) {
        delete t.pc_config.sdpSemantics, t.peerConnection = new n(t.pc_config, t.con);
      }

      r.default.debug("[" + t.clientId + ']safari Created RTCPeerConnnection with config "' + JSON.stringify(t.pc_config) + '".'), t.iceCandidateTimer = setTimeout(function () {
        t.iceCandidateTimer = null, r.default.debug("[".concat(t.clientId, "]Candidates collected: ").concat(t.iceCandidateCount)), t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded());
      }, Object(o.getParameter)("CANDIDATE_TIMEOUT")), t.peerConnection.onicecandidate = function (e) {
        var n, i, o, a;
        i = (n = t.peerConnection.localDescription.sdp).match(/a=candidate:.+typ\ssrflx.+\r\n/), o = n.match(/a=candidate:.+typ\shost.+\r\n/), a = n.match(/a=candidate:.+typ\srelay.+\r\n/), 0 === t.iceCandidateCount && (t.timeout = setTimeout(function () {
          t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded());
        }, 1e3)), null === i && null === o && null === a || void 0 !== t.ice || !t.iceCandidateTimer || (r.default.debug("[" + t.clientId + "]srflx candidate : " + i + " relay candidate: " + a + " host candidate : " + o), clearTimeout(t.iceCandidateTimer), t.iceCandidateTimer = null, t.ice = 0, t.moreIceComing = !1, t.markActionNeeded()), t.iceCandidateCount = t.iceCandidateCount + 1;
      };

      var i = function i(t) {
        return e.screen && (t = t.replace("a=x-google-flag:conference\r\n", "")), t;
      },
          a = function a(n) {
        var i, o;
        return (i = n.match(/m=video.*\r\n/)) && e.minVideoBW && e.maxVideoBW && (o = i[0] + "b=AS:" + e.maxVideoBW + "\r\n", n = n.replace(i[0], o), r.default.debug("[" + t.clientId + "]Set Video Bitrate - min:" + e.minVideoBW + " max:" + e.maxVideoBW)), (i = n.match(/m=audio.*\r\n/)) && e.maxAudioBW && (o = i[0] + "b=AS:" + e.maxAudioBW + "\r\n", n = n.replace(i[0], o)), n;
      };

      t.processSignalingMessage = function (e) {
        var n,
            o = JSON.parse(e);
        t.incomingMessage = o, "new" === t.state ? "OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "offer-sent" === t.state ? "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), n.sdp = a(n.sdp), n.sdp = n.sdp.replace(/a=x-google-flag:conference\r\n/g, ""), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.sendOK(), t.state = "established") : "pr-answer" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "pr-answer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : "offer" === o.messageType ? t.error("Not written yet") : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "established" === t.state && ("OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), n.sdp = a(n.sdp), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state));
      };

      var s = {
        id: "",
        type: "",
        mediaType: "",
        googCodecName: "opus",
        aecDivergentFilterFraction: "0",
        audioInputLevel: "0",
        bytesSent: "0",
        packetsSent: "0",
        googEchoCancellationReturnLoss: "0",
        googEchoCancellationReturnLossEnhancement: "0"
      },
          c = {
        id: "",
        type: "",
        mediaType: "",
        googCodecName: "h264" === e.codec ? "H264" : "VP8",
        bytesSent: "0",
        packetsLost: "0",
        packetsSent: "0",
        googAdaptationChanges: "0",
        googAvgEncodeMs: "0",
        googEncodeUsagePercent: "0",
        googFirsReceived: "0",
        googFrameHeightSent: "0",
        googFrameHeightInput: "0",
        googFrameRateInput: "0",
        googFrameRateSent: "0",
        googFrameWidthSent: "0",
        googFrameWidthInput: "0",
        googNacksReceived: "0",
        googPlisReceived: "0",
        googRtt: "0",
        googFramesEncoded: "0"
      },
          d = {
        id: "",
        type: "",
        mediaType: "",
        audioOutputLevel: "0",
        bytesReceived: "0",
        packetsLost: "0",
        packetsReceived: "0",
        googAccelerateRate: "0",
        googCurrentDelayMs: "0",
        googDecodingCNG: "0",
        googDecodingCTN: "0",
        googDecodingCTSG: "0",
        googDecodingNormal: "0",
        googDecodingPLC: "0",
        googDecodingPLCCNG: "0",
        googExpandRate: "0",
        googJitterBufferMs: "0",
        googJitterReceived: "0",
        googPreemptiveExpandRate: "0",
        googPreferredJitterBufferMs: "0",
        googSecondaryDecodedRate: "0",
        googSpeechExpandRate: "0"
      },
          u = {
        id: "",
        type: "",
        mediaType: "",
        googTargetDelayMs: "0",
        packetsLost: "0",
        googDecodeMs: "0",
        googMaxDecodeMs: "0",
        googRenderDelayMs: "0",
        googFrameWidthReceived: "0",
        googFrameHeightReceived: "0",
        googFrameRateReceived: "0",
        googFrameRateDecoded: "0",
        googFrameRateOutput: "0",
        googFramesDecoded: "0",
        googFrameReceived: "0",
        googJitterBufferMs: "0",
        googCurrentDelayMs: "0",
        googMinPlayoutDelayMs: "0",
        googNacksSent: "0",
        googPlisSent: "0",
        googFirsSent: "0",
        bytesReceived: "0",
        packetsReceived: "0"
      },
          l = {
        id: "bweforvideo",
        type: "VideoBwe",
        googAvailableSendBandwidth: "0",
        googAvailableReceiveBandwidth: "0",
        googActualEncBitrate: "0",
        googRetransmitBitrate: "0",
        googTargetEncBitrate: "0",
        googBucketDelay: "0",
        googTransmitBitrate: "0"
      },
          p = 0,
          f = 0,
          m = 0;
      return t.getVideoRelatedStats = function (n) {
        t.peerConnection.getStats().then(function (i) {
          var o = {
            peerId: t.uid,
            mediaType: "video",
            isVideoMute: t.isVideoMute
          };
          i.forEach(function (i) {
            if (t.isSubscriber) {
              if ("track" === i.type && (~i.id.indexOf("video") || ~i.trackIdentifier.indexOf("v"))) {
                if (!t.lastReport) return void (t.lastReport = i);
                o.frameRateReceived = i.framesReceived - t.lastReport.framesReceived + "", o.frameRateDecoded = i.framesDecoded - t.lastReport.framesDecoded + "", t.lastReport = i;
              }

              "inbound-rtp" === i.type && ~i.id.indexOf("Video") && (o.bytesReceived = i.bytesReceived + "", o.packetsReceived = i.packetsReceived + "", o.packetsLost = i.packetsLost + "");
            } else if ("outbound-rtp" === i.type && ~i.id.indexOf("Video")) {
              if (!t.lastReport) return void (t.lastReport = i);
              n && n({
                mediaType: "video",
                isVideoMute: t.isVideoMute,
                frameRateInput: e.maxFrameRate + "",
                frameRateSent: i.framesEncoded - t.lastReport.framesEncoded + ""
              }), t.lastReport = i;
            }
          }), n && n(o);
        });
      }, t.getAudioRelatedStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          n.forEach(function (n) {
            t.isSubscriber && "inbound-rtp" === n.type && ~n.id.indexOf("Audio") && e && e({
              peerId: t.uid,
              mediaType: "audio",
              isAudioMute: t.isAudioMute,
              frameDropped: n.packetsLost + "",
              frameReceived: n.packetsReceived + "",
              googJitterReceived: n.jitter + "",
              bytesReceived: n.bytesReceived + "",
              packetsReceived: n.packetsReceived + "",
              packetsLost: n.packetsLost + ""
            });
          });
        });
      }, t.getStatsRate = function (e) {
        t.getStats(function (t) {
          t.forEach(function (e) {
            "outbound-rtp" === e.type && "video" === e.mediaType && e.googFramesEncoded && (e.googFrameRateSent = ((e.googFramesEncoded - p) / 3).toString(), p = e.googFramesEncoded), "inbound-rtp" === e.type && -1 != e.id.indexOf("55543") && (e.googFrameRateReceived && (e.googFrameRateReceived = ((e.googFrameReceived - m) / 3).toString(), m = e.googFrameReceived), e.googFrameRateDecoded && (e.googFrameRateDecoded = ((e.googFramesDecoded - f) / 3).toString(), f = e.googFramesDecoded));
          }), e(t);
        });
      }, t.getStats = function (e, n) {
        n = (n = n || 500) > 500 ? 500 : n, t.lastTimeGetStats && Date.now() - t.lastTimeGetStats < n ? e && e(t.filterStatsCache, t.originStatsCache) : this._getStats(function (n, i) {
          t.filterStatsCache = n, t.originStatsCache = i, t.lastTimeGetStats = Date.now(), e && e(n, i);
        });
      }, t._getStats = function (e) {
        var n = [];
        t.peerConnection.getStats().then(function (i) {
          i.forEach(function (e) {
            n.push(e), "outbound-rtp" === e.type && "audio" === e.mediaType && (s.id = e.id, s.type = e.type, s.mediaType = e.mediaType, s.bytesSent = e.bytesSent ? e.bytesSent + "" : "0", s.packetsSent = e.packetsSent ? e.packetsSent + "" : "0"), "outbound-rtp" === e.type && "video" === e.mediaType && (c.id = e.id, c.type = e.type, c.mediaType = e.mediaType, c.bytesSent = e.bytesSent ? e.bytesSent + "" : "0", c.packetsSent = e.packetsSent ? e.packetsSent + "" : "0", c.googPlisReceived = e.pliCount ? e.pliCount + "" : "0", c.googNacksReceived = e.nackCount ? e.nackCount + "" : "0", c.googFirsReceived = e.firCount ? e.firCount + "" : "0", c.googFramesEncoded = e.framesEncoded ? e.framesEncoded + "" : "0"), "inbound-rtp" === e.type && -1 != e.id.indexOf("44444") && (d.id = e.id, d.type = e.type, d.mediaType = "audio", d.packetsReceived = e.packetsReceived ? e.packetsReceived + "" : "0", d.bytesReceived = e.bytesReceived ? e.bytesReceived + "" : "0", d.packetsLost = e.packetsLost ? e.packetsLost + "" : "0", d.packetsReceived = e.packetsReceived ? e.packetsReceived + "" : "0", d.googJitterReceived = e.jitter ? e.jitter + "" : "0"), "inbound-rtp" === e.type && -1 != e.id.indexOf("55543") && (u.id = e.id, u.type = e.type, u.mediaType = "video", u.packetsReceived = e.packetsReceived ? e.packetsReceived + "" : "0", u.bytesReceived = e.bytesReceived ? e.bytesReceived + "" : "0", u.packetsLost = e.packetsLost ? e.packetsLost + "" : "0", u.googJitterBufferMs = e.jitter ? e.jitter + "" : "0", u.googNacksSent = e.nackCount ? e.nackCount + "" : "0", u.googPlisSent = e.pliCount ? e.pliCount + "" : "0", u.googFirsSent = e.firCount ? e.firCount + "" : "0"), "track" !== e.type || -1 == e.id.indexOf("55543") && !~e.trackIdentifier.indexOf("v") && null != e.audioLevel || (u.googFrameWidthReceived = e.frameWidth ? e.frameWidth + "" : "0", u.googFrameHeightReceived = e.frameHeight ? e.frameHeight + "" : "0", u.googFrameReceived = e.framesReceived ? e.framesReceived + "" : "0", u.googFramesDecoded = e.framesDecoded ? e.framesDecoded + "" : "0"), "track" !== e.type || -1 == e.id.indexOf("44444") && !~e.trackIdentifier.indexOf("a") && void 0 === e.audioLevel || (d.audioOutputLevel = e.audioLevel + "", s.audioInputLevel = e.audioLevel + ""), "candidate-pair" === e.type && (0 == e.availableIncomingBitrate ? l.googAvailableSendBandwidth = e.availableOutgoingBitrate + "" : l.googAvailableReceiveBandwidth = e.availableIncomingBitrate + "");
          });
          var o = [l, s, c, d, u];
          o.push({
            id: "time",
            startTime: t.connectedTime,
            timestamp: new Date()
          }), e(o, n);
        }).catch(function (e) {
          console.error(e);
        });
      }, t.addTrack = function (e, n) {
        t.peerConnection.addTrack(e, n);
      }, t.removeTrack = function (e, n) {
        var i = t.peerConnection.getSenders().find(function (t) {
          return t.track == e;
        });
        i.replaceTrack(null), t.peerConnection.removeTrack(i);
      }, t.addStream = function (e) {
        window.navigator.userAgent.indexOf("Safari") > -1 && -1 === navigator.userAgent.indexOf("Chrome") ? e.getTracks().forEach(function (n) {
          return t.peerConnection.addTrack(n, e);
        }) : t.peerConnection.addStream(e), t.markActionNeeded();
      }, t.removeStream = function () {
        t.markActionNeeded();
      }, t.close = function () {
        t.state = "closed", t.peerConnection.close();
      }, t.markActionNeeded = function () {
        t.actionNeeded = !0, t.doLater(function () {
          t.onstablestate();
        });
      }, t.doLater = function (e) {
        window.setTimeout(e, 1);
      }, t.onstablestate = function () {
        var n;

        if (t.actionNeeded) {
          if ("new" === t.state || "established" === t.state) e.isSubscriber && (t.peerConnection.addTransceiver("audio", {
            direction: "recvonly"
          }), t.peerConnection.addTransceiver("video", {
            direction: "recvonly"
          })), t.peerConnection.createOffer(t.mediaConstraints).then(function (n) {
            if (n.sdp = a(n.sdp), e.isSubscriber || (n.sdp = n.sdp.replace(/a=extmap:4 urn:3gpp:video-orientation\r\n/g, "")), n.sdp !== t.prevOffer) return t.peerConnection.setLocalDescription(n), t.state = "preparing-offer", void t.markActionNeeded();
            r.default.debug("[" + t.clientId + "]Not sending a new offer");
          }).catch(function (e) {
            r.default.debug("[" + t.clientId + "]peer connection create offer failed ", e);
          });else if ("preparing-offer" === t.state) {
            if (t.moreIceComing) return;
            t.prevOffer = t.peerConnection.localDescription.sdp, t.offerCandidates = t.prevOffer.match(/a=candidate.+\r\n/g) || [], t.offerCandidates.length || (r.default.warning("[".concat(t.clientId, "]No Ice Candidate generated")), Object(o.getParameter)("SHIM_CANDIDATE") ? (r.default.debug("Shimming fake candidate"), t.prevOffer += "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n") : r.default.error("[".concat(t.clientId, "]None Ice Candidate not allowed"))), t.prevOffer = t.prevOffer.replace(/a=candidate:.+typ\shost.+\r\n/g, "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n"), t.sendMessage("OFFER", t.prevOffer), t.state = "offer-sent";
          } else if ("offer-received" === t.state) t.peerConnection.createAnswer(function (e) {
            if (t.peerConnection.setLocalDescription(e), t.state = "offer-received-preparing-answer", t.iceStarted) t.markActionNeeded();else {
              var n = new Date();
              r.default.debug("[" + t.clientId + "]" + n.getTime() + ": Starting ICE in responder"), t.iceStarted = !0;
            }
          }, function (e) {
            r.default.debug("[" + t.clientId + "]peer connection create answer failed ", e);
          }, t.mediaConstraints);else if ("offer-received-preparing-answer" === t.state) {
            if (t.moreIceComing) return;
            n = t.peerConnection.localDescription.sdp, t.sendMessage("ANSWER", n), t.state = "established";
          } else t.error("Dazed and confused in state " + t.state + ", stopping here");
          t.actionNeeded = !1;
        }
      }, t.sendOK = function () {
        t.sendMessage("OK");
      }, t.sendMessage = function (e, n) {
        var i = {};
        i.messageType = e, i.sdp = n, "OFFER" === e ? (i.offererSessionId = t.sessionId, i.answererSessionId = t.otherSessionId, i.seq = t.sequenceNumber += 1, i.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (i.offererSessionId = t.incomingMessage.offererSessionId, i.answererSessionId = t.sessionId, i.seq = t.incomingMessage.seq), t.onsignalingmessage(JSON.stringify(i));
      }, t._getSender = function (e) {
        if (t.peerConnection && t.peerConnection.getSenders) {
          var n = t.peerConnection.getSenders().find(function (t) {
            return t.track.kind == e;
          });
          if (n) return n;
        }

        return null;
      }, t.hasSender = function (e) {
        return !!t._getSender(e);
      }, t.replaceTrack = function (e, n, i) {
        var o = t._getSender(e.kind);

        if (!o) return i("NO_SENDER_FOUND");

        try {
          o.replaceTrack(e);
        } catch (e) {
          return i && i(e);
        }

        setTimeout(function () {
          return n && n();
        }, 50);
      }, t.error = function (e) {
        throw "Error in RoapOnJsep: " + e;
      }, t.sessionId = t.roapSessionId += 1, t.sequenceNumber = 0, t.actionNeeded = !1, t.iceStarted = !1, t.moreIceComing = !0, t.iceCandidateCount = 0, t.onsignalingmessage = e.callback, t.peerConnection.ontrack = function (e) {
        t.onaddstream && t.onaddstream(e, "ontrack");
      }, t.peerConnection.onremovestream = function (e) {
        t.onremovestream && t.onremovestream(e);
      }, t.peerConnection.oniceconnectionstatechange = function (e) {
        "connected" === e.currentTarget.iceConnectionState && (t.connectedTime = new Date()), t.oniceconnectionstatechange && t.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      }, t.renegotiate = function () {
        void 0 !== t.prevOffer && t.peerConnection.createOffer().then(function (e) {
          return e.sdp = e.sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n"), e.sdp = i(e.sdp), e.sdp = a(e.sdp), t.peerConnection.setLocalDescription(e);
        }).then(function () {
          t.onnegotiationneeded && t.onnegotiationneeded(t.peerConnection.localDescription.sdp);
        }).catch(function (e) {
          console.log("createOffer error: ", e);
        });
      }, t.peerConnection.onnegotiationneeded = t.renegotiate, t.onaddstream = null, t.onremovestream = null, t.state = "new", t.markActionNeeded(), t;
    },
        N = function N(e) {
      var t = {},
          n = (mozRTCPeerConnection, mozRTCSessionDescription),
          i = !1;
      t.uid = e.uid, t.isVideoMute = e.isVideoMute, t.isAudioMute = e.isAudioMute, t.isSubscriber = e.isSubscriber, t.clientId = e.clientId, t.filterStatsCache = [], t.originStatsCache = [], t.lastTimeGetStats = null, t.pc_config = {
        iceServers: []
      }, e.iceServers instanceof Array ? e.iceServers.map(function (e) {
        0 === e.url.indexOf("stun:") && t.pc_config.iceServers.push({
          url: e.url
        });
      }) : (e.stunServerUrl && (e.stunServerUrl instanceof Array ? e.stunServerUrl.map(function (e) {
        "string" == typeof e && "" !== e && t.pc_config.iceServers.push({
          url: e
        });
      }) : "string" == typeof e.stunServerUrl && "" !== e.stunServerUrl && t.pc_config.iceServers.push({
        url: e.stunServerUrl
      })), e.turnServer && "string" == typeof e.turnServer.url && "" !== e.turnServer.url && (t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.udpport + "?transport=udp"
      }), "string" == typeof e.turnServer.tcpport && "" !== e.turnServer.tcpport && t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.tcpport + "?transport=tcp"
      }), !0 === e.turnServer.forceturn && (t.pc_config.iceTransportPolicy = "relay"))), void 0 === e.audio && (e.audio = !0), void 0 === e.video && (e.video = !0), t.mediaConstraints = {
        offerToReceiveAudio: e.audio,
        offerToReceiveVideo: e.video,
        mozDontOfferDataChannel: !0
      }, t.roapSessionId = 103, t.peerConnection = new h.RTCPeerConnection(t.pc_config), r.default.debug("[" + t.clientId + ']safari Created RTCPeerConnnection with config "' + JSON.stringify(t.pc_config) + '".'), t.iceCandidateTimer = setTimeout(function () {
        t.iceCandidateTimer = null, r.default.debug("[".concat(t.clientId, "]Candidates collected: ").concat(t.iceCandidateCount)), t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded());
      }, Object(o.getParameter)("CANDIDATE_TIMEOUT")), t.peerConnection.onicecandidate = function (e) {
        var n, i, o, a;
        i = (n = t.peerConnection.localDescription.sdp).match(/a=candidate:.+typ\ssrflx.+\r\n/), o = n.match(/a=candidate:.+typ\shost.+\r\n/), a = n.match(/a=candidate:.+typ\srelay.+\r\n/), null === i && null === o && null === a || void 0 !== t.ice || !t.iceCandidateTimer || (r.default.debug("[" + t.clientId + "]srflx candidate : " + i + " relay candidate: " + a + " host candidate : " + o), clearTimeout(t.iceCandidateTimer), t.iceCandidateTimer = null, t.ice = 0, t.moreIceComing = !1, t.markActionNeeded()), t.iceCandidateCount = t.iceCandidateCount + 1;
      }, t.checkMLineReverseInSDP = function (e) {
        return !(!~e.indexOf("m=audio") || !~e.indexOf("m=video")) && e.indexOf("m=audio") > e.indexOf("m=video");
      }, t.reverseMLineInSDP = function (e) {
        var t = e.split("m=audio"),
            n = t[1].split("m=video"),
            i = "m=video" + n[1],
            o = "m=audio" + n[0];
        return e = t[0] + i + o;
      }, t.processSignalingMessage = function (e) {
        var i,
            o = JSON.parse(e);
        t.incomingMessage = o, "new" === t.state ? "OFFER" === o.messageType ? (o.sdp = l(o.sdp), i = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          r.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          r.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        }), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "offer-sent" === t.state ? "ANSWER" === o.messageType ? (o.sdp = l(o.sdp), o.sdp = o.sdp.replace(/ generation 0/g, ""), o.sdp = o.sdp.replace(/ udp /g, " UDP "), -1 !== o.sdp.indexOf("a=group:BUNDLE") ? (o.sdp = o.sdp.replace(/a=group:BUNDLE audio video/, "a=group:BUNDLE sdparta_0 sdparta_1"), o.sdp = o.sdp.replace(/a=mid:audio/, "a=mid:sdparta_0"), o.sdp = o.sdp.replace(/a=mid:video/, "a=mid:sdparta_1")) : (o.sdp = o.sdp.replace(/a=mid:audio/, "a=mid:sdparta_0"), o.sdp = o.sdp.replace(/a=mid:video/, "a=mid:sdparta_0")), i = {
          sdp: o.sdp,
          type: "answer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          r.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          r.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e);
        }), t.sendOK(), t.state = "established") : "pr-answer" === o.messageType ? (i = {
          sdp: o.sdp,
          type: "pr-answer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          r.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          r.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        })) : "offer" === o.messageType ? t.error("Not written yet") : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "established" === t.state && ("OFFER" === o.messageType ? (i = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          r.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          r.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        }), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state));
      };
      var a = {
        id: "",
        type: "",
        mediaType: "opus",
        googCodecName: "opus",
        aecDivergentFilterFraction: "0",
        audioInputLevel: "0",
        bytesSent: "0",
        packetsSent: "0",
        googEchoCancellationReturnLoss: "0",
        googEchoCancellationReturnLossEnhancement: "0"
      },
          s = {
        id: "",
        type: "",
        mediaType: "",
        googCodecName: "h264" === e.codec ? "H264" : "VP8",
        bytesSent: "0",
        packetsLost: "0",
        packetsSent: "0",
        googAdaptationChanges: "0",
        googAvgEncodeMs: "0",
        googEncodeUsagePercent: "0",
        googFirsReceived: "0",
        googFrameHeightSent: "0",
        googFrameHeightInput: "0",
        googFrameRateInput: "0",
        googFrameRateSent: "0",
        googFrameWidthSent: "0",
        googFrameWidthInput: "0",
        googNacksReceived: "0",
        googPlisReceived: "0",
        googRtt: "0"
      },
          c = {
        id: "",
        type: "",
        mediaType: "",
        audioOutputLevel: "0",
        bytesReceived: "0",
        packetsLost: "0",
        packetsReceived: "0",
        googAccelerateRate: "0",
        googCurrentDelayMs: "0",
        googDecodingCNG: "0",
        googDecodingCTN: "0",
        googDecodingCTSG: "0",
        googDecodingNormal: "0",
        googDecodingPLC: "0",
        googDecodingPLCCNG: "0",
        googExpandRate: "0",
        googJitterBufferMs: "0",
        googJitterReceived: "0",
        googPreemptiveExpandRate: "0",
        googPreferredJitterBufferMs: "0",
        googSecondaryDecodedRate: "0",
        googSpeechExpandRate: "0"
      },
          d = {
        id: "",
        type: "",
        mediaType: "",
        googTargetDelayMs: "0",
        packetsLost: "0",
        googDecodeMs: "0",
        googMaxDecodeMs: "0",
        googRenderDelayMs: "0",
        googFrameWidthReceived: "0",
        googFrameHeightReceived: "0",
        googFrameRateReceived: "0",
        googFrameRateDecoded: "0",
        googFrameRateOutput: "0",
        googJitterBufferMs: "0",
        googCurrentDelayMs: "0",
        googMinPlayoutDelayMs: "0",
        googNacksSent: "0",
        googPlisSent: "0",
        googFirsSent: "0",
        bytesReceived: "0",
        packetsReceived: "0",
        googFramesDecoded: "0"
      },
          u = 0;
      t.getVideoRelatedStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          var i = !0,
              o = !1,
              r = void 0;

          try {
            for (var a, s = n.values()[Symbol.iterator](); !(i = (a = s.next()).done); i = !0) {
              var c = a.value;

              if (t.isSubscriber) {
                if (("inbound-rtp" === c.type || "inboundrtp" === c.type) && "video" === c.mediaType) {
                  if (!t.lastReport) return void (t.lastReport = c);
                  e && e({
                    browser: "firefox",
                    mediaType: "video",
                    peerId: t.uid,
                    isVideoMute: t.isVideoMute,
                    frameRateReceived: c.framerateMean + "",
                    frameRateDecoded: c.framesDecoded - t.lastReport.framesDecoded + "",
                    bytesReceived: c.bytesReceived + "",
                    packetsReceived: c.packetsReceived + "",
                    packetsLost: c.packetsLost + ""
                  }), t.lastReport = c;
                }
              } else if (("outbound-rtp" === c.type || "outboundrtp" === c.type) && "video" === c.mediaType) {
                if (!t.lastReport) return void (t.lastReport = c);
                e && e({
                  mediaType: "video",
                  isVideoMute: t.isVideoMute,
                  frameRateInput: c.framerateMean + "",
                  frameRateSent: c.framesEncoded - t.lastReport.framesEncoded + ""
                }), t.lastReport = c;
              }
            }
          } catch (e) {
            o = !0, r = e;
          } finally {
            try {
              i || null == s.return || s.return();
            } finally {
              if (o) throw r;
            }
          }
        });
      }, t.getAudioRelatedStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          var i = !0,
              o = !1,
              r = void 0;

          try {
            for (var a, s = n.values()[Symbol.iterator](); !(i = (a = s.next()).done); i = !0) {
              var c = a.value;
              t.isSubscriber && ("inbound-rtp" !== c.type && "inboundrtp" !== c.type || "audio" !== c.mediaType || e && e({
                browser: "firefox",
                mediaType: "audio",
                peerId: t.uid,
                isAudioMute: t.isAudioMute,
                frameDropped: c.packetsLost + "",
                frameReceived: c.packetsReceived + "",
                googJitterReceived: c.jitter + "",
                bytesReceived: c.bytesReceived + "",
                packetsReceived: c.packetsReceived + "",
                packetsLost: c.packetsLost + ""
              }));
            }
          } catch (e) {
            o = !0, r = e;
          } finally {
            try {
              i || null == s.return || s.return();
            } finally {
              if (o) throw r;
            }
          }
        });
      }, t.getStatsRate = function (e) {
        t.getStats(function (t) {
          t.forEach(function (e) {
            "inbound-rtp" !== e.type && "inboundrtp" !== e.type || "video" !== e.mediaType || e.googFrameRateDecoded && (e.googFrameRateDecoded = ((e.googFramesDecoded - u) / 3).toString(), u = e.googFramesDecoded);
          }), e(t);
        });
      }, t.getStats = function (e, n) {
        n = (n = n || 500) > 500 ? 500 : n, t.lastTimeGetStats && Date.now() - t.lastTimeGetStats < n ? e && e(t.filterStatsCache, t.originStatsCache) : this._getStats(function (n, i) {
          t.filterStatsCache = n, t.originStatsCache = i, t.lastTimeGetStats = Date.now(), e && e(n, i);
        });
      }, t._getStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          var i = [],
              o = !0,
              r = !1,
              u = void 0;

          try {
            for (var l, p = n.values()[Symbol.iterator](); !(o = (l = p.next()).done); o = !0) {
              var f = l.value;
              i.push(f), "outbound-rtp" !== f.type && "outboundrtp" !== f.type || "video" !== f.mediaType || -1 !== f.id.indexOf("rtcp") || (s.id = f.id, s.type = f.type, s.mediaType = f.mediaType, s.bytesSent = f.bytesSent ? f.bytesSent + "" : "0", s.packetsSent = f.packetsSent ? f.packetsSent + "" : "0", s.googPlisReceived = f.pliCount ? f.pliCount + "" : "0", s.googNacksReceived = f.nackCount ? f.nackCount + "" : "0", s.googFirsReceived = f.firCount ? f.firCount + "" : "0", s.googFrameRateSent = f.framerateMean ? f.framerateMean + "" : "0"), "outbound-rtp" !== f.type && "outboundrtp" !== f.type || "audio" !== f.mediaType || -1 !== f.id.indexOf("rtcp") || (a.id = f.id, a.type = f.type, a.mediaType = f.mediaType, a.bytesSent = f.bytesSent ? f.bytesSent + "" : "0", a.packetsSent = f.packetsSent ? f.packetsSent + "" : "0"), "inbound-rtp" !== f.type && "inboundrtp" !== f.type || "audio" !== f.mediaType || f.isRemote || -1 !== f.id.indexOf("rtcp") || (c.id = f.id, c.type = f.type, c.mediaType = f.mediaType, c.bytesReceived = f.bytesReceived ? f.bytesReceived + "" : "0", c.packetsLost = f.packetsLost ? f.packetsLost + "" : "0", c.packetsReceived = f.packetsReceived ? f.packetsReceived + "" : "0", c.googJitterReceived = f.jitter ? f.jitter + "" : "0"), "inbound-rtp" !== f.type && "inboundrtp" !== f.type || "video" !== f.mediaType || f.isRemote || -1 !== f.id.indexOf("rtcp") || (d.id = f.id, d.type = f.type, d.mediaType = f.mediaType, d.bytesReceived = f.bytesReceived ? f.bytesReceived + "" : "0", d.googFrameRateReceived = f.framerateMean ? f.framerateMean + "" : "0", d.googFramesDecoded = f.framesDecoded ? f.framesDecoded + "" : "0", d.packetsLost = f.packetsLost ? f.packetsLost + "" : "0", d.packetsReceived = f.packetsReceived ? f.packetsReceived + "" : "0", d.googJitterBufferMs = f.jitter ? f.jitter + "" : "0", d.googNacksSent = f.nackCount ? f.nackCount + "" : "0", d.googPlisSent = f.pliCount ? f.pliCount + "" : "0", d.googFirsSent = f.firCount ? f.firCount + "" : "0"), -1 !== f.id.indexOf("outbound_rtcp_video") && (s.packetsLost = f.packetsLost ? f.packetsLost + "" : "0");
            }
          } catch (e) {
            r = !0, u = e;
          } finally {
            try {
              o || null == p.return || p.return();
            } finally {
              if (r) throw u;
            }
          }

          var m = [s, a, c, d];
          m.push({
            id: "time",
            startTime: t.connectedTime,
            timestamp: new Date()
          }), e(m, i);
        }, function (e) {
          r.default.error("[" + t.clientId + "]" + e);
        });
      }, t.addStream = function (e) {
        i = !0, t.peerConnection.addStream(e), t.markActionNeeded();
      }, t.removeStream = function () {
        t.markActionNeeded();
      }, t.close = function () {
        t.state = "closed", t.peerConnection.close();
      }, t.markActionNeeded = function () {
        t.actionNeeded = !0, t.doLater(function () {
          t.onstablestate();
        });
      }, t.doLater = function (e) {
        window.setTimeout(e, 1);
      }, t.onstablestate = function () {
        if (t.actionNeeded) {
          if ("new" === t.state || "established" === t.state) i && (t.mediaConstraints = void 0), t.peerConnection.createOffer(function (e) {
            if (e.sdp = l(e.sdp), e.sdp = e.sdp.replace(/a=extmap:1 http:\/\/www.webrtc.org\/experiments\/rtp-hdrext\/abs-send-time/, "a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"), e.sdp !== t.prevOffer) return t.peerConnection.setLocalDescription(e), t.state = "preparing-offer", void t.markActionNeeded();
            r.default.debug("[" + t.clientId + "]Not sending a new offer");
          }, function (e) {
            r.default.debug("[" + t.clientId + "]Ups! create offer failed ", e);
          }, t.mediaConstraints);else if ("preparing-offer" === t.state) {
            if (t.moreIceComing) return;
            t.prevOffer = t.peerConnection.localDescription.sdp, t.offerCandidates = t.prevOffer.match(/a=candidate.+\r\n/g) || [], t.offerCandidates.length || (r.default.warning("[".concat(t.clientId, "]No Ice Candidate generated")), Object(o.getParameter)("SHIM_CANDIDATE") ? (r.default.debug("Shimming fake candidate"), t.prevOffer += "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n") : r.default.error("[".concat(t.clientId, "]None Ice Candidate not allowed"))), t.prevOffer = t.prevOffer.replace(/a=candidate:.+typ\shost.+\r\n/g, "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n"), t.sendMessage("OFFER", t.prevOffer), t.state = "offer-sent";
          } else if ("offer-received" === t.state) t.peerConnection.createAnswer(function (e) {
            if (t.peerConnection.setLocalDescription(e), t.state = "offer-received-preparing-answer", t.iceStarted) t.markActionNeeded();else {
              var n = new Date();
              r.default.debug("[" + t.clientId + "]" + n.getTime() + ": Starting ICE in responder"), t.iceStarted = !0;
            }
          }, function () {
            r.default.debug("[" + t.clientId + "]Ups! Something went wrong");
          });else if ("offer-received-preparing-answer" === t.state) {
            if (t.moreIceComing) return;
            var e = t.peerConnection.localDescription.sdp;
            t.sendMessage("ANSWER", e), t.state = "established";
          } else t.error("Dazed and confused in state " + t.state + ", stopping here");
          t.actionNeeded = !1;
        }
      }, t.sendOK = function () {
        t.sendMessage("OK");
      }, t.sendMessage = function (e, n) {
        var i = {};
        i.messageType = e, i.sdp = n, "OFFER" === e ? (i.offererSessionId = t.sessionId, i.answererSessionId = t.otherSessionId, i.seq = t.sequenceNumber += 1, i.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (i.offererSessionId = t.incomingMessage.offererSessionId, i.answererSessionId = t.sessionId, i.seq = t.incomingMessage.seq), t.onsignalingmessage(JSON.stringify(i));
      }, t._getSender = function (e) {
        if (t.peerConnection && t.peerConnection.getSenders) {
          var n = t.peerConnection.getSenders().find(function (t) {
            return t.track.kind == e;
          });
          if (n) return n;
        }

        return null;
      }, t.hasSender = function (e) {
        return !!t._getSender(e);
      }, t.replaceTrack = function (e, n, i) {
        var o = t._getSender(e.kind);

        if (!o) return i("NO_SENDER_FOUND");

        try {
          o.replaceTrack(e);
        } catch (e) {
          return i && i(e);
        }

        setTimeout(function () {
          return n && n();
        }, 50);
      }, t.error = function (e) {
        throw "Error in RoapOnJsep: " + e;
      }, t.sessionId = t.roapSessionId += 1, t.sequenceNumber = 0, t.actionNeeded = !1, t.iceStarted = !1, t.moreIceComing = !0, t.iceCandidateCount = 0, t.onsignalingmessage = e.callback, t.peerConnection.ontrack = function (e) {
        t.onaddstream && t.onaddstream(e, "ontrack");
      }, t.peerConnection.onremovestream = function (e) {
        t.onremovestream && t.onremovestream(e);
      }, t.peerConnection.oniceconnectionstatechange = function (e) {
        "connected" === e.currentTarget.iceConnectionState && (t.connectedTime = new Date()), t.oniceconnectionstatechange && t.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      };

      var l = function l(t) {
        var n;

        if (e.video && e.maxVideoBW && (null == (n = t.match(/m=video.*\r\n/)) && (n = t.match(/m=video.*\n/)), n && n.length > 0)) {
          var i = n[0] + "b=TIAS:" + 1e3 * e.maxVideoBW + "\r\n";
          t = t.replace(n[0], i);
        }

        return e.audio && e.maxAudioBW && (null == (n = t.match(/m=audio.*\r\n/)) && (n = t.match(/m=audio.*\n/)), n && n.length > 0) && (i = n[0] + "b=TIAS:" + 1e3 * e.maxAudioBW + "\r\n", t = t.replace(n[0], i)), t;
      };

      return t.onaddstream = null, t.onremovestream = null, t.state = "new", t.markActionNeeded(), t;
    },
        D = n(13),
        k = n.n(D),
        M = null,
        L = function L() {
      try {
        M = window.require("electron");
      } catch (e) {}

      return M;
    },
        P = function P(e) {
      var t = a.b.reportApiInvoke(null, {
        callback: e,
        name: "getScreenSources",
        options: arguments,
        tag: "tracer"
      }),
          n = L();
      if (!n) return t && t("electron is null");
      n.desktopCapturer.getSources({
        types: ["window", "screen"]
      }, function (e, n) {
        if (e) return t && t(e);
        t && t(null, n);
      });
    },
        x = function x(e, t, n) {
      var i = t.width;
      t = {
        audio: !1,
        video: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: e,
            maxHeight: t.height,
            maxWidth: i,
            maxFrameRate: t.frameRate && t.frameRate.max,
            minFrameRate: t.frameRate && t.frameRate.min
          }
        }
      };
      navigator.webkitGetUserMedia(t, function (e) {
        n && n(null, e);
      }, function (e) {
        n && n(e);
      });
    },
        V = function V() {
      return !!L();
    },
        U = P,
        F = x,
        B = function B(e, t) {
      P(function (n, i) {
        if (n) return t && t(n);
        !function (e, t) {
          var n = document.createElement("div");
          n.innerText = "share screen", n.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
          var i = document.createElement("div");
          i.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
          var o = document.createElement("div");
          o.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o.setAttribute("style", "height: 12%;");
          var r = document.createElement("div");
          r.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
          var a = document.createElement("div");
          a.setAttribute("style", "text-align: right; padding: 16px 0;");
          var s = document.createElement("button");
          s.innerHTML = "cancel", s.setAttribute("style", "width: 85px;"), s.onclick = function () {
            document.body.removeChild(c), t && t("NotAllowedError");
          }, a.appendChild(s), i.appendChild(o), i.appendChild(r), i.appendChild(a);
          var c = document.createElement("div");
          c.setAttribute("style", "position: absolute; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), c.appendChild(n), c.appendChild(i), document.body.appendChild(c), e.map(function (e) {
            if (e.id) {
              var n = document.createElement("div");
              n.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;"), n.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + e.thumbnail.toDataURL() + ' /></div><span style="\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e.name + "</span>", n.onclick = function () {
                document.body.removeChild(c), t && t(null, e.id);
              }, r.appendChild(n);
            }
          });
        }(i, function (n, i) {
          if (n) return t && t(n);
          x(i, e, t);
        });
      });
    },
        j = 103,
        W = function W(e) {
      var t = {};
      if (t.clientId = e.clientId, e.session_id = j += 1, "undefined" == typeof window || !window.navigator) throw r.default.error("[" + t.streamId + "][" + t.clientId + "]Publish/subscribe video/audio streams not supported yet"), new Error("NON_BROWSER_ENV_DETECTED");
      return null !== window.navigator.userAgent.match("Firefox") ? (t.browser = "mozilla", t = N(e)) : "iOS" === f.getBrowserOS() || f.isSafari() ? (r.default.debug("[" + t.streamId + "][" + t.clientId + "]Safari"), (t = w(e)).browser = "safari") : ~window.navigator.userAgent.indexOf("Edge") ? t = new k.a(e) : (t = O(e)).browser = "chrome-stable", t;
    },
        H = function H(e, t, n) {
      var i = {};
      i.config = e, i.streamId = e.streamId, delete e.streamId, navigator.getMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

      var o = 0,
          a = 1,
          s = !1,
          c = null,
          d = function d(e) {
        if (o++, c) {
          if (c === e) r.default.debug("Using Video Source/ Audio Source");else {
            var n = c.getVideoTracks()[0],
                i = c.getAudioTracks()[0],
                d = e.getVideoTracks()[0],
                u = e.getAudioTracks()[0];
            d && (n && c.removeTrack(n), c.addTrack(d)), u && (i && c.removeTrack(i), c.addTrack(u));
          }
        } else c = e;
        o !== a || s || (s = !0, setTimeout(function () {
          t(c);
        }, 0));
      },
          u = function u(e) {
        r.default.error("Failed to GetUserMedia", e.name, e.code, e.message, e), o++, s || (s = !0, setTimeout(function () {
          n && n(e);
        }, 0));
      },
          l = function l() {
        var t = {
          video: e.video,
          audio: e.audio
        };
        if (r.default.debug("GetUserMedia", JSON.stringify(t)), navigator.mediaDevices && navigator.mediaDevices.getUserMedia) navigator.mediaDevices.getUserMedia(t).then(d).catch(u);else if ("undefined" != typeof navigator && navigator.getMedia) navigator.getMedia(e, d, u);else {
          var o = {
            name: "MEDIA_NOT_SUPPORT",
            message: "Video/audio streams not supported yet"
          };
          r.default.error("[" + i.streamId + "]" + o.message), n && n(o);
        }
      };

      if ((e.videoSource || e.audioSource) && (c = new MediaStream(), e.videoSource && c.addTrack(e.videoSource), e.audioSource && c.addTrack(e.audioSource)), e.video || e.audio || e.screen) {
        if (e.screen) {
          if (V()) return e.screen.sourceId ? F(e.screen.sourceId, e.screen, function (e, t) {
            e ? u(e) : d(t);
          }) : B(e.screen, function (e, t) {
            e ? u(e) : d(t);
          });

          if (f.isFireFox()) {
            r.default.debug("[" + i.streamId + "]Screen access requested");
            if (!~["screen", "window", "application"].indexOf(e.screen.mediaSource)) return n && n("Invalid mediaSource, mediaSource should be one of [screen, window, application]");
            navigator.getMedia({
              video: e.screen
            }, function (t) {
              e.audio && (a++, l()), d(t);
            }, u);
          } else if (f.isChrome() && e.screen.extensionId) {
            if (window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] < 34) return void n({
              code: "This browser does not support screen sharing"
            });
            r.default.debug("[" + i.streamId + "]Screen access on chrome stable, looking for extension");

            try {
              chrome.runtime.sendMessage(e.screen.extensionId, {
                getStream: !0
              }, function (t) {
                if (void 0 === t) {
                  r.default.error("[" + i.streamId + "]No response from Chrome Plugin. Plugin not installed properly");
                  u({
                    name: "PluginNotInstalledProperly",
                    message: "No response from Chrome Plugin. Plugin not installed properly."
                  });
                } else e.screen.mandatory.chromeMediaSourceId = t.streamId, navigator.getMedia({
                  video: e.screen
                }, function (t) {
                  e.audio && (a++, l()), d(t);
                }, u);
              });
            } catch (e) {
              r.default.debug("[" + i.streamId + "]AgoraRTC screensharing plugin is not accessible");
              return void n({
                code: "no_plugin_present"
              });
            }
          } else {
            if (window.navigator.mediaDevices.getDisplayMedia) {
              var p = {};
              return "number" == typeof e.screen.width && "number" == typeof e.screen.height ? p.video = {
                width: {
                  ideal: e.screen.width
                },
                height: {
                  ideal: e.screen.height
                }
              } : p.video = {
                width: e.screen.width,
                height: e.screen.height
              }, e.screen.frameRate && e.screen.frameRate.min ? p.video.frameRate = {
                ideal: e.screen.frameRate.max,
                max: e.screen.frameRate.max
              } : p.video.frameRate = e.screen.frameRate, r.default.debug("use getDisplayMedia, constraints:", p), window.navigator.mediaDevices.getDisplayMedia(p).then(function (t) {
                e.audio && (a++, l()), d(t);
              }).catch(u);
            }

            r.default.error("[" + i.streamId + "]This browser does not support screenSharing");
          }
        } else l();
      } else d(c);
    },
        G = n(7),
        J = function J(e, t, n) {
      if (["End2EndDelay", "TransportDelay", "PacketLossRate", "RecvLevel", "RecvBitrate", "CodecType", "MuteState", "TotalFreezeTime", "TotalPlayDuration", "RecordingLevel", "SendLevel", "SamplingRate", "SendBitrate", "CodecType", "MuteState", "End2EndDelay", "TransportDelay", "PacketLossRate", "RecvBitrate", "RecvResolutionWidth", "RecvResolutionHeight", "RenderResolutionHeight", "RenderResolutionWidth", "RenderFrameRate", "TotalFreezeTime", "TotalPlayDuration", "TargetSendBitrate", "SendFrameRate", "SendFrameRate", "SendBitrate", "SendResolutionWidth", "SendResolutionHeight", "CaptureResolutionHeight", "CaptureResolutionWidth", "EncodeDelay", "MuteState", "TotalFreezeTime", "TotalDuration", "CaptureFrameRate", "RTT", "OutgoingAvailableBandwidth", "Duration", "UserCount", "SendBytes", "RecvBytes", "SendBitrate", "RecvBitrate", "accessDelay", "audioSendBytes", "audioSendPackets", "videoSendBytes", "videoSendPackets", "videoSendPacketsLost", "videoSendFrameRate", "audioSendPacketsLost", "videoSendResolutionWidth", "videoSendResolutionHeight", "accessDelay", "audioReceiveBytes", "audioReceivePackets", "audioReceivePacketsLost", "videoReceiveBytes", "videoReceivePackets", "videoReceivePacketsLost", "videoReceiveFrameRate", "videoReceiveDecodeFrameRate", "videoReceiveResolutionWidth", "videoReceiveResolutionHeight", "endToEndDelay", "videoReceiveDelay", "audioReceiveDelay", "FirstFrameTime", "VideoFreezeRate", "AudioFreezeRate", "RenderResolutionWidth", "RenderResolutionHeight"].indexOf(t) > -1 && ("string" == typeof n || isFinite(n))) return e[t] = "" + n;
    },
        Y = new function () {
      var e = s();
      return e.devicesHistory = {}, e.states = {
        UNINIT: "UNINIT",
        INITING: "INITING",
        INITED: "INITED"
      }, e.state = e.states.UNINIT, e.deviceStates = {
        ACTIVE: "ACTIVE",
        INACTIVE: "INACTIVE"
      }, e.deviceReloadTimer = null, e._init = function (t, n) {
        e.state = e.states.INITING, e.devicesHistory = {}, e._reloadDevicesInfo(function () {
          e.state = e.states.INITED, e.dispatchEvent({
            type: "inited"
          }), t && t();
        }, function (t) {
          r.default.warning("Device Detection functionality cannot start properly."), e.state = e.states.UNINIT, n && n(t);
        });
      }, e._enumerateDevices = function (e, t) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return r.default.warning("enumerateDevices() not supported."), t && t("enumerateDevices() not supported");
        navigator.mediaDevices.enumerateDevices().then(function (t) {
          e && setTimeout(function () {
            e(t);
          }, 0);
        }).catch(function (e) {
          t && t(e);
        });
      }, e._reloadDevicesInfo = function (t, n) {
        var i = [];

        e._enumerateDevices(function (n) {
          var o = Date.now();

          for (var a in n.forEach(function (t) {
            var n = e.devicesHistory[t.deviceId];

            if ((n ? n.state : e.deviceStates.INACTIVE) != e.deviceStates.ACTIVE) {
              var r = n || {
                initAt: o
              };
              r.device = t, r.state = e.deviceStates.ACTIVE, i.push(r), e.devicesHistory[t.deviceId] = r;
            }

            e.devicesHistory[t.deviceId].lastReloadAt = o;
          }), e.devicesHistory) {
            var s = e.devicesHistory[a];
            s && s.state == e.deviceStates.ACTIVE && s.lastReloadAt !== o && (s.state = e.deviceStates.INACTIVE, i.push(s)), s.lastReloadAt = o;
          }

          e.state == e.states.INITED && i.forEach(function (t) {
            var n = S()({}, t);

            switch (t.device.kind) {
              case "audioinput":
                n.type = "recordingDeviceChanged";
                break;

              case "audiooutput":
                n.type = "playoutDeviceChanged";
                break;

              case "videoinput":
                n.type = "cameraChanged";
                break;

              default:
                r.default.warning("Unknown device change", n), n.type = "unknownDeviceChanged";
            }

            e.dispatchEvent(n);
          }), t && t();
        }, n);
      }, e.getDeviceById = function (t, n, i) {
        e.getDevices(function (e) {
          for (var o = 0; o < e.length; o++) {
            var r = e[o];
            if (r && r.deviceId === t) return n && n(r);
          }

          return i && i();
        });
      }, e.searchDeviceNameById = function (t) {
        var n = e.devicesHistory[t];
        return n ? n.device.label || n.device.deviceId : null;
      }, e.getDevices = function (t, n) {
        e._enumerateDevices(t, function (e) {
          n && n(e.name + ": " + e.message);
        });
      }, e.getVideoCameraIdByLabel = function (t, n, i) {
        e.getCameras(function (e) {
          var o = !0,
              r = !1,
              a = void 0;

          try {
            for (var s, c = e[Symbol.iterator](); !(o = (s = c.next()).done); o = !0) {
              var d = s.value;
              if (d.label === t) return n && n(d.deviceId);
            }
          } catch (e) {
            r = !0, a = e;
          } finally {
            try {
              o || null == c.return || c.return();
            } finally {
              if (r) throw a;
            }
          }

          return i && i(A.NOT_FIND_DEVICE_BY_LABEL);
        }, i);
      }, e.getRecordingDevices = function (t, n) {
        return e._enumerateDevices(function (e) {
          var n = e.filter(function (e) {
            return "audioinput" == e.kind;
          });
          t && t(n);
        }, function (e) {
          n && n(e);
        });
      }, e.getPlayoutDevices = function (t, n) {
        return e._enumerateDevices(function (e) {
          var n = e.filter(function (e) {
            return "audiooutput" == e.kind;
          });
          t && t(n);
        }, function (e) {
          n && n(e);
        });
      }, e.getCameras = function (t, n) {
        return e._enumerateDevices(function (e) {
          var n = e.filter(function (e) {
            return "videoinput" == e.kind;
          });
          t && t(n);
        }, function (e) {
          n && n(e);
        });
      }, e._init(function () {
        navigator.mediaDevices && navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", function () {
          e._reloadDevicesInfo();
        }), e.deviceReloadTimer = setInterval(e._reloadDevicesInfo, 5e3);
      }), e;
    }(),
        z = n(5),
        q = n.n(z),
        K = function K(e, t, n) {
      for (var i = 0; i < n.length; i++) {
        if (e === n[i]) return !0;
      }

      throw new Error("".concat(t, " can only be set as ").concat(JSON.stringify(n)));
    },
        X = function X(e, t) {
      if (!e) throw new Error("Invalid param: ".concat(t || "param", " cannot be empty"));
      if ("object" !== q()(e)) throw new Error("".concat(t || "This paramter", " is of the object type"));
      return !0;
    },
        Q = function Q(e, t, n, i, o) {
      if (se(n) && (n = 1), i = i || 255, se(o) && (o = !0), se(e)) throw new Error("".concat(t || "param", " cannot be empty"));
      if (!ee(e, n, i, o)) throw new Error("Invalid ".concat(t || "string param", ": Length of the string: [").concat(n, ",").concat(i, "].").concat(o ? " ASCII characters only." : ""));
    },
        $ = function $(e, t, n, i) {
      if (se(n) && (n = 1), i = i || 1e4, se(e)) throw new Error("".concat(t || "param", " cannot be empty"));
      if (!te(e, n, i)) throw new Error("Invalid ".concat(t || "number param", ": The value range is [").concat(n, ",").concat(i, "]. integer only"));
    },
        Z = function Z(e, t) {
      if (se(e)) throw new Error("".concat(t || "param", " cannot be empty"));
      if (!ne(e)) throw new Error("Invalid ".concat(t || "boolean param", ": The value is of the boolean type."));
    },
        ee = function ee(e, t, n, i) {
      return t || (t = 0), n || (n = Number.MAX_SAFE_INTEGER), se(i) && (i = !0), ae(e) && (!i || oe(e)) && e.length >= t && e.length <= n;
    },
        te = function te(e, t, n) {
      return re(e) && e >= t && e <= n;
    },
        ne = function ne(e) {
      return "boolean" == typeof e;
    },
        ie = function ie(e) {
      return ee(e, 1, 2047);
    },
        oe = function oe(e) {
      if ("string" == typeof e) {
        for (var t = 0; t < e.length; t++) {
          var n = e.charCodeAt(t);
          if (n < 0 || n > 255) return !1;
        }

        return !0;
      }
    },
        re = function re(e) {
      return "number" == typeof e && e % 1 == 0;
    },
        ae = function ae(e) {
      return "string" == typeof e;
    },
        se = function se(e) {
      return null == e;
    },
        ce = n(12);

    var de = function de(e) {
      Q(e, "profileName"), -1 === (e = e.toLowerCase()).indexOf("_") && (e += "_1"), K(e, "profileName", Object.keys(o.SUPPORT_RESOLUTION_LIST));
      var t = o.SUPPORT_RESOLUTION_LIST[e];
      t || (e = Object(o.getParameter)("DEFAULT_PROFILE"), t = o.SUPPORT_RESOLUTION_LIST[e]);
      var n = {
        profileName: e,
        video: {
          width: t[0],
          height: t[1]
        },
        attributes: {
          resolution: "".concat(t[0], "x").concat(t[1]),
          minFrameRate: t[2],
          maxFrameRate: t[3],
          minVideoBW: t[4],
          maxVideoBW: t[5]
        }
      };
      return t[2] && t[3] && (n.video.frameRate = {
        ideal: t[2],
        max: t[3]
      }), t[6] && t[7] && (n.screen = {
        width: t[0],
        height: t[1],
        frameRate: {
          min: t[6],
          max: t[7]
        }
      }), n;
    },
        ue = function ue(e) {
      return Object.keys(o.SUPPORT_RESOLUTION_LIST).filter(function (t) {
        var n = o.SUPPORT_RESOLUTION_LIST[t],
            i = ["width", "height", "frameRate"];

        for (var r in i) {
          var a = i[r];

          if (e[a] && n[r]) {
            if ("number" == typeof e[a].max && e[a].max < n[r]) return !1;
            if ("number" == typeof e[a].min && e[a].min > n[r]) return !1;
          }
        }

        return !0;
      }).reverse();
    },
        le = function le(e) {
      var t = o.AUDIO_PROFILE_SETTINGS[e] || o.AUDIO_PROFILE_SETTINGS.default;
      return {
        highQuality: t[0],
        stereo: t[1],
        speech: t[2],
        lowQuality: t[3]
      };
    };

    var pe = function pe(e) {
      var t = s();
      if (t.params = S()({}, e), t.stream = e.stream, t.url = e.url, t.onClose = void 0, t.local = !1, t.videoSource = e.videoSource, t.audioSource = e.audioSource, e.video = !(!e.videoSource && !e.video), t.video = e.video, e.audio = !(!e.audioSource && !e.audio), t.audio = e.audio, t.screen = !!e.screen, t.screenAttributes = {
        width: 1920,
        height: 1080,
        maxFr: 5,
        minFr: 1
      }, t.videoSize = e.videoSize, t.player = void 0, t.audioLevelHelper = null, e.attributes = e.attributes || {}, t.attributes = e.attributes, t.microphoneId = e.microphoneId, t.cameraId = e.cameraId, t.inSwitchDevice = !1, t.userMuteVideo = !1, t.userMuteAudio = !1, t.peerMuteVideo = !1, t.peerMuteAudio = !1, t.lowStream = null, t.videoWidth = 0, t.videoHeight = 0, t.streamId = e.streamID, t.userId = null, t.mirror = !1 !== e.mirror, t.DTX = e.audioProcessing && e.audioProcessing.DTX, t.audioProcessing = e.audioProcessing, t.highQuality = !1, t.stereo = !1, t.speech = !1, t.screen || delete t.screen, !(void 0 === t.videoSize || t.videoSize instanceof Array && 4 === t.videoSize.length)) throw Error("Invalid Video Size");

      function n() {
        var e = {};
        t.getVideoTrack() === this ? (r.default.debug("Video Track Ended"), e.type = "videoTrackEnded", e.track = this) : t.getAudioTrack() === this ? (r.default.debug("Audio Track Ended"), e.type = "audioTrackEnded", e.track = this) : r.default.debug("Detached Track ended", this.kind, this.label, this), e.type && t.dispatchEvent(e);
      }

      return t.videoSize = [640, 480, 640, 480], void 0 !== e.local && !0 !== e.local || (t.local = !0), t.initialized = !t.local, function (e) {
        e.audioMixing = {
          audioContextInited: !1,
          defaultVolume: 100,
          inEarMonitoring: "FILE",
          sounds: {},
          states: {
            IDLE: "IDLE",
            STARTING: "STARTING",
            BUSY: "BUSY",
            PAUSED: "PAUSED"
          },
          inEarMonitoringModes: {
            NONE: "NONE",
            FILE: "FILE",
            MICROPHONE: "MOCROPHONE",
            ALL: "ALL"
          },
          ctx: null,
          mediaStreamSource: null,
          mediaStreamDest: null,
          buffer: {}
        }, e._initSoundIfNotExists = function (t, n) {
          e.audioMixing.sounds[t] || (e.audioMixing.sounds[t] = {
            soundId: t,
            state: "IDLE",
            muted: e.userMuteAudio,
            filePath: n,
            volume: e.audioMixing.defaultVolume,
            startAt: null,
            startOffset: null,
            pauseAt: null,
            pauseOffset: null,
            resumeAt: null,
            resumeOffset: null,
            stopAt: null,
            options: null,
            source: null
          });
        }, e._initSoundIfNotExists(-1), e.loadAudioBuffer = function (t, n, i) {
          var o = a.b.reportApiInvoke(e.sid, {
            callback: i,
            name: "Stream.loadAudioBuffer",
            options: arguments,
            tag: "tracer"
          });
          Q(n, "url", 1, 1024, !1), Q(t, "id", 1, 1024, !1);
          var s = new XMLHttpRequest();
          s.open("GET", n, !0), s.responseType = "arraybuffer", s.onload = function () {
            if (s.status > 400) {
              var n = s.statusText;
              return r.default.error("[".concat(e.streamId, "] loadAudioBuffer Failed: ") + n), o(n);
            }

            var i = s.response;
            e.audioMixing.audioContextInited || e._initAudioContext(), e.audioMixing.ctx.decodeAudioData(i, function (n) {
              e.audioMixing.buffer[t] = n, o(null);
            }, function (t) {
              r.default.error("[".concat(e.streamId, "] decodeAudioData Failed: "), t), o(t);
            });
          }, s.send();
        }, e.createAudioBufferSource = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            name: "Stream.createAudioBufferSource",
            options: arguments,
            tag: "tracer"
          });

          if (e.audioMixing.buffer[t.id]) {
            var i = e.audioMixing.buffer[t.id],
                o = e.audioMixing.ctx.createBufferSource();
            o.buffer = i;
            var s = e.audioMixing.ctx.createGain();
            if (o.connect(s), s.connect(e.audioMixing.mediaStreamDest), o.gainNode = s, t.loop) o.loop = !0, o.start(0, t.playTime / 1e3);else if (t.cycle > 1) {
              if (Object(f.isChrome)()) {
                o.loop = !0;
                var c = t.cycle * i.duration * 1e3 - (t.playTime || 0);
                o.start(0, t.playTime / 1e3, c / 1e3);
              } else r.default.warning("[".concat(e.streamId, "] Cycle Param is ignored by current browser")), o.start(0, t.playTime / 1e3);
            } else o.start(0, t.playTime / 1e3);
            var d = e.audioMixing.sounds[t.soundId];
            return d.source = o, e._flushAudioMixingMuteStatus(), o.addEventListener("ended", function () {
              o === d.source && e.dispatchEvent({
                type: "audioSourceEnded",
                soundId: t.soundId,
                source: o,
                sound: d
              });
            }), n(), o;
          }

          return r.default.error("[".concat(e.streamId, "] "), "AUDIOBUFFER_NOT_FOUND", t.id), n(!1), !1;
        }, e.on("audioSourceEnded", function (t) {
          t.source;
          var n = t.sound;
          n && n.state === e.audioMixing.states.BUSY && !n.pauseAt && (n.state = e.audioMixing.states.IDLE, n.startAt = null, n.startOffset = null, n.resumeAt = null, n.resumeOffset = null, e.audioMixing.mediaStreamSource.connect(e.audioMixing.mediaStreamDest));
        }), e.clearAudioBufferSource = function () {
          e.audioBufferSource.forEach(function (e) {
            e.stop();
          });
        }, e._isSoundExists = function (t) {
          return !!e.audioMixing.sounds[t.soundId] || (r.default.error("SoundId not exists. #".concat(t.soundId)), !1);
        }, e._initAudioContext = function () {
          if (e.audioMixing.audioContextInited) throw new Error("Failed to init audio context. Already inited");
          if (!e.stream) throw new Error("Failed to init audio context. Local Stream not initialized");
          e.audioMixing.ctx = Object(ce.a)(), e.audioMixing.mediaStreamSource = e.audioMixing.ctx.createMediaStreamSource(e.stream), e.audioMixing.mediaStreamDest = e.audioMixing.ctx.createMediaStreamDestination(), e.audioMixing.mediaStreamSource.connect(e.audioMixing.mediaStreamDest);
          var t = e.stream.getVideoTracks()[0];

          if (t && e.audioMixing.mediaStreamDest.stream.addTrack(t), e._isAudioMuted() ? (e._unmuteAudio(), e.stream = e.audioMixing.mediaStreamDest.stream, e._muteAudio()) : e.stream = e.audioMixing.mediaStreamDest.stream, e.audioLevelHelper = null, e.pc && e.pc.peerConnection && e.pc.peerConnection) {
            var n = (e.pc.peerConnection && e.pc.peerConnection.getSenders()).find(function (e) {
              return e && e.track && "audio" == e.track.kind;
            }),
                i = e.audioMixing.mediaStreamDest.stream.getAudioTracks()[0];
            n && n.replaceTrack && i && n.replaceTrack(i);
          }

          e.audioMixing.audioContextInited = !0;
        }, e._cleanupAudioMixing = function () {
          if (e.audioMixing.audioContextInited) {
            for (var t in e.audioMixing.sounds) {
              var n = e.audioMixing.sounds[t];
              n.state !== e.audioMixing.states.BUSY && n.state !== e.audioMixing.states.PAUSED || e._stopOneEffect({
                soundId: t
              });
            }

            e.audioLevelHelper = null, e.audioMixing.audioContextInited = !1;
          }
        }, e._reloadInEarMonitoringMode = function (t) {
          if (t) {
            if (!e.audioMixing.inEarMonitoringModes[t]) return r.default.error("[".concat(e.streamId, "] Invalid InEarMonitoringMode ").concat(t));
            e.audioMixing.inEarMonitoring = t;
          }

          switch (e.audioMixing.audioContextInited || e._initAudioContext(), e.audioMixing.inEarMonitoring) {
            case e.audioMixing.inEarMonitoringModes.FILE:
              e.audioMixing.mediaStreamSource.connectedToDestination && (e.audioMixing.mediaStreamSource.disconnect(e.audioMixing.ctx.destination), e.audioMixing.mediaStreamSource.connectedToDestination = !1);

            case e.audioMixing.inEarMonitoringModes.ALL:
              for (var n in e.audioMixing.sounds) {
                var i = e.audioMixing.sounds[n];
                i && i.source && !i.source.connectedToDestination && (i.source.gainNode.connect(e.audioMixing.ctx.destination), i.source.connectedToDestination = !0);
              }

          }

          switch (e.audioMixing.inEarMonitoring) {
            case e.audioMixing.inEarMonitoringModes.MICROPHONE:
              e.audioMixing.source.forEach(function (t) {
                t.connectedToDestination && (t.gainNode.disconnect(e.audioMixing.ctx.destination), t.connectedToDestination = !1);
              });

            case e.audioMixing.inEarMonitoringModes.ALL:
              e.audioMixing.mediaStreamSource.connectedToDestination || (e.audioMixing.mediaStreamSource.connect(e.audioMixing.ctx.destination), e.audioMixing.mediaStreamSource.connectedToDestination = !0);
          }
        }, e._startAudioMixingBufferSource = function (t) {
          e.audioMixing.audioContextInited || e._initAudioContext();
          var n = {
            soundId: t.soundId,
            id: t.filePath,
            loop: t.loop,
            cycle: t.cycle,
            playTime: t.playTime || 0
          },
              i = t.replace,
              o = e.createAudioBufferSource(n);
          return o.sound = e.audioMixing.sounds[t.soundId], o ? (o.addEventListener("ended", e._audioMixingFinishedListener, {
            once: !0
          }), e._reloadInEarMonitoringMode(), i && e.audioMixing.mediaStreamSource.disconnect(e.audioMixing.mediaStreamDest), o) : null;
        }, e._stopAudioMixingBufferSource = function (t) {
          var n = e.audioMixing.sounds[t.soundId].source;
          return n ? (n.removeEventListener("ended", e._audioMixingFinishedListener), e.audioMixing.mediaStreamSource.connect(e.audioMixing.mediaStreamDest), n.stop(), n) : null;
        }, e._flushAudioMixingMuteStatus = function (t) {
          for (var n in e.audioMixing.sounds) {
            var i = e.audioMixing.sounds[n];
            i && (void 0 !== t && (i.muted = !!t), i.source && (i.muted ? i.source.gainNode.gain.value = 0 : i.source.gainNode.gain.value = i.volume / 100));
          }
        }, e._handleAudioMixingInvalidStateError = function (t, n, i) {
          var o = e.audioMixing.sounds[n.soundId],
              a = -1 === n.soundId ? "INVALID_AUDIO_MIXING_STATE" : "INVALID_PLAY_EFFECT_STATE";
          r.default.error("[".concat(e.streamId, "] Cannot ").concat(t, ": ").concat(a, ", state is ").concat(o.state)), i && i(a);
        }, e._handleAudioMixingNoSourceError = function (t, n, i) {
          e.audioMixing.sounds[n.soundId].state = e.audioMixing.states.IDLE;
          var o = -1 === n.soundId ? "NO_AUDIO_MIXING_SOURCE" : "NO_EFFECT_SOURCE";
          r.default.error("[".concat(e.streamId, "] Cannot ").concat(t, ": ").concat(o)), i && i(o);
        }, e._getOneEffectStates = function (t) {
          var n = e.audioMixing.sounds[t.soundId];
          return function () {
            return n ? {
              state: n.state,
              startAt: n.startAt,
              resumeAt: n.resumeAt,
              pauseOffset: n.pauseOffset,
              pauseAt: n.pauseAt,
              resumeOffset: n.resumeOffset,
              stopAt: n.stopAt,
              duration: e._getOneEffectDuration(t),
              position: e._getOneEffectCurrentPosition(t)
            } : {};
          };
        }, e._audioMixingFinishedListener = function () {
          var t = this.sound;
          t.state === e.audioMixing.states.IDLE && e.audioMixing.buffer[t.options.filePath] && !t.options.cacheResource && (r.default.debug("Recycled buffer ".concat(t.options.filePath)), delete e.audioMixing.buffer[t.options.filePath]), -1 === t.soundId && e.dispatchEvent({
            type: "audioMixingFinished"
          });
        }, e._playOneEffect = function (t, n) {
          X(t, "options");
          var i = t.soundId,
              o = (t.filePath, t.cacheResource);

          if (t.cycle, t.loop, t.playTime, t.replace, Object(f.isSafari)() && Object(f.getBrowserVersion)() < 12) {
            var a = "BROWSER_NOT_SUPPORT";
            return r.default.error("[".concat(e.streamId, "] Cannot _playOneEffect: "), a), n(a);
          }

          e.audioMixing.audioContextInited || e._initAudioContext(), e._initSoundIfNotExists(i);
          var s = e.audioMixing.sounds[i];

          if (s.state === e.audioMixing.states.IDLE) {
            if (void 0 !== t.cycle && !t.cycle > 0) return a = "Invalid Parmeter cycle: " + t.cycle, r.default.error("[".concat(e.streamId, "] ").concat(i), a), n(a);

            if (se(o) && (t.cacheResource = !0), s.state = e.audioMixing.states.STARTING, s.options = t, e.audioMixing.buffer[t.filePath]) {
              var c = e._startAudioMixingBufferSource(t);

              if (c) return s.source = c, s.startAt = Date.now(), s.resumeAt = null, s.pauseOffset = null, s.pauseAt = null, s.resumeOffset = null, s.stopAt = null, s.startOffset = t.playTime || 0, s.state = e.audioMixing.states.BUSY, e._flushAudioMixingMuteStatus(), n(null);
              s.state = e.audioMixing.states.IDLE;
              var d = "CREATE_BUFFERSOURCE_FAILED";
              if (n) return n(d);
              r.default.error("[".concat(e.streamId, "] "), d);
            } else e.loadAudioBuffer(t.filePath, t.filePath, function (i) {
              if (i) s.state = e.audioMixing.states.IDLE, n ? n(i) : r.default.error("[".concat(e.streamId, "] "), i);else {
                var o = e._startAudioMixingBufferSource(t);

                if (o) return s.source = o, s.startAt = Date.now(), s.resumeAt = null, s.pauseOffset = null, s.pauseAt = null, s.resumeOffset = null, s.stopAt = null, s.startOffset = t.playTime || 0, s.state = e.audioMixing.states.BUSY, e._flushAudioMixingMuteStatus(), n(null);
                if (s.state = e.audioMixing.states.IDLE, i = "CREATE_BUFFERSOURCE_FAILED", n) return n(i);
                r.default.error("[".concat(e.streamId, "] "), i);
              }
            });
          } else e._handleAudioMixingInvalidStateError("_playEffect", t, n);
        }, e._stopOneEffect = function (t, n) {
          var i = e.audioMixing.sounds[t.soundId];
          return e._isSoundExists(t) ? i.state === e.audioMixing.states.BUSY || i.state === e.audioMixing.states.PAUSED ? (e._stopAudioMixingBufferSource(t), i.stopAt = Date.now(), i.state = e.audioMixing.states.IDLE, e.audioMixing.buffer[i.options.filePath] && !i.options.cacheResource && (r.default.debug("Recycled buffer ".concat(i.options.filePath)), delete e.audioMixing.buffer[i.options.filePath]), void (n && n(null))) : void e._handleAudioMixingInvalidStateError("_stopOneEffect", t, n) : n("SOUND_NOT_EXISTS");
        }, e._pauseOneEffect = function (t, n) {
          var i = e.audioMixing.sounds[t.soundId];
          if (i.state === e.audioMixing.states.BUSY) return e._stopAudioMixingBufferSource(t) ? (i.pauseAt = Date.now(), i.state = e.audioMixing.states.PAUSED, i.resumeAt ? i.pauseOffset = i.pauseAt - i.resumeAt + i.resumeOffset : i.pauseOffset = i.pauseAt - i.startAt + i.startOffset, n && n(null)) : void e._handleAudioMixingNoSourceError("_pauseOneEffect", t, n);

          e._handleAudioMixingInvalidStateError("_pauseOneEffect", t, n);
        }, e._resumeOneEffect = function (t, n) {
          var i = e.audioMixing.sounds[t.soundId];

          if (i.state === e.audioMixing.states.PAUSED) {
            var o = {
              soundId: t.soundId,
              filePath: i.options.filePath,
              cycle: i.options.cycle,
              loop: i.options.loop,
              playTime: i.pauseOffset,
              replace: i.options.replace
            },
                a = e._startAudioMixingBufferSource(o);

            if (!a) {
              var s = "CREATE_BUFFERSOURCE_FAILED";
              return n(s), void r.default.error("[".concat(e.streamId, "] "), s);
            }

            i.source = a, i.resumeAt = Date.now(), i.resumeOffset = i.pauseOffset, i.state = e.audioMixing.states.BUSY, i.pauseAt = null, i.pauseOffset = null, n(null);
          } else e._handleAudioMixingInvalidStateError("_resumeOneEffect", t, n);
        }, e._getOneEffectDuration = function (t) {
          var n = e.audioMixing.sounds[t.soundId];
          return n.options && n.options.filePath && e.audioMixing.buffer[n.options.filePath] ? 1e3 * e.audioMixing.buffer[n.options.filePath].duration : null;
        }, e._getOneEffectCurrentPosition = function (t, n) {
          var i = e.audioMixing.sounds[t.soundId];
          return i.state === e.audioMixing.states.PAUSED ? i.pauseOffset % e._getOneEffectDuration(t) : i.state === e.audioMixing.states.BUSY ? i.resumeAt ? (Date.now() - i.resumeAt + i.resumeOffset + i.startOffset) % e._getOneEffectDuration(t) : (Date.now() - i.startAt + i.startOffset) % e._getOneEffectDuration(t) : void (n && e._handleAudioMixingInvalidStateError("_getOneEffectCurrentPosition", t));
        }, e._setOneEffectPosition = function (t, n, i) {
          var o = e.audioMixing.sounds[t.soundId];

          if (o.state === e.audioMixing.states.BUSY) {
            if (!e._stopAudioMixingBufferSource(t)) return void e._handleAudioMixingNoSourceError("_setOneEffectPosition", t, i);

            var a = {
              soundId: t.soundId,
              filePath: o.options.filePath,
              loop: o.options.loop,
              cycle: o.options.cycle,
              playTime: n
            },
                s = e._startAudioMixingBufferSource(a);

            if (!s) {
              var c = "CREATE_BUFFERSOURCE_FAILED";
              return i && i(c), void r.default.error("[".concat(e.streamId, "] "), c);
            }

            o.source = s, o.startAt = Date.now(), o.startOffset = n, o.resumeAt = null, o.resumeOffset = null, o.pauseOffset = null, o.pauseAt = null;
          } else {
            if (o.state !== e.audioMixing.states.PAUSED) return void e._handleAudioMixingInvalidStateError("_setOneEffectPosition", t, i);
            o.pauseOffset = n;
          }

          i && i(null);
        }, e.startAudioMixing = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: function callback(t) {
              if (t) return n && n(t);
              e.dispatchEvent({
                type: "audioMixingPlayed"
              }), n && n(null);
            },
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.startAudioMixing",
            options: t
          });
          X(t, "options");
          var r = t.filePath,
              s = t.cacheResource,
              c = t.cycle,
              d = t.loop,
              u = t.playTime,
              l = t.replace;
          Q(r, "filePath", 1, Object(o.getParameter)("FILEPATH_LENMAX"), !1), $(u, "playTime", 0, 1e8), !se(c) && $(c, "cycle"), !se(d) && Z(d, "loop"), !se(l) && Z(l, "replace"), !se(s) && Z(s, "cacheResource");
          var p = S()({
            soundId: -1
          }, t);

          e._playOneEffect(p, i);
        }, e.stopAudioMixing = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.stopAudioMixing"
          });

          e._stopOneEffect({
            soundId: -1
          }, n);
        }, e.pauseAudioMixing = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.pauseAudioMixing"
          });
          return e._pauseOneEffect({
            soundId: -1
          }, n);
        }, e.resumeAudioMixing = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: function callback(n, i) {
              if (n) return t && t(n);
              e.dispatchEvent({
                type: "audioMixingPlayed"
              }), t && t(null);
            },
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.resumeAudioMixing"
          });

          e._resumeOneEffect({
            soundId: -1
          }, n);
        }, e.adjustAudioMixingVolume = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.adjustAudioMixingVolume",
            options: arguments,
            tag: "tracer"
          });
          $(t, "volume", 0, 100), e.audioMixing.sounds[-1].volume = t, e._flushAudioMixingMuteStatus(), n();
        }, e.getAudioMixingDuration = function () {
          var t = a.b.reportApiInvoke(e.sid, {
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.getAudioMixingDuration"
          }),
              n = e._getOneEffectDuration({
            soundId: -1
          });

          return t(null, n), n;
        }, e.getAudioMixingCurrentPosition = function () {
          var t = a.b.reportApiInvoke(e.sid, {
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.getAudioMixingCurrentPosition"
          }),
              n = e._getOneEffectCurrentPosition({
            soundId: -1
          }, !0);

          return t(null, n), n;
        }, e.setAudioMixingPosition = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            options: arguments,
            tag: "tracer",
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.setAudioMixingPosition"
          });
          $(t, "position", 0, 1e8), e._setOneEffectPosition({
            soundId: -1
          }, t, i);
        }, e.playEffect = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: function callback(t) {
              if (t) return n && n(t);
              e.dispatchEvent({
                type: "effectPlayed"
              }), n && n(null);
            },
            name: "Stream.playEffect",
            options: t
          });
          X(t, "options");
          var r = t.soundId,
              s = t.filePath,
              c = t.cycle;
          $(r, "soundId", 1, 1e4), Q(s, "filePath", 0, Object(o.getParameter)("FILEPATH_LENMAX"), !1), !se(c) && $(c, "cycle"), e._playOneEffect(t, i);
        }, e.stopEffect = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            getStates: e._getOneEffectStates({
              soundId: t
            }),
            name: "Stream.stopEffect"
          });
          $(t, "soundId", 1, 1e4), e._stopOneEffect({
            soundId: t
          }, i);
        }, e.stopAllEffects = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            name: "Stream.stopAllEffect"
          }),
              i = !1,
              o = 0,
              r = 0,
              s = function s(e) {
            i || (e ? (n(e), i = !0) : o += 1, o === r && (n(null), i = !0));
          };

          for (var c in e.audioMixing.sounds) {
            var d = e.audioMixing.sounds[c];
            -1 !== d.soundId && (d.state !== e.audioMixing.states.BUSY && d.state !== e.audioMixing.states.PAUSED || (r++, e._stopOneEffect({
              soundId: c
            }, s)));
          }

          r || n(null);
        }, e.preloadEffect = function (t, n, i) {
          var r = a.b.reportApiInvoke(e.sid, {
            callback: i,
            options: arguments,
            tag: "tracer",
            name: "Stream.preloadEffect"
          });
          $(t, "soundId", 1, 1e4), Q(n, "filePath", 1, Object(o.getParameter)("FILEPATH_LENMAX"), !1), e._initSoundIfNotExists(t, n), e.audioMixing.buffer[n] ? r(null) : e.loadAudioBuffer(n, n, r);
        }, e.unloadEffect = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            options: arguments,
            tag: "tracer",
            name: "Stream.unloadEffect"
          });
          $(t, "soundId", 1, 1e4);
          var o = e.audioMixing.sounds[t];

          if (!o) {
            var s = "SOUND_NOT_EXISTS";
            return r.default.error(s, t), void i(s);
          }

          var c = o.options ? o.options.filePath : o.filePath;
          if (c) delete e.audioMixing.buffer[c], delete e.audioMixing.sounds[t], i(null);else {
            var d = "SOUND_BUFFER_NOT_FOUND";
            r.default.error(d, t), i(d);
          }
        }, e.pauseEffect = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            options: arguments,
            tag: "tracer",
            name: "Stream.pauseEffect"
          });
          return e._pauseOneEffect({
            soundId: t
          }, i);
        }, e.pauseAllEffects = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            name: "Stream.pauseAllEffects"
          }),
              i = !1,
              o = 0,
              r = 0,
              s = function s(e) {
            i || (e ? (n(e), i = !0) : o += 1, o === r && (n(null), i = !0));
          };

          for (var c in e.audioMixing.sounds) {
            "-1" !== c && e.audioMixing.sounds[c].state === e.audioMixing.states.BUSY && (r++, e._pauseOneEffect({
              soundId: c
            }, s));
          }

          r || n(null);
        }, e.resumeEffect = function (t, n) {
          $(t, "soundId", 1, 1e4);
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            options: arguments,
            tag: "tracer",
            name: "Stream.resumeEffect"
          });
          return e._resumeOneEffect({
            soundId: t
          }, i);
        }, e.resumeAllEffects = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            name: "Stream.resumeAllEffects"
          }),
              i = !1,
              o = 0,
              r = 0,
              s = function s(e) {
            i || (e ? (n(e), i = !0) : o += 1, o === r && (n(null), i = !0));
          };

          for (var c in e.audioMixing.sounds) {
            "-1" !== c && e.audioMixing.sounds[c].state === e.audioMixing.states.PAUSED && (r++, e._resumeOneEffect({
              soundId: c
            }, s));
          }

          r || n(null);
        }, e.getEffectsVolume = function () {
          var t = [];

          for (var n in e.audioMixing.sounds) {
            var i = e.audioMixing.sounds[n];
            i && "-1" !== n && t.push({
              soundId: parseInt(n),
              volume: i.volume
            });
          }

          return t;
        }, e.setEffectsVolume = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setEffectsVolume",
            options: arguments,
            tag: "tracer",
            callback: n
          });

          for (var o in $(t, "volume", 0, 100), e.audioMixing.defaultVolume = t, e.audioMixing.sounds) {
            var r = e.audioMixing.sounds[o];
            "-1" !== o && (r.volume = t);
          }

          e._flushAudioMixingMuteStatus(), i(null);
        }, e.setVolumeOfEffect = function (t, n, i) {
          var o = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVolumeOfEffect",
            options: arguments,
            tag: "tracer",
            callback: i
          });
          $(t, "soundId", 0, 1e4), $(n, "volume", 0, 100), e._initSoundIfNotExists(t), e.audioMixing.sounds[t].volume = n, e._flushAudioMixingMuteStatus(), o(null);
        };
      }(t), function (e, t) {
        e.videoConstraint = {}, t.cameraId && (e.videoConstraint.deviceId = {
          exact: t.cameraId
        }), e.videoSize && (e.videoConstraint.width = e.videoSize[0], e.videoConstraint.height = e.videoSize[1]), Object(f.isLegacyChrome)() || (e.videoConstraint.frameRate = {
          ideal: 30,
          max: 30
        }), e.audioConstraint = {}, t.microphoneId && (e.audioConstraint.deviceId = {
          exact: t.microphoneId
        }), Object(f.isLegacyChrome)() || e.audioProcessing && (void 0 !== e.audioProcessing.AGC && (Object(f.isFireFox)() ? e.audioConstraint.autoGainControl = e.audioProcessing.AGC : Object(f.isChrome)() && (e.audioConstraint.googAutoGainControl = e.audioProcessing.AGC, e.audioConstraint.googAutoGainControl2 = e.audioProcessing.AGC)), void 0 !== e.audioProcessing.AEC && (e.audioConstraint.echoCancellation = e.audioProcessing.AEC), void 0 !== e.audioProcessing.ANS && (Object(f.isFireFox)() ? e.audioConstraint.noiseSuppression = e.audioProcessing.ANS : Object(f.isChrome)() && (e.audioConstraint.googNoiseSuppression = e.audioProcessing.ANS))), e.screenConstraint = {}, t.sourceId && (e.screenConstraint.sourceId = t.sourceId), t.extensionId && Object(f.isChrome)() ? (e.screenConstraint.extensionId = t.extensionId, e.screenConstraint.mandatory = {
          chromeMediaSource: "desktop",
          maxWidth: e.screenAttributes.width,
          maxHeight: e.screenAttributes.height,
          maxFrameRate: e.screenAttributes.maxFr,
          minFrameRate: e.screenAttributes.minFr
        }) : (e.screenConstraint.mediaSource = "screen", e.screenConstraint.width = e.screenAttributes.width, e.screenConstraint.height = e.screenAttributes.height, e.screenConstraint.frameRate = {
          ideal: e.screenAttributes.maxFr,
          max: e.screenAttributes.maxFr
        }), t.mediaSource && (e.screenConstraint.mediaSource = t.mediaSource), e.setVideoResolution = function (n) {
          var i = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVideoResolution",
            options: arguments,
            tag: "tracer"
          });

          if (!(n instanceof Array)) {
            var o = de(n += "");
            return o && o.video ? (e.videoConstraint = S()(e.videoConstraint, {
              width: {
                ideal: o.video.width
              },
              height: {
                ideal: o.video.height
              }
            }), t.attributes.resolution = o.attributes.resolution, (s = e.stream && e.stream.getVideoTracks && e.stream.getVideoTracks()[0]) && s.applyConstraints ? (r.default.debug("setVideoResolution applyConstraints", e.videoConstraint), s.applyConstraints(e.videoConstraint).then(i).catch(i)) : i(), !0) : (i("NO_PROFILE_".concat(n)), !1);
          }

          var s,
              c = n[0],
              d = n[1];
          e.videoConstraint = S()(e.videoConstraint, {
            width: {
              ideal: c
            },
            height: {
              ideal: d
            }
          }), t.attributes.resolution = "".concat(c, "x").concat(d), (s = e.stream && e.stream.getVideoTracks && e.stream.getVideoTracks()[0]) && s.applyConstraints ? (r.default.debug("setVideoResolution applyConstraints", e.videoConstraint), s.applyConstraints(e.videoConstraint).then(i).catch(i)) : i();
        }, e.setVideoFrameRate = function (n) {
          var i = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVideoFrameRate",
            options: arguments,
            tag: "tracer"
          });
          if (Object(f.isFireFox)()) return i("FIREFOX_NOT_SUPPORTED"), !1;

          if ("object" === q()(n) && n instanceof Array && n.length > 1) {
            e.videoConstraint = S()(e.videoConstraint, {
              frameRate: {
                ideal: n[0],
                max: n[1]
              }
            }), t.attributes.minFrameRate = n[0], t.attributes.maxFrameRate = n[1];
            var o = e.stream && e.stream.getVideoTracks && e.stream.getVideoTracks()[0];
            return o && o.applyConstraints ? (r.default.debug("setVideoFrameRate applyConstraints", e.videoConstraint), o.applyConstraints(e.videoConstraint).then(i).catch(i)) : i(), !0;
          }

          return i("INVALID_PARAM_".concat(JSON.stringify(n))), !1;
        }, e.setVideoBitRate = function (n) {
          var i = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVideoBitRate",
            options: arguments,
            tag: "tracer"
          });
          return "object" === q()(n) && n instanceof Array && n.length > 1 ? (t.attributes.minVideoBW = n[0], t.attributes.maxVideoBW = n[1], e.connectionSpec && (e.connectionSpec.minVideoBW = n[0], e.connectionSpec.maxVideoBW = n[1]), e.pc && e.pc.renegotiate && e.pc.renegotiate(), i(), !0) : (i("INVALID_PARAM_".concat(JSON.stringify(n))), !1);
        }, e.setScreenBitRate = function (n) {
          var i = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setScreenBitRate",
            options: arguments,
            tag: "tracer"
          });
          return "object" === q()(n) && n instanceof Array && n.length > 1 ? (t.screenAttributes.minVideoBW = n[0], t.screenAttributes.maxVideoBW = n[1], i(), !0) : (i("INVALID_PARAM_".concat(JSON.stringify(n))), !1);
        }, e.setScreenProfile = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setScreenProfile",
            options: arguments,
            tag: "tracer"
          });
          K(t, "profile", ["480p_1", "480p_2", "720p_1", "720p_2", "1080p_1", "1080p_2"]);
          var i = de(t);
          return i && i.screen ? (e.screenConstraint.mandatory ? (e.screenConstraint.mandatory.maxWidth = i.screen.width, e.screenConstraint.mandatory.maxHeight = i.screen.height, i.screen.frameRate && i.screen.frameRate.min && i.screen.frameRate.max && (e.screenConstraint.mandatory.minFrameRate = i.screen.frameRate.min, e.screenConstraint.mandatory.maxFrameRate = i.screen.frameRate.max)) : e.screenConstraint = S()(e.screenConstraint, i.screen), e.screenAttributes.width = i.screen.width, e.screenAttributes.height = i.screen.height, e.screenAttributes.minFr = i.screen.frameRate.min, e.screenAttributes.maxFr = i.screen.frameRate.max, n(), !0) : (n("NO_SCREEN_PROFILE_".concat(JSON.stringify(t))), !1);
        }, e.setVideoProfileCustom = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVideoProfileCustom",
            options: arguments,
            tag: "tracer"
          });
          e.setVideoResolution(t[0]), e.setVideoFrameRate([t[1], t[1]]), e.setVideoBitRate([t[2], t[2]]), n();
        }, e.setVideoProfileCustomPlus = function (n) {
          var i = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVideoProfileCustom",
            options: arguments,
            tag: "tracer"
          });
          e.videoConstraint.width = n.width, e.videoConstraint.height = n.height, t.attributes.resolution = "".concat(n.width, "x").concat(n.height), e.setVideoFrameRate([n.framerate, n.framerate]), e.setVideoBitRate([n.bitrate, n.bitrate]), i();
        }, e.setVideoProfile = function (n) {
          var i = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVideoProfile",
            options: arguments,
            tag: "tracer"
          }),
              o = de(n);

          if (!o) {
            var s = "Invalid Profile ".concat(n);
            throw new Error(s);
          }

          if (e.profile = n, o && o.video) {
            e.profile = o.profileName, e.videoConstraint = S()(e.videoConstraint, o.video), e.connectionSpec && o.attributes.maxVideoBW && (e.connectionSpec.minVideoBW = o.attributes.minVideoBW, e.connectionSpec.maxVideoBW = o.attributes.maxVideoBW), Object(f.isEdge)() && (e.videoConstraint.frameRate.max = 60), Object(f.isFireFox)() && (e.videoConstraint.frameRate = {
              ideal: 30,
              max: 30
            }), t.attributes = S()(t.attributes, o.attributes), e.pc && e.pc.renegotiate && e.pc.renegotiate();
            var c = e.stream && e.stream.getVideoTracks && e.stream.getVideoTracks()[0];
            return c && c.applyConstraints ? (r.default.debug("setVideoProfile applyConstraints", e.videoConstraint), c.applyConstraints(e.videoConstraint).then(function (t) {
              i(t), Object(G.h)(e.stream, function (t, n) {
                e.videoWidth = t, e.videoHeight = n;
              }, function (t) {
                r.default.warning("[".concat(e.streamId, "] vsResHack failed: "), t);
              });
            }).catch(i)) : i(), !0;
          }

          return i("INVALID_VIDEO_PROFILE_".concat(n)), !1;
        }, e.setAudioProfile = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setAudioProfile",
            options: arguments,
            tag: "tracer"
          });
          K(t, "profile", ["speech_low_quality", "speech_standard", "music_standard", "standard_stereo", "high_quality", "high_quality_stereo"]), e.audioProfile = t;
          var i = le(t);
          return e.highQuality = i.highQuality, e.stereo = i.stereo, e.speech = i.speech, e.lowQuality = i.lowQuality, e.stereo && Object(f.isChrome)() && (e.audioConstraint.googAutoGainControl = !1, e.audioConstraint.googAutoGainControl2 = !1, e.audioConstraint.echoCancellation = !1, e.audioConstraint.googNoiseSuppression = !1), n(), !0;
        }, e.setVideoEncoderConfiguration = function (t) {
          X(t, "config");
          var n = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVideoEncoderConfiguration",
            options: t,
            tag: "tracer"
          });
          t.resolution && ($(t.resolution.width, "config.resolution.width"), $(t.resolution.height, "config.resolution.height"), e.setVideoResolution([t.resolution.width, t.resolution.height])), t.frameRate && ($(t.frameRate.min, "config.frameRate.min"), $(t.frameRate.max, "config.frameRate.max"), e.setVideoFrameRate([t.frameRate.min, t.frameRate.max])), t.bitrate && ($(t.bitrate.min, "config.bitrate.min", 1, 1e7), $(t.bitrate.max, "config.bitrate.max", 1, 1e7), e.setVideoBitRate([t.bitrate.min, t.bitrate.max])), n();
        }, e.getSupportedProfile = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            name: "Stream.getSupportedProfile",
            options: arguments,
            tag: "tracer",
            callback: t
          });

          if (!e.local) {
            var i = "ONLY_LOCAL_STREAM_SUPPORTED";
            return r.default.error(i), n(i);
          }

          if (!e.stream) return i = "STREAM_NOT_INIT", r.default.error(i), n(i);
          if (!e.stream.getVideoTracks) return i = "TRACK_NOT_SUPPORT", r.default.error(i), n(i);
          var o = e.stream.getVideoTracks()[0];
          if (!o) return i = "NO_VIDEO_TRACK_FOUND", r.default.error(i), n(i);
          if (!o.getCapabilities) return i = "GETCAPABILITY_NOT_SUPPORT", r.default.error(i), n(i);
          var s = o.getCapabilities();
          return n(null, ue(s));
        };
      }(t, e), t.on("collectStats", function (e) {
        e.promises.push(t._getPCStats(e.interval)), e.promises.push(new Promise(function (e) {
          var n = {};
          t.pc && t.pc.isSubscriber ? null !== window.navigator.userAgent.match("Firefox") && (J(n, "videoReceiveResolutionHeight", t.videoHeight), J(n, "videoReceiveResolutionWidth", t.videoWidth)) : t.pc && !t.pc.isSubscriber && ((Object(f.isSafari)() || Object(f.isFireFox)()) && (J(n, "videoSendResolutionHeight", t.videoHeight), J(n, "videoSendResolutionWidth", t.videoWidth)), (Object(f.isSafari)() || Object(f.isFireFox)()) && t.uplinkStats && J(n, "videoSendPacketsLost", t.uplinkStats.uplink_cumulative_lost)), e(n);
        })), e.promises.push(new Promise(function (e) {
          var n = {};
          return t.traffic_stats && t.pc && t.pc.isSubscriber ? (J(n, "accessDelay", t.traffic_stats.access_delay), J(n, "endToEndDelay", t.traffic_stats.e2e_delay), J(n, "videoReceiveDelay", t.traffic_stats.video_delay), J(n, "audioReceiveDelay", t.traffic_stats.audio_delay)) : t.traffic_stats && t.pc && !t.pc.isSubscriber && J(n, "accessDelay", t.traffic_stats.access_delay), e(n);
        }));
      }), t.getId = function () {
        return t.streamId;
      }, t.getUserId = function () {
        return t.userId;
      }, t.setUserId = function (e) {
        var n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setUserId",
          options: arguments,
          tag: "tracer"
        });
        t.userId && r.default.warning("[".concat(t.streamId, "] Stream.userId ").concat(t.userId, " => ").concat(e)), t.userId = e, n();
      }, t.getAttributes = function () {
        return e.screen ? t.screenAttributes : e.attributes;
      }, t.hasAudio = function () {
        return t.audio;
      }, t.hasVideo = function () {
        return t.video;
      }, t.hasScreen = function () {
        return t.screen;
      }, t.isVideoOn = function () {
        return (t.hasVideo() || t.hasScreen()) && !t.userMuteVideo;
      }, t.isAudioOn = function () {
        return t.hasAudio() && !t.userMuteAudio;
      }, t.init = function (i, o) {
        var s = a.b.reportApiInvoke(t.sid, {
          callback: function callback(e, t) {
            if (e) return o && o(e);
            i && i(t);
          },
          name: "Stream.init",
          options: arguments,
          tag: "tracer"
        }),
            c = (new Date().getTime(), arguments[2]);
        if (void 0 === c && (c = 2), !0 === t.initialized) return s({
          type: "warning",
          msg: "STREAM_ALREADY_INITIALIZED"
        });
        if (!0 !== t.local) return s({
          type: "warning",
          msg: "STREAM_NOT_LOCAL"
        });
        t.videoSource ? t.videoName = "videoSource" : t.video && (t.videoName = Y.searchDeviceNameById(e.cameraId) || "default"), t.audioSource ? t.audioName = "audioSource" : t.audio && (t.audioName = Y.searchDeviceNameById(e.microphoneId) || "default"), t.screen && (t.screenName = e.extensionId || "default");

        try {
          if (e.audio || e.video || e.screen || e.videoSource || e.audioSource) {
            r.default.debug("[".concat(t.streamId, "] Requested access to local media"));
            var d = {
              streamId: t.streamId
            };
            e.videoSource ? d.videoSource = e.videoSource : e.screen ? d.screen = t.screenConstraint : e.video && (d.video = t.videoConstraint), e.audioSource ? d.audioSource = e.audioSource : e.audio && (d.audio = t.audioConstraint), H(d, function (i) {
              d.screen && r.default.debug("[".concat(t.streamId, "] User has granted access to screen sharing")), (d.video || d.audio) && r.default.debug("[".concat(t.streamId, "] User has granted access to local media")), t.dispatchEvent({
                type: "accessAllowed"
              }), t.stream = i, t.initialized = !0, t.reloadDeviceName(), t.hasVideo() && Object(G.h)(i, function (e, n) {
                t.videoWidth = e, t.videoHeight = n;
              }, function (e) {
                r.default.warning("[".concat(t.streamId, "] vsResHack failed: "), e);
              }), e.screen && t.stream && t.stream.getVideoTracks()[0] && (t.stream.getVideoTracks()[0].onended = function () {
                t.dispatchEvent({
                  type: "stopScreenSharing"
                });
              }), t.stream && t.stream.getTracks && t.stream.getTracks().forEach(function (e) {
                e && !e.onended && (e.onended = n);
              }), s();
            }, function (e) {
              var n = {
                type: "error",
                info: null
              };

              switch (e && (n.msg = e.name || e.code || e, e.message && (n.info = e.message), e.code && (n.info ? n.info += ". " + e.code : n.info = " " + e.code), e.constraint && (n.info ? n.info += ". Constraint: " + e.constraint : n.info = "constraint: " + e.constraint)), n.msg) {
                case "Starting video failed":
                case "TrackStartError":
                  if (t.videoConstraint && (delete t.videoConstraint.width, delete t.videoConstraint.height), c > 0) return void setTimeout(function () {
                    t.init(function (e) {
                      return s(e);
                    }, s, c - 1);
                  }, 1);
                  n.msg = "MEDIA_OPTION_INVALID";
                  break;

                case "DevicesNotFoundError":
                  n.msg = "DEVICES_NOT_FOUND";
                  break;

                case "NotSupportedError":
                  n.msg = "NOT_SUPPORTED";
                  break;

                case "PermissionDeniedError":
                case "InvalidStateError":
                  n.msg = "PERMISSION_DENIED", t.dispatchEvent({
                    type: "accessDenied"
                  });
                  break;

                case "PERMISSION_DENIED":
                case "NotAllowedError":
                  t.dispatchEvent({
                    type: "accessDenied"
                  });
                  break;

                case "ConstraintNotSatisfiedError":
                  n.msg = "CONSTRAINT_NOT_SATISFIED";
                  break;

                default:
                  n.msg || (n.msg = "UNDEFINED");
              }

              var i = "Media access ".concat(n.msg).concat(n.info ? ": " + n.info : "");
              r.default.error("[".concat(t.streamId, "] "), i), s(n);
            });
          } else s({
            type: "warning",
            msg: "STREAM_HAS_NO_MEDIA_ATTRIBUTES"
          });
        } catch (e) {
          r.default.error("[".concat(t.streamId, "] Stream init: "), e), s({
            type: "error",
            msg: e.message || e
          });
        }
      }, t.reloadDeviceName = function () {
        if (t.stream) {
          if (t.stream.getVideoTracks) {
            var e = t.stream.getVideoTracks()[0];
            e && e.label && (t.videoName = e.label);
          }

          if (t.stream.getAudioTracks) {
            var n = t.stream.getAudioTracks()[0];
            n && n.label && (t.audioName = n.label);
          }
        }
      }, t.close = function () {
        var e = a.b.reportApiInvoke(null, {
          name: "Stream.close",
          options: arguments,
          tag: "tracer"
        });

        if (r.default.debug("[".concat(t.streamId, "] Close stream with id"), t.streamId), void 0 !== t.stream) {
          var n = t.stream.getTracks();

          for (var i in n) {
            n.hasOwnProperty(i) && n[i].stop();
          }

          t.stream = void 0;
        }

        Object(f.isSafari)() && t.pc && t.pc.peerConnection && t.pc.peerConnection.removeTrack && t.pc.peerConnection.getSenders && t.pc.peerConnection.getSenders().forEach(function (e) {
          e && (r.default.debug("[".concat(t.streamId, "] Remove Track"), e), t.pc.peerConnection.removeTrack(e));
        });
        t.initialized = !1, t._onAudioMute = void 0, t._onAudioUnmute = void 0, t._onVideoMute = void 0, t._onVideoUnmute = void 0, t.lowStream && t.lowStream.close(), e();
      }, t.enableAudio = function () {
        var e,
            n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.enableAudio",
          options: arguments,
          tag: "tracer"
        });
        return r.default.deprecate("[".concat(t.streamId, "] Stream.enableAudio is deprecated and will be removed in the future. Use Stream.unmuteAudio instead")), t.userMuteAudio || r.default.warning("[".concat(t.streamId, "] User already enableAudio")), t.userMuteAudio = !1, n(null, e = !t.peerMuteAudio && t._unmuteAudio()), e;
      }, t.disableAudio = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.disableAudio",
          options: arguments,
          tag: "tracer"
        });
        r.default.deprecate("[".concat(t.streamId, "] Stream.disableAudio is deprecated and will be removed in the future. Use Stream.muteAudio instead")), t.userMuteAudio && r.default.warning("[".concat(t.streamId, "] User already disableAudio")), t.userMuteAudio = !0;

        var n = t._muteAudio();

        return e(null, n), n;
      }, t.enableVideo = function () {
        var e,
            n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.enableVideo",
          options: arguments,
          tag: "tracer"
        });
        return r.default.deprecate("[".concat(t.streamId, "] Stream.enableVideo is deprecated and will be removed in the future. Use Stream.unmuteVideo instead")), t.userMuteVideo || r.default.warning("[".concat(t.streamId, "] User already enableVideo")), t.userMuteVideo = !1, t.lowStream && (t.lowStream.userMuteVideo = !1), n(null, e = !t.peerMuteVideo && t._unmuteVideo()), e;
      }, t.disableVideo = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.disableVideo",
          options: arguments,
          tag: "tracer"
        });
        r.default.deprecate("[".concat(t.streamId, "] Stream.disableVideo is deprecated and will be removed in the future. Use Stream.muteVideo instead")), t.userMuteVideo && r.default.warning("[".concat(t.streamId, "] User already disableVideo")), t.userMuteVideo = !0, t.lowStream && (t.lowStream.userMuteVideo = !0);

        var n = t._muteVideo();

        return e(null, n), n;
      }, t.unmuteAudio = function () {
        var e,
            n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.unmuteAudio",
          options: arguments,
          tag: "tracer"
        });
        return t.userMuteAudio || r.default.warning("[".concat(t.streamId, "] User already unmuteAudio")), t.userMuteAudio = !1, n(null, e = !t.peerMuteAudio && t._unmuteAudio()), e;
      }, t.muteAudio = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.muteAudio",
          options: arguments,
          tag: "tracer"
        });
        t.userMuteAudio && r.default.warning("[".concat(t.streamId, "] User already muteAudio")), t.userMuteAudio = !0;

        var n = t._muteAudio();

        return e(null, n), n;
      }, t.unmuteVideo = function () {
        var e,
            n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.unmuteVideo",
          options: arguments,
          tag: "tracer"
        });
        return t.userMuteVideo || r.default.warning("[".concat(t.streamId, "] User already unmuteVideo")), t.userMuteVideo = !1, t.lowStream && (t.lowStream.userMuteVideo = !1), n(null, e = !t.peerMuteVideo && t._unmuteVideo()), e;
      }, t.muteVideo = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.muteVideo",
          options: arguments,
          tag: "tracer"
        });
        t.userMuteVideo && r.default.warning("[".concat(t.streamId, "] User already muteVideo")), t.userMuteVideo = !0, t.lowStream && (t.lowStream.userMuteVideo = !0);

        var n = t._muteVideo();

        return e(null, n), n;
      }, t._unmuteAudio = function () {
        return r.default.debug("[".concat(t.streamId, "] Unmuted audio stream with id "), t.streamId), t._flushAudioMixingMuteStatus(!1), !(!t.hasAudio() || !t.initialized || void 0 === t.stream || !0 === t.stream.getAudioTracks()[0].enabled) && (t._onAudioUnmute && t._onAudioUnmute(), t.pc && (t.pc.isAudioMute = !1), t.stream.getAudioTracks()[0].enabled = !0, !0);
      }, t._isAudioMuted = function () {
        if (t.stream && t.hasAudio()) {
          var e = t.stream.getAudioTracks();
          return e.length > 0 && !e[0].enabled;
        }

        return !1;
      }, t._muteAudio = function () {
        return r.default.debug("[".concat(t.streamId, "] Muted audio stream with id "), t.streamId), t._flushAudioMixingMuteStatus(!0), !!(t.hasAudio() && t.initialized && void 0 !== t.stream && t.stream.getAudioTracks()[0].enabled) && (t._onAudioMute && t._onAudioMute(), t.pc && (t.pc.isAudioMute = !0), t.stream.getAudioTracks()[0].enabled = !1, t.sid && a.b.audioSendingStopped(t.sid, {
          succ: !0,
          reason: "muteAudio"
        }), !0);
      }, t._unmuteVideo = function () {
        return r.default.debug("[".concat(t.streamId, "] Unmuted video stream with id"), t.streamId), !(!t.initialized || void 0 === t.stream || !t.stream.getVideoTracks().length || !0 === t.stream.getVideoTracks()[0].enabled) && (t._onVideoUnmute && t._onVideoUnmute(), t.pc && (t.pc.isVideoMute = !1), t.stream.getVideoTracks()[0].enabled = !0, t.lowStream && t.lowStream._unmuteVideo(), !0);
      }, t._muteVideo = function () {
        return r.default.debug("[".concat(t.streamId, "] Muted video stream with id"), t.streamId), !!(t.initialized && void 0 !== t.stream && t.stream.getVideoTracks().length && t.stream.getVideoTracks()[0].enabled) && (t._onVideoMute && t._onVideoMute(), t.pc && (t.pc.isVideoMute = !0), t.stream.getVideoTracks()[0].enabled = !1, t.lowStream && t.lowStream._muteVideo(), t.sid && a.b.videoSendingStopped(t.sid, {
          succ: !0,
          reason: "muteVideo"
        }), !0);
      }, t.addTrack = function (i) {
        var o = a.b.reportApiInvoke(t.sid, {
          name: "Stream.addTrack",
          options: arguments,
          tag: "tracer"
        });

        if (t.pc && t.pc.addTrack(i, t.stream), "audio" == i.kind) {
          t._cleanupAudioMixing();

          var r = new MediaStream();
          t.userMuteAudio && (i.enabled = !1), r.addTrack(i);
          var s = t.stream.getVideoTracks()[0];
          s && (r.addTrack(s), t.audio = !0, e.audio = !0), t.stream = r, t.audioLevelHelper = null, t.player && t.player.video && (t.player.video.srcObject = t.stream);
        } else t.userMuteVideo && (i.enabled = !1), t.stream.addTrack(i), t.video = !0, e.video = !0;

        i.onended || (i.onended = n), o();
      }, t.removeTrack = function (n) {
        var i = a.b.reportApiInvoke(t.sid, {
          name: "Stream.removeTrack",
          options: arguments,
          tag: "tracer"
        });
        t.pc && t.pc.removeTrack(n, t.stream), t.stream.removeTrack(n), t._cleanupAudioMixing(), "audio" === n.kind ? (t.audio = !1, e.audio = !1) : (t.video = !1, e.video = !1), t.audioLevelHelper = null, "live" == n.readyState && (n.stop(), r.default.debug("[".concat(t.streamId, "] Track ").concat(n.kind, " Stopped"))), i();
      }, t.setAudioOutput = function (e, n, i) {
        var o = a.b.reportApiInvoke(t.sid, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Stream.setAudioOutput",
          options: arguments,
          tag: "tracer"
        });
        return ee(e, 1, 255) ? (t.audioOutput = e, t.player ? void t.player.setAudioOutput(e, function () {
          return o();
        }, o) : o()) : (r.default.error("[".concat(t.streamId, "] setAudioOutput Invalid Parameter"), e), o(A.INVALID_PARAMETER));
      }, t.play = function (e, n, i) {
        "function" == typeof n && (i = n, n = null), r.default.debug("[".concat(t.streamId, "] play()."), e, n);
        var o = a.b.reportApiInvoke(t.sid, {
          name: "Stream.play",
          options: arguments,
          tag: "tracer",
          callback: i
        });
        if (Q(e, "elementID"), se(n) || (se(n.fit) || K(n.fit, "fit", ["cover", "contain"]), se(n.muted) || Z(n.muted, "muted")), t.player) r.default.warning("[".concat(t.streamId, "] Stream.play(): Stream is already playing. Fallback to resume stream")), t.resume().then(function () {
          o(null);
        }).catch(o);else {
          t.elementID = e, t.playOptions = n, !t.local || t.video || t.screen ? t.player = new C({
            id: t.getId(),
            stream: t,
            elementID: e,
            options: n
          }) : t.hasAudio() && (t.player = new C({
            id: t.getId(),
            stream: t,
            elementID: e,
            options: n
          }));
          var s = {
            audio: null,
            video: null
          };
          t.on("player-status-change", function e(n) {
            if (s[n.mediaType] = n, s.audio && s.video) if (t.removeEventListener("player-status-change", e), s.video.isErrorState || s.audio.isErrorState) {
              var i = s.video.isErrorState ? s.video : s.audio;
              o({
                isErrorState: !0,
                status: i.status,
                reason: i.reason,
                video: s.video,
                audio: s.audio
              });
            } else "aborted" === s.video.status && "aborted" === s.audio.status ? o({
              status: "aborted",
              reason: "stop",
              video: s.video,
              audio: s.audio
            }) : o(null);
          }), t.audioOutput && t.player.setAudioOutput(t.audioOutput), void 0 !== t.audioLevel && t.player.setAudioVolume(t.audioLevel), t._flushAudioMixingMuteStatus(!1);
        }
      }, t.stop = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.stop",
          options: arguments,
          tag: "tracer"
        });
        r.default.debug("[".concat(t.streamId, "] Stop stream player with id "), t.streamId), t.player ? (t.player.destroy(), delete t.player) : r.default.error("[".concat(t.streamId, "] Stream.stop(): Stream is not playing")), t._flushAudioMixingMuteStatus(!0), e();
      }, t.isPlaying = function () {
        return !!t.player;
      }, t.isPaused = function () {
        return !!t.player && (!!(t.player.video && t.player.video.paused && t.player.mediaElemExists(t.player.video)) || !!(t.player.audio && t.player.audio.paused && t.player.mediaElemExists(t.player.audio)));
      }, t.resume = function () {
        var e, n;
        return t.player ? (t.player.video && t.player.video.play && (e = t.player.video.play()), e = e || Promise.resolve(), t.player.audio && t.player.audio.play && (n = t.player.audio.play()), n = n || Promise.resolve(), Promise.all([e, n])) : Promise.reject("NO_PLAYER_FOUND");
      }, t.getVideoTrack = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.getVideoTrack",
          options: arguments,
          tag: "tracer"
        });

        if (t.stream && t.stream.getVideoTracks) {
          var n = t.stream.getVideoTracks()[0];
          if (n) return r.default.info("[".concat(t.streamId, "] getVideoTrack"), n), e(), n;
        }

        r.default.info("[".concat(t.streamId, "] getVideoTrack None")), e(null, "getVideoTrack None");
      }, t.getAudioTrack = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.getAudioTrack",
          options: arguments,
          tag: "tracer"
        });

        if (t.stream && t.stream.getAudioTracks) {
          var n = t.stream.getAudioTracks()[0];
          if (n) return r.default.info("[".concat(t.streamId, "] getAudioTracks"), n), e(), n;
        }

        r.default.info("[".concat(t.streamId, "] getAudioTracks None")), e(null, "getAudioTracks None");
      }, t._replaceMediaStreamTrack = function (e, n, i) {
        if (t.stream) {
          if ("video" == e.kind) {
            if (a = t.stream.getVideoTracks()[0]) return t.userMuteVideo && (e.enabled = !1), t.stream.removeTrack(a), t.stream.addTrack(e), r.default.debug("[".concat(t.streamId, "] _replaceMediaStreamTrack ").concat(e.kind, " SUCCESS")), "live" == a.readyState && (a.stop(), r.default.debug("[".concat(t.streamId, "] Track ").concat(a.kind, " Stopped"))), n && n();
            var o = "MEDIASTREAM_TRACK_NOT_FOUND";
            return r.default.error("[".concat(t.streamId, "] MEDIASTREAM_TRACK_NOT_FOUND ").concat(e.kind)), i(o);
          }

          if ("audio" == e.kind) {
            var a;

            if (a = t.stream.getAudioTracks()[0]) {
              t.userMuteAudio && (e.enabled = !1);
              var s = new MediaStream();
              s.addTrack(e);
              var c = t.stream && t.stream.getVideoTracks()[0];
              return c && s.addTrack(c), t.stream = s, t.audioLevelHelper = null, t.player && t.player.video && (t.player.video.srcObject = t.stream), r.default.debug("[".concat(t.streamId, "] _replaceMediaStreamTrack SUCCESS")), "live" == a.readyState && (a.stop(), r.default.debug("[".concat(t.streamId, "] Track ").concat(a.kind, " Stopped"))), n && n();
            }

            o = "MEDIASTREAM_TRACK_NOT_FOUND";
            return r.default.error("[".concat(t.streamId, "] MEDIASTREAM_TRACK_NOT_FOUND ").concat(e.kind)), i(o);
          }

          o = "INVALID_TRACK_TYPE";
          return r.default.error("[".concat(t.streamId, "] _replaceMediaStreamTrack ").concat(o, " ").concat(e.kind)), i && i(o);
        }

        o = "NO_STREAM_FOUND";
        return r.default.error("[".concat(t.streamId, "] _replaceMediaStreamTrack ").concat(o)), i && i(o);
      }, t.replaceTrack = function (e, i, o) {
        var s = a.b.reportApiInvoke(t.sid, {
          callback: function callback(e, t) {
            if (e) return o && o(e);
            i && i(t);
          },
          name: "Stream.replaceTrack",
          options: arguments,
          tag: "tracer"
        });
        return e && e.kind ? (t._cleanupAudioMixing(), e.onended || (e.onended = n), t.pc && t.pc.hasSender && t.pc.hasSender(e.kind) ? void t.pc.replaceTrack(e, function () {
          return r.default.debug("[".concat(t.streamId, "] PeerConnection.replaceTrack ").concat(e.kind, " SUCCESS")), t._replaceMediaStreamTrack(e, function (e) {
            return s(null, e);
          }, s);
        }, function (n) {
          return r.default.error("[".concat(t.streamId, "] PeerConnection.replaceTrack ").concat(e.kind, " Failed ").concat(n)), s(n);
        }) : t._replaceMediaStreamTrack(e, function (e) {
          return s(null, e);
        }, s)) : s("INVALID_TRACK");
      }, t.setAudioVolume = function (e) {
        var n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setAudioVolume",
          options: arguments,
          tag: "tracer"
        });
        $(e, "level", 0, 100), t.audioLevel = e, t.player && t.player.setAudioVolume(e), n();
      }, t.getStats = function (e, n, i) {
        var o = {
          type: "collectStats",
          promises: [],
          interval: i
        };
        t.dispatchEvent(o), Promise.all(o.promises).then(function (n) {
          for (var i = {}, o = n.length - 1; o >= 0; o--) {
            var r = n[o];
            S()(i, r);
          }

          e && setTimeout(e.bind(t, i), 0);
        }).catch(function (e) {
          n && setTimeout(n.bind(t, e), 0);
        });
      }, t._getPCStats = function (e) {
        return new Promise(function (n, i) {
          if (!t.pc || "established" !== t.pc.state || !t.pc.getStats) {
            return i("PEER_CONNECTION_NOT_ESTABLISHED");
          }

          t.pc.getStats(function (e) {
            if (!t.pc || "established" !== t.pc.state || !t.pc.getStats) {
              return i("PEER_CONNECTION_STATE_CHANGE");
            }

            var o = t.pc.isSubscriber ? function (e) {
              var t = {};
              return e.forEach(function (e) {
                e.id && (-1 === e.id.indexOf("recv") && -1 === e.id.indexOf("inbound_rtp") && -1 === e.id.indexOf("inbound-rtp") && -1 === e.id.indexOf("InboundRTP") || ("audio" === e.mediaType ? (J(t, "audioReceiveBytes", e.bytesReceived), J(t, "audioReceivePackets", e.packetsReceived), J(t, "audioReceivePacketsLost", e.packetsLost)) : (J(t, "videoReceiveBytes", e.bytesReceived), J(t, "videoReceivePacketsLost", e.packetsLost), J(t, "videoReceivePackets", e.packetsReceived), J(t, "videoReceiveFrameRate", e.googFrameRateReceived), J(t, "videoReceiveDecodeFrameRate", e.googFrameRateDecoded), J(t, "videoReceiveResolutionWidth", e.googFrameWidthReceived), J(t, "videoReceiveResolutionHeight", e.googFrameHeightReceived))));
              }), t;
            }(e) : function (e) {
              var t = {};
              return e.forEach(function (e) {
                e.id && (-1 === e.id.indexOf("send") && -1 === e.id.indexOf("outbound_rtp") && -1 === e.id.indexOf("OutboundRTP") || ("audio" === e.mediaType ? (J(t, "audioSendBytes", e.bytesSent), J(t, "audioSendPackets", e.packetsSent), J(t, "audioSendPacketsLost", e.packetsLost)) : (J(t, "videoSendBytes", e.bytesSent), J(t, "videoSendPackets", e.packetsSent), J(t, "videoSendPacketsLost", e.packetsLost), J(t, "videoSendFrameRate", e.googFrameRateSent), J(t, "videoSendResolutionWidth", e.googFrameWidthSent), J(t, "videoSendResolutionHeight", e.googFrameHeightSent))));
              }), t;
            }(e);
            return n(o);
          }, e);
        }).then(function (e) {
          return t.pc.isSubscriber ? (Object(f.isFireFox)() || Object(f.isSafari)()) && (e.videoReceiveResolutionHeight && "0" !== e.videoReceiveResolutionHeight || e.videoReceiveResolutionWidth && "0" !== e.videoReceiveResolutionWidth || (J(e, "videoReceiveResolutionHeight", t.videoHeight), J(e, "videoReceiveResolutionWidth", t.videoWidth))) : ((Object(f.isSafari)() || Object(f.isFireFox)()) && (e.videoSendResolutionHeight && "0" !== e.videoSendResolutionHeight || e.videoSendResolutionWidth && "0" !== e.videoSendResolutionWidth || (J(e, "videoSendResolutionHeight", t.videoHeight), J(e, "videoSendResolutionWidth", t.videoWidth))), (Object(f.isSafari)() || Object(f.isFireFox)()) && t.uplinkStats && J(e, "videoSendPacketsLost", t.uplinkStats.uplink_cumulative_lost)), Promise.resolve(e);
        });
      }, t.getAudioLevel = function () {
        if (t.audioLevelHelper) return t.audioLevelHelper.getAudioLevel();

        if (t.stream) {
          if (0 !== t.stream.getAudioTracks().length) return t.audioLevelHelper = new G.a(t.stream), t.audioLevelHelper.getAudioLevel();
          r.default.warning("[".concat(t.streamId, "] can't get audioLevel beacuse no audio trace in stream"));
        } else r.default.warning("[".concat(t.streamId, "] can't get audioLevel beacuse no stream exist"));
      }, t.setVideoProfile("480P"), t._switchVideoDevice = function (e, n, i) {
        if (e === t.cameraId) return n && n();
        var o = {
          video: S()({}, t.videoConstraint, {
            deviceId: {
              exact: e
            }
          }),
          audio: !1
        };
        r.default.debug("[".concat(t.streamId, "] ").concat(o)), H(o, function (o) {
          try {
            var r = function r() {
              t.isPlaying() && (t.stop(), t.elementID && t.play(t.elementID, t.playOptions)), t.cameraId = e, t.videoConstraint.deviceId = {
                exact: e
              }, t.userMuteVideo && (t.stream.getVideoTracks()[0].enabled = !1), n && n();
            };

            Object(f.isSafari)() ? t.replaceTrack(o.getVideoTracks()[0], r, i) : (t.removeTrack(t.stream.getVideoTracks()[0]), t.addTrack(o.getVideoTracks()[0]), r());
          } catch (e) {
            return i && i(e);
          }
        }, function (e) {
          return i && i(e);
        });
      }, t._switchAudioDevice = function (e, n, i) {
        if (e === t.microphoneId) return n && n();
        var o = {
          video: !1,
          audio: S()({}, t.audioConstraint, {
            deviceId: {
              exact: e
            }
          })
        };
        r.default.debug("[".concat(t.streamId, "] "), o), H(o, function (o) {
          var r = function r() {
            t._cleanupAudioMixing(), t.userMuteAudio && (t.stream.getAudioTracks()[0].enabled = !1), t.isPlaying() && (t.stop(), t.elementID && t.play(t.elementID)), t.microphoneId = e, t.audioConstraint.deviceId = {
              exact: e
            }, n && n();
          };

          try {
            Object(f.isSafari)() ? t.replaceTrack(o.getAudioTracks()[0], r, i) : (t.removeTrack(t.stream.getAudioTracks()[0]), t.addTrack(o.getAudioTracks()[0]), r());
          } catch (e) {
            return i && i(e);
          }
        }, function (e) {
          return i && i(e);
        });
      }, t.switchDevice = function (e, n, i, o) {
        var s = a.b.reportApiInvoke(t.sid, {
          callback: function callback(e, t) {
            if (e) return o && o(e);
            i && i(t);
          },
          name: "Stream.switchDevice",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "deviceId");

        var c = function c() {
          return t.inSwitchDevice = !1, s();
        },
            d = function d(e) {
          t.inSwitchDevice = !1, r.default.error("[".concat(t.streamId, "] "), e), s(e);
        };

        if (t.inSwitchDevice) return s("Device switch is in process.");
        if (t.inSwitchDevice = !0, !t.local) return d("Only the local stream can switch the device.");
        if (t.screen && "video" === e) return d("The device cannot be switched during screen-sharing.");
        if (t.videoSource || t.audioSource) return d("The device cannot be switched when using videoSource or audioSource.");
        if (t.lowStream) return d("The device cannot be switched when using lowstream.");
        var u = !1;

        for (var l in t.audioMixing.sounds) {
          if (t.audioMixing.sounds[l].state !== t.audioMixing.states.IDLE) {
            u = !0;
            break;
          }
        }

        if (t.audioMixing.audioContextInited && u) return d("The device cannot be switched when using audio Mixing.");
        Y.getDeviceById(n, function () {
          if ("video" === e) t._switchVideoDevice(n, c, d);else {
            if ("audio" !== e) return d("Invalid type.");

            t._switchAudioDevice(n, c, d);
          }
        }, function () {
          return d("The device does not exist.");
        });
      }, t;
    },
        fe = n(14),
        me = ["live", "rtc", "web", "interop", "h264_interop", "web-only"],
        ge = ["vp8", "h264"],
        ve = ["aes-128-xts", "aes-256-xts", "aes-128-ecb"],
        Se = function Se(e) {
      e && e.apply(this, [].slice.call(arguments, 1));
    },
        Ie = n(6),
        he = function he(e) {
      var t = s();
      return t.needReconnect = !0, t.isTimeout = !1, t.isInit = !0, t.sendbytes = 0, t.recvbytes = 0, t.startTime = Date.now(), t.lastMsgTime = null, t.clientId = e.clientId, t.hostIndex = 0, t.requestID = 0, e.host instanceof Array ? t.host = e.host : t.host = [e.host], t.getSendBytes = function () {
        return t.sendbytes;
      }, t.getRecvBytes = function () {
        return t.recvbytes;
      }, t.getDuration = function () {
        return Math.ceil((Date.now() - t.startTime) / 1e3);
      }, t.getURL = function () {
        return t.connection.url;
      }, t.reconnect = function () {
        t.isInit = !0, t.creatConnection();
      }, t.connectNext = function () {
        t.isInit = !0, ++t.hostIndex, r.default.debug("[" + t.clientId + "] Gateway length:" + t.host.length + " current index:" + t.hostIndex), t.hostIndex >= t.host.length ? t.dispatchEvent(l({
          type: "recover"
        })) : t.creatConnection();
      }, t.replaceHost = function (e) {
        t.host = e || t.host, t.hostIndex = 0, t.creatConnection();
      }, t.creatConnection = function () {
        t.needReconnect = !0, r.default.debug("[" + t.clientId + "] start connect:" + t.host[t.hostIndex]), t.lts = new Date().getTime(), t.connection = new WebSocket("wss://" + t.host[t.hostIndex]), t.connection.onopen = function (e) {
          r.default.debug("[" + t.clientId + "] websockect opened: " + t.host[t.hostIndex]), t.needReconnect = !0, t.isTimeout = !1, t.isInit = !1, t.sendbytes = 0, t.recvbytes = 0, t.startTime = Date.now(), Object(Ie.d)(), clearTimeout(t.timeoutCheck), t.dispatchEvent(l({
            type: "onopen",
            event: e,
            socket: t
          }));
        }, t.connection.onmessage = function (e) {
          t.recvbytes += Object(G.e)(e.data);
          var n = JSON.parse(e.data);
          t.lastMsgTime = Date.now(), n.hasOwnProperty("_id") ? t.dispatchEvent(l({
            type: n._id,
            msg: n
          })) : n.hasOwnProperty("_type") && t.dispatchSocketEvent(l({
            type: n._type,
            msg: n.message
          }));
        }, t.connection.onclose = function (n) {
          t.needReconnect ? t.isTimeout || t.isInit ? (r.default.debug("[" + t.clientId + "] websockect connect timeout"), a.b.joinGateway(e.sid, {
            lts: t.lts,
            succ: !1,
            ec: "timeout",
            addr: t.connection.url
          }), t.connectNext()) : t.dispatchEvent(l({
            type: "disconnect",
            event: n
          })) : (r.default.debug("[" + t.clientId + "] websockect closeed"), Se(e.onFailure, n), clearTimeout(t.timeoutCheck), t.dispatchEvent(l({
            type: "close",
            event: n
          })), t.connection.onopen = void 0, t.connection.onclose = void 0, t.connection.onerror = void 0, t.connection.onmessage = void 0, t.connection = void 0);
        }, t.connection.onerror = function (e) {}, setTimeout(function () {
          t.connection && t.connection.readyState != WebSocket.OPEN && (t.isTimeout = !0, t.connection.close());
        }, 5e3);
      }, t.creatConnection(), t.sendMessage = function (e, n) {
        if (t.connection && t.connection.readyState == WebSocket.OPEN) {
          var i = JSON.stringify(e);
          t.sendbytes += Object(G.e)(i), t.connection.send(i);
        } else n({
          error: "Gateway not connected"
        });
      }, t.disconnect = function () {
        t.needReconnect = !0, t.connection.close();
      }, t.close = function () {
        t.needReconnect = !1, t.connection.onclose = void 0, t.connection.close();
      }, t.sendSignalCommand = function (e, n) {
        e._id = "_request_" + t.requestID, t.requestID += 1, "publish_stats" !== e._type && "subscribe_stats" !== e._type && "publish_stats_low" !== e._type && t.on(e._id, function (i) {
          i.msg && n && n(i.msg._result, i.msg.message), delete t.dispatcher.eventListeners[e._id];
        }), t.sendMessage(e, function (e) {
          e.reason = "NOT_CONNECTED", n && n(e.reason, e);
        });
      }, t;
    },
        ye = function ye(e, t) {
      var n = {
        connect: function connect() {
          t.host = e, n.signal = he(t), n.on = n.signal.on, n.dispatchEvent = n.signal.dispatchEvent, n.signal.on("onopen", function (e) {
            n.signal.onEvent = function (e) {
              n.dispatchEvent(l({
                type: e.event,
                msg: e
              }));
            }, n.dispatchEvent(l({
              type: "connect",
              msg: e
            }));
          }), n.signal.on("onError", function (e) {
            var t = e.msg;
            onError(t.code, "error");
          });
        },
        getLastMsgTime: function getLastMsgTime() {
          return n.signal && n.signal.lastMsgTime;
        },
        getSendBytes: function getSendBytes() {
          return n.signal.getSendBytes();
        },
        getRecvBytes: function getRecvBytes() {
          return n.signal.getRecvBytes();
        },
        getDuration: function getDuration() {
          return n.signal.getDuration();
        },
        disconnect: function disconnect() {
          n.signal.disconnect();
        },
        close: function close() {
          n.signal.close();
        },
        getURL: function getURL() {
          return n.signal.getURL();
        },
        reconnect: function reconnect() {
          n.signal.reconnect();
        },
        connectNext: function connectNext() {
          n.signal.connectNext();
        },
        replaceHost: function replaceHost(e) {
          n.signal.replaceHost(e);
        },
        emitSimpleMessage: function emitSimpleMessage(e, t) {
          n.signal.sendSignalCommand(e, t);
        }
      };
      return n.connect(), n;
    },
        _e = n(10),
        Ee = n.n(_e),
        be = n(15),
        Te = n.n(be),
        Ae = function Ae(e, t) {
      var n = !1,
          i = 0,
          s = {
        command: "convergeAllocateEdge",
        sid: e.sid,
        appId: e.appId,
        token: e.token,
        uid: e.uid,
        cname: e.cname,
        ts: Math.floor(Date.now() / 1e3),
        version: o.VERSION,
        seq: 0,
        requestId: 1
      };
      Object(o.getParameter)("PROXY_CS").map(function (c) {
        var d = new Date().getTime();
        Re("https://" + c + "/api/v1", s, function (s, u) {
          if (s) return r.default.debug("[" + e.clientId + "] Request proxy server failed: ", s), i++, a.b.requestProxyAppCenter(e.sid, {
            lts: d,
            succ: !1,
            APAddr: c,
            workerManagerList: null,
            ec: JSON.stringify(s),
            response: JSON.stringify({
              err: s,
              res: u
            })
          }), void (i >= Object(o.getParameter)("PROXY_CS").length && t && t("Get proxy server failed: request all failed"));
          if (!n) if ((u = JSON.parse(u)).json_body) {
            var l = JSON.parse(u.json_body);

            if (r.default.debug("[" + e.clientId + "] App return:", l.servers), 200 !== l.code) {
              s = "Get proxy server failed: response code [" + l.code + "], reason [ " + l.reason + "]";
              r.default.debug("[" + e.clientId + "] " + s), a.b.requestProxyAppCenter(e.sid, {
                lts: d,
                succ: !1,
                APAddr: c,
                workerManagerList: null,
                ec: s,
                response: JSON.stringify({
                  err: s,
                  res: u
                })
              });
            } else {
              n = !0;
              var p = Oe(l.servers);
              a.b.requestProxyAppCenter(e.sid, {
                lts: d,
                succ: !0,
                APAddr: c,
                workerManagerList: JSON.stringify(p),
                ec: null,
                response: JSON.stringify({
                  res: u
                })
              }), t && t(null, p);
            }
          } else r.default.debug("[" + e.clientId + "] Get proxy server failed: no json_body"), a.b.requestProxyAppCenter(e.sid, {
            lts: d,
            succ: !1,
            APAddr: c,
            workerManagerList: null,
            ec: "Get proxy server failed: no json_body",
            response: JSON.stringify({
              res: u
            })
          });
        });
      });
    },
        Re = function Re(e, t, n) {
      var i = {
        service_name: "webrtc_proxy",
        json_body: JSON.stringify(t)
      };
      Object(Ie.c)(e, i, function (e) {
        n && n(null, e);
      }, function (e) {
        n && n(e);
      }, {
        "X-Packet-Service-Type": 0,
        "X-Packet-URI": 61
      });
    },
        Ce = function Ce(e, t, n) {
      var i = !1,
          o = 0,
          s = {
        command: "request",
        gatewayType: "http",
        appId: e.appId,
        cname: e.cname,
        uid: e.uid + "",
        sdkVersion: "2.3.1",
        sid: e.sid,
        seq: 1,
        ts: +new Date(),
        requestId: 3,
        clientRequest: {
          appId: e.appId,
          cname: e.cname,
          uid: e.uid + "",
          sid: e.sid
        }
      };
      t.map(function (c) {
        var d = new Date().getTime();
        !function (e, t, n) {
          Object(Ie.c)(e, t, function (e) {
            n && n(null, e);
          }, function (e) {
            n && n(e);
          });
        }("https://" + c + ":4000/v2/machine", s, function (s, u) {
          if (s) return r.default.debug("[" + e.clientId + "] Request worker manager failed: ", s), o++, a.b.requestProxyWorkerManager(e.sid, {
            lts: d,
            succ: !1,
            workerManagerAddr: c,
            ec: JSON.stringify(s),
            response: JSON.stringify({
              res: u
            })
          }), void (o >= t.length && n && n("requeet worker manager server failed: request failed"));

          if (!i) {
            if (!(u = JSON.parse(u)).serverResponse) return n && n("requeet worker manager server failed: serverResponse is undefined");
            i = !0, a.b.requestProxyWorkerManager(e.sid, {
              lts: d,
              succ: !0,
              workerManagerAddr: c,
              ec: JSON.stringify(s),
              response: JSON.stringify({
                res: u
              })
            }), n && n(null, {
              address: c,
              serverResponse: u.serverResponse
            });
          }
        });
      });
    },
        Oe = function Oe(e) {
      if (!e || [] instanceof Array == !1) return [];
      var t = [];
      return e.forEach(function (e) {
        var n;
        e.address && e.tcp ? (e.address.match(/^[\.\:\d]+$/) ? n = "".concat(e.address.replace(/[^\d]/g, "-"), ".edge.agora.io") : (r.default.info("[" + joinInfo.clientId + "] " + "Cannot recognized as IP address ".concat(e.address, ". Used As Host instead")), n = "".concat(e.address, ":").concat(e.tcp)), t.push(n)) : r.default.error("[" + joinInfo.clientId + "] Invalid address format ", e);
      }), t;
    },
        we = function we(e, t) {
      var n = S()({}, e),
          i = Object(o.getParameter)("WEBCS_DOMAIN").concat(Object(o.getParameter)("WEBCS_DOMAIN_BACKUP_LIST")),
          r = [],
          a = !1;
      (i = i.map(function (e) {
        return n.proxyServer ? "https://".concat(n.proxyServer, "/ap/?url=").concat(e + "/api/v1") : "https://".concat(e, "/api/v1");
      })).map(function (e) {
        !function (e, t, n) {
          var i = {
            flag: 64,
            cipher_method: 0,
            timeout: 1e3,
            features: t
          };
          Object(Ie.c)(e, i, function (e) {
            try {
              var t = JSON.parse(e);
              n && n(null, t);
            } catch (e) {
              n && n(e);
            }

            n && n(null, e);
          }, function (e) {
            n && n(e);
          }, {
            "X-Packet-Service-Type": 0,
            "X-Packet-URI": 54
          });
        }(e, n, function (e, n) {
          a || (e ? (r.push(e), r.length >= i.length && t && t("ALL_REQUEST_FAILED")) : (a = !0, t && t(null, n)));
        });
      });
    },
        Ne = {},
        De = function De(e, t, n, i) {
      var o = new Date().getTime(),
          s = "";
      t.multiIP && t.multiIP.gateway_ip && (s = {
        vocs_ip: [t.multiIP.uni_lbs_ip],
        vos_ip: [t.multiIP.gateway_ip]
      });
      var c = {
        flag: 4,
        ts: +new Date(),
        key: t.appId,
        cname: t.cname,
        sid: t.sid,
        detail: {},
        uid: t.uid || 0
      };
      s && (c.detail[5] = JSON.stringify(s)), Object(Ie.c)(e + "".concat(-1 === e.indexOf("?") ? "?" : "&", "action=wrtc_gateway"), c, function (s) {
        try {
          var c = JSON.parse(s).res,
              d = c.code;
        } catch (e) {
          var u = "requestChooseServer failed with unexpected body " + s;
          return r.default.error("[" + joinInfo.clientId + "]", u), i(u);
        }

        if (d) {
          var l = y[c.code] || d;
          return a.b.joinChooseServer(t.sid, {
            lts: o,
            succ: !1,
            csAddr: e,
            serverList: null,
            ec: l
          }), i("Get server node failed [" + l + "]", e, l);
        }

        var p = [],
            f = [".agora.io", ".agoraio.cn"],
            m = 0;

        if (e.indexOf(f[1]) > -1 && (m = 1), c.addresses.forEach(function (e) {
          var t;
          e.ip && e.port ? (e.ip.match(/^[\.\:\d]+$/) ? t = "webrtc-".concat(e.ip.replace(/[^\d]/g, "-")).concat(f[m++ % f.length], ":").concat(e.port) : (r.default.info("[" + joinInfo.clientId + "] " + "Cannot recognized as IP address ".concat(e.ip, ". Used As Host instead")), t = "".concat(e.ip, ":").concat(e.port)), p.push(t)) : r.default.error("[" + joinInfo.clientId + "] Invalid address format ", e);
        }), !p.length) {
          r.default.error("[" + joinInfo.clientId + "] Empty Address response", c);
          l = "EMPTY_ADDRESS_RESPONSE";
          return a.b.joinChooseServer(t.sid, {
            lts: o,
            succ: !1,
            csAddr: e,
            serverList: null,
            ec: l
          }), i("Get server node failed [" + l + "]", e, l);
        }

        var g = {
          gateway_addr: p,
          uid: c.uid,
          cid: c.cid,
          uni_lbs_ip: c.detail
        };
        return n(g, e);
      }, function (e, n) {
        "timeout" === e.type ? (a.b.joinChooseServer(t.sid, {
          lts: o,
          succ: !1,
          csAddr: n,
          serverList: null,
          ec: "timeout"
        }), i("Connect choose server timeout", n)) : a.b.joinChooseServer(t.sid, {
          lts: o,
          succ: !1,
          csAddr: n,
          serverList: null,
          ec: "server_wrong"
        });
      }, {
        "X-Packet-Service-Type": 0,
        "X-Packet-URI": 44
      });
    },
        ke = function ke(e, t, n) {
      var i = !1,
          s = null,
          c = 1,
          d = 1,
          u = null,
          l = e.clientId;
      Ne[l] = !0;

      var p = function t(n, d) {
        if (!i) {
          var p = !1,
              m = !1,
              g = [],
              v = f.getBrowserInfo() || {};
          we({
            device: v.name,
            system: v.os,
            vendor: e.appId,
            version: o.VERSION,
            cname: e.cname,
            sid: e.sid,
            session_id: Object(a.a)(),
            detail: "",
            proxyServer: n
          }, function (t, n) {
            m = !0;

            try {
              var i = Object.keys(n.test_tags)[0],
                  o = JSON.parse(n.test_tags[i]);
              u = o[1];
            } catch (e) {
              u = null;
            }

            a.b.reportApiInvoke(e.sid, {
              name: "_config-distribute-request",
              options: {
                err: t,
                res: n
              }
            })(), p && d && d(g, u);
          }), function (e, t, n) {
            for (var i = new Date().getTime(), s = !1, c = !0, d = function d(n, o) {
              if (s) a.b.joinChooseServer(e.sid, {
                lts: i,
                succ: !0,
                csAddr: o,
                serverList: n.gateway_addr,
                cid: n.cid + "",
                uid: n.uid + "",
                ec: null
              }, !1);else {
                if (clearTimeout(g), s = !0, r.default.debug("[" + e.clientId + "] Get gateway address:", n.gateway_addr), e.proxyServer) {
                  for (var c = n.gateway_addr, d = 0; d < c.length; d++) {
                    var u = c[d].split(":");
                    n.gateway_addr[d] = e.proxyServer + "/ws/?h=" + u[0] + "&p=" + u[1];
                  }

                  r.default.debug("[" + e.clientId + "] Get gateway address:", n.gateway_addr);
                }

                t(n), a.b.joinChooseServer(e.sid, {
                  lts: i,
                  succ: !0,
                  csAddr: o,
                  serverList: n.gateway_addr,
                  cid: n.cid + "",
                  uid: n.uid + "",
                  ec: null
                }, !0);
              }
            }, u = function u(t, i, o) {
              c && (r.default.error("[" + e.clientId + "]", t, i, o), o && -1 === b.indexOf(o) && (c = !1, n(o)));
            }, l = Object(o.getParameter)("WEBCS_DOMAIN"), p = 0; p < l.length; ++p) {
              var f;

              if ("string" == typeof l[p]) {
                var m = l[p];
                f = e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(m + "/api/v1") : "https://".concat(m, "/api/v1"), r.default.debug("[" + e.clientId + "] " + "Connect to choose_server: ".concat(f)), De(f, e, d, u);
              } else r.default.error("[" + e.clientId + "] Invalid Host", l[p]);
            }

            var g = setTimeout(function () {
              if (!s) for (var t = Object(o.getParameter)("WEBCS_DOMAIN_BACKUP_LIST"), n = 0; n < t.length; ++n) {
                if ("string" == typeof t[n]) {
                  var i = t[n];
                  f = e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(i + "/api/v1") : "https://".concat(i, "/api/v1"), r.default.debug("[" + e.clientId + "] " + "Connect to backup_choose_server: ".concat(f)), De(f, e, d, u);
                } else r.default.error("[" + e.clientId + "] Invalid Host", t[n]);
              }
            }, 1e3);
            setTimeout(function () {
              !s && c && n();
            }, Object(o.getParameter)("WEBCS_BACKUP_CONNECT_TIMEOUT"));
          }(e, function (e) {
            i = !0, p = !0, g = e, clearTimeout(s), m && d && d(g, u);
          }, function (i) {
            i ? r.default.info("[" + e.clientId + "] Join failed: " + i) : Ne[l] && (r.default.debug("[" + e.clientId + "] Request gateway list will be restart in " + c + "s"), s = setTimeout(function () {
              t(n, d);
            }, 1e3 * c), c = c >= 3600 ? 3600 : 2 * c);
          });
        }
      };

      e.useProxyServer ? function n() {
        !function (e, t) {
          Ae(e, function (n, i) {
            if (n) return t && t(n);
            r.default.debug("[" + e.clientId + "] getProxyServerList: ", i), Ce(e, i, t);
          });
        }(e, function (i, o) {
          if (i) {
            if (r.default.debug("[" + e.clientId + "]", i), !Ne[l]) return;
            return r.default.debug("[" + e.clientId + "] Request proxy will be restart in " + d + "s"), s = setTimeout(function () {
              n();
            }, 1e3 * d), void (d = d >= 3600 ? 3600 : 2 * d);
          }

          clearTimeout(s);
          var c = o.address;
          e.proxyServer = c, e.turnServer = {
            url: o.address,
            tcpport: o.serverResponse.tcpport || "3433",
            udpport: o.serverResponse.udpport || "3478",
            username: o.serverResponse.username || "test",
            credential: o.serverResponse.password || "111111",
            forceturn: !0
          }, e.turnServer.tcpport += "", e.turnServer.udpport += "", a.b.setProxyServer(c), r.default.setProxyServer(c), p(c, t);
        });
      }() : p(null, t);
    },
        Me = function Me(e, t) {
      var n = Date.now(),
          i = {
        sid: t.sid,
        opid: 10,
        appid: t.appId,
        string_uid: t.stringUid
      };
      return new Promise(function (o, s) {
        Object(Ie.c)(e + "".concat(-1 === e.indexOf("?") ? "?" : "&", "action=stringuid"), i, function (c) {
          try {
            var d = JSON.parse(c),
                u = d.code;
          } catch (o) {
            var l = "requestUserAccount failed with unexpected body " + c;
            return r.default.error("[" + t.clientId + "]", l), s({
              retryable: !0,
              info: l,
              url: e
            }), void a.b.reqUserAccount(i.sid, {
              lts: n,
              success: !1,
              serverAddress: e,
              stringUid: i.stringUid,
              uid: null,
              extend: c,
              errorCode: "BODY_NOT_JSON"
            });
          }

          if (u) {
            var p = E[d.code % 1e4] || "REQ_ACCOUNT_ERR_".concat(u);
            return a.b.reqUserAccount(i.sid, {
              lts: n,
              success: !1,
              serverAddress: e,
              stringUid: i.stringUid,
              uid: null,
              errorCode: p,
              extend: i
            }), s({
              retryable: !1,
              info: l = "Get String Uid Failed [" + p + "]",
              url: e,
              error: p
            });
          }

          var f = d.uid;

          if (!(f > 0 && f < Math.pow(2, 32))) {
            r.default.error("[" + t.clientId + "] " + "Invalid Uint Uid ".concat(t.stringUid, " => ").concat(f), d);
            p = "INVALID_UINT_UID_".concat(f);
            return a.b.reqUserAccount(i.sid, {
              lts: n,
              success: !1,
              serverAddress: e,
              stringUid: i.stringUid,
              uid: null,
              errorCode: p,
              extend: i
            }), s({
              retryable: !0,
              error: p,
              info: "Get String Uid failed [" + p + "]",
              url: e
            });
          }

          o({
            uid: f,
            url: e
          }), a.b.reqUserAccount(i.sid, {
            lts: n,
            success: !0,
            serverAddress: e,
            stringUid: i.stringUid,
            uid: f,
            errorCode: null,
            extend: i
          });
        }, function (e, t) {
          if ("timeout" === e.type) {
            var o = "USER_ACCOUNT_TIMEOUT";
            a.b.reqUserAccount(i.sid, {
              lts: n,
              success: !1,
              serverAddress: t,
              stringUid: i.stringUid,
              uid: null,
              errorCode: o,
              extend: i
            }), s({
              retryable: !0,
              info: o,
              url: t
            });
          } else {
            var r = "USER_ACCOUNT_SERVER_WRONG_".concat(e.type);
            a.b.reqUserAccount(i.sid, {
              lts: n,
              success: !1,
              serverAddress: t,
              stringUid: i.stringUid,
              uid: null,
              errorCode: r,
              extend: i
            }), s({
              retryable: !0,
              info: r,
              url: t
            });
          }
        }, {
          "X-Packet-Service-Type": 0,
          "X-Packet-URI": 72
        });
      });
    },
        Le = function Le(e) {
      Date.now();
      var t,
          n = Object(o.getParameter)("ACCOUNT_REGISTER"),
          a = !1,
          s = Object(o.getParameter)("ACCOUNT_REGISTER_RETRY_TIMEOUT"),
          c = null,
          d = null,
          u = new Promise(function () {
        var u = Te()(Ee.a.mark(function u(l, p) {
          var f, m, g;
          return Ee.a.wrap(function (u) {
            for (;;) {
              switch (u.prev = u.next) {
                case 0:
                  c = l, d = p, t = 0;

                case 3:
                  if (!(t < Object(o.getParameter)("ACCOUNT_REGISTER_RETRY_COUNT_MAX"))) {
                    u.next = 33;
                    break;
                  }

                  if (!a) {
                    u.next = 6;
                    break;
                  }

                  return u.abrupt("return");

                case 6:
                  return f = n[t % n.length], m = e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(n[i] + "/api/v1") : "https://".concat(f, "/api/v1"), u.prev = 8, u.delegateYield(Ee.a.mark(function t() {
                    var n;
                    return Ee.a.wrap(function (t) {
                      for (;;) {
                        switch (t.prev = t.next) {
                          case 0:
                            return t.next = 2, Me(m, e);

                          case 2:
                            if (n = t.sent, !a) {
                              t.next = 5;
                              break;
                            }

                            return t.abrupt("return", {
                              v: void 0
                            });

                          case 5:
                            a = !0, setTimeout(function () {
                              r.default.debug("Get UserAccount Successfully", n), c(n);
                            }, 0);

                          case 7:
                          case "end":
                            return t.stop();
                        }
                      }
                    }, t, this);
                  })(), "t0", 10);

                case 10:
                  if (g = u.t0, "object" !== q()(g)) {
                    u.next = 13;
                    break;
                  }

                  return u.abrupt("return", g.v);

                case 13:
                  u.next = 30;
                  break;

                case 15:
                  if (u.prev = 15, u.t1 = u.catch(8), !a) {
                    u.next = 19;
                    break;
                  }

                  return u.abrupt("return");

                case 19:
                  if (!u.t1.retryable) {
                    u.next = 27;
                    break;
                  }

                  return (s = Math.ceil(s * Object(o.getParameter)("ACCOUNT_REGISTER_RETRY_RATIO"))) > Object(o.getParameter)("ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX") && (s = Object(o.getParameter)("ACCOUNT_REGISTER_RETRY_TIMEOUT_MAX")), r.default.error("".concat(u.t1.info, " ").concat(u.t1.url, " Will Fetch User Account in ").concat(s / 1e3, " seconds")), u.next = 25, new Promise(function (e) {
                    setTimeout(e, s);
                  });

                case 25:
                  u.next = 30;
                  break;

                case 27:
                  r.default.error("Get UserAccount Error: ".concat(u.t1.info, " ").concat(u.t1.url), u.t1.error), a = !0, d(u.t1);

                case 30:
                  t++, u.next = 3;
                  break;

                case 33:
                case "end":
                  return u.stop();
              }
            }
          }, u, this, [[8, 15]]);
        }));
        return function (e, t) {
          return u.apply(this, arguments);
        };
      }());
      return u.cancel = function () {
        a || (a = !0, d({
          info: "Request Cancelled",
          retryable: !1
        }));
      }, u.isFinished = function () {
        return a;
      }, u;
    },
        Pe = {
      ERR_NO_VOCS_AVAILABLE: "tryNext",
      ERR_NO_VOS_AVAILABLE: "tryNext",
      ERR_JOIN_CHANNEL_TIMEOUT: "tryNext",
      WARN_REPEAT_JOIN: "quit",
      ERR_JOIN_BY_MULTI_IP: "recover",
      WARN_LOOKUP_CHANNEL_TIMEOUT: "tryNext",
      WARN_OPEN_CHANNEL_TIMEOUT: "tryNext",
      ERR_VOM_SERVICE_UNAVAILABLE: "tryNext",
      ERR_TOO_MANY_USERS: "tryNext",
      ERR_MASTER_VOCS_UNAVAILABLE: "tryNext",
      ERR_INTERNAL_ERROR: "tryNext",
      notification_test_recover: "recover",
      notification_test_tryNext: "tryNext",
      notification_test_retry: "retry"
    },
        xe = {
      googResidualEchoLikelihood: "A_rel",
      googResidualEchoLikelihoodRecentMax: "A_rem",
      googTypingNoiseState: "A_tns",
      totalSamplesDuration: "A_sd",
      googAdaptationChanges: "A_ac",
      googBandwidthLimitedResolution: "A_blr",
      googCpuLimitedResolution: "A_clr",
      googEncodeUsagePercent: "A_eup",
      googHasEnteredLowResolution: "A_helr",
      googActualEncBitrate: "A_aeb",
      googAvailableReceiveBandwidth: "A_arb",
      googAvailableSendBandwidth: "A_asb",
      googRetransmitBitrate: "A_rb",
      googTargetEncBitrate: "A_teb",
      googCaptureStartNtpTimeMs: "A_csnt",
      googPreemptiveExpandRate: "A_per",
      googPreferredJitterBufferMs: "A_pjbm",
      googSecondaryDecodedRate: "A_sder",
      googSecondaryDiscardedRate: "A_sdir",
      googSpeechExpandRate: "A_ser",
      googFrameHeightReceived: "A_fhr",
      googInterframeDelayMax: "A_ifdm",
      googMinPlayoutDelayMs: "A_mpdm",
      aecDivergentFilterFraction: "A_dff",
      codecImplementationName: "A_cin",
      googEchoCancellationReturnLoss: "A_ecl",
      googEchoCancellationReturnLossEnhancement: "A_ece"
    },
        Ve = {};

    for (var Ue in xe) {
      var Fe = xe[Ue];
      xe[Fe] && console.error("Key Conflict: ".concat(Ue)), Ve[Fe] = Ue;
    }

    var Be = function Be(e) {
      return xe[e] || e;
    },
        je = function e(t) {
      var n = !1,
          i = function i(e) {
        return {
          _type: "control",
          message: e
        };
      },
          c = function c(e) {
        var t = {};
        return Object.keys(e).forEach(function (n) {
          t[Be(n)] = e[n];
        }), {
          _type: "subscribe_related_stats",
          options: t
        };
      },
          m = function m(e, t, n) {
        return {
          _type: "publish",
          options: e,
          sdp: t,
          p2pid: n
        };
      },
          g = e.DISCONNECTED,
          v = e.CONNECTING,
          I = e.CONNECTED,
          h = e.DISCONNECTING,
          y = g,
          E = s();

      Object.defineProperty(E, "state", {
        set: function set(t) {
          var n = y;
          y = t, n !== t && E.dispatchEvent({
            type: "connection-state-change",
            prevState: e.connetionStateMap[n],
            curState: e.connetionStateMap[t]
          });
        },
        get: function get() {
          return y;
        }
      }), E.socket = void 0, E.state = g, E.mode = t.mode, E.role = t.role, E.codec = t.codec, E.config = {}, E.timers = {}, E.timer_counter = {}, E.localStreams = {}, E.remoteStreams = {}, E.attemps = 1, E.p2p_attemps = 1, E.audioLevel = {}, E.activeSpeaker = void 0, E.reconnectMode = "retry", E.rejoinAttempt = 0, E.hasChangeBGPAddress = !1, E.traffic_stats = {}, E.clientId = t.clientId, E.pingpongCounter = 0, E.p2ps = new Map(), E.liveStreams = new Map(), E.injectLiveStreams = new Map(), E.remoteStreamsInChannel = new Set(), E.inChannelInfo = {
        joinAt: null,
        duration: 0
      };
      var b = Se;
      E.p2pCounter = Object(G.g)(1e5), E.generateP2PId = function () {
        return ++E.p2pCounter;
      }, E.audioVolumeIndication = {
        enabled: !1,
        sortedAudioVolumes: [],
        smooth: 3,
        interval: 2e3
      }, E.remoteVideoStreamTypes = {
        REMOTE_VIDEO_STREAM_HIGH: 0,
        REMOTE_VIDEO_STREAM_LOW: 1,
        REMOTE_VIDEO_STREAM_MEDIUM: 2
      }, E.streamFallbackTypes = {
        STREAM_FALLBACK_OPTION_DISABLED: 0,
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW: 1,
        STREAM_FALLBACK_OPTION_AUDIO_ONLY: 2
      }, E.configPublisher = function (e) {
        E.config = e;
      }, E.getGatewayInfo = function (e, t) {
        w({
          _type: "gateway_info"
        }, e, t);
      }, E.setClientRole = function (e, t) {
        r.default.debug("[".concat(E.clientId, "] setClientRole to ").concat(e));
        var n = a.b.reportApiInvoke(E.joinInfo.sid, {
          name: "_setClientRole",
          callback: t
        });
        w(function (e) {
          return {
            _type: "set_client_role",
            message: e
          };
        }(e), function () {
          E.role = e, E.dispatchEvent({
            type: "client-role-changed",
            role: e
          }), n && n(null, {
            role: e
          });
        }, function (t) {
          var i = t && t.code ? t.code : 0,
              o = T[i];
          if ("ERR_ALREADY_IN_USE" === o) return n && n(null);
          o || (o = "UNKNOW_ERROR_".concat(i)), r.default.error("set Client role error to " + e + ": " + o), n && n(o);
        });
      }, E.join = function (e, n, i, s) {
        e.useProxyServer && (E.hasChangeBGPAddress = !0);
        var c = new Date().getTime(),
            d = e.uid;
        if (E.inChannelInfo.joinAt && (E.inChannelInfo.duration += c - E.inChannelInfo.joinAt), E.inChannelInfo.joinAt = c, E.state !== v) return r.default.error("[".concat(E.clientId, "] GatewayClient.join Failed: state "), E.state), s && s(A.INVALID_OPERATION), void a.b.joinGateway(e.sid, {
          lts: c,
          succ: !1,
          ec: A.INVALID_OPERATION,
          addr: null
        });
        if (null != d && parseInt(d) !== d) return r.default.error("[".concat(E.clientId, "] Input uid is invalid")), E.state = g, s && s(A.INVALID_PARAMETER), void a.b.joinGateway(e.sid, {
          lts: c,
          succ: !1,
          ec: A.INVALID_PARAMETER,
          addr: null
        });
        var u = We.register(E, {
          uid: d,
          cname: e && e.cname
        });
        if (u) return E.state = g, s && s(u), void a.b.joinGateway(e.sid, {
          lts: c,
          succ: !1,
          ec: u,
          addr: null
        });
        E.joinInfo = S()({}, e), E.uid = d, E.key = n, E.pingpongCounter = 0, O(e, function (n) {
          var d, u, p;
          E.state = I, r.default.debug("[".concat(E.clientId, "] Connected to gateway server")), E.pingTimer = setInterval(function () {
            var e = Object(o.getParameter)("PING_PONG_TIME_OUT");

            if (++E.pingpongCounter >= e) {
              var t = Date.now();
              r.default.warning("PINGPONG Timeout. Last Socket Message: ".concat(t - E.socket.getLastMsgTime(), "ms")), E.socket && E.socket.getLastMsgTime() && t - E.socket.getLastMsgTime() > Object(o.getParameter)("WEBSOCKET_TIMEOUT_MIN") && (E.pingpongCounter = 0, E.socket.close(), E.socket.dispatchEvent(l({
                type: "disconnect",
                event: {
                  msg: "PING_PONG_TIME_OUT"
                }
              })));
            }

            var n = Date.now();
            w({
              _type: "ping"
            }, function () {
              E.pingpongCounter = 0;
              var e = Date.now() - n;
              w({
                _type: "signal_stats",
                message: {
                  pingpongElapse: e
                }
              }, function () {}, function (e) {});
            }, function (e) {});
          }, 3e3), w((d = {
            role: E.role
          }, u = d.role, p = {
            appId: t.appId,
            key: E.key,
            channel: E.joinInfo.cname,
            uid: E.uid,
            version: o.VERSION,
            browser: navigator.userAgent,
            mode: E.mode,
            codec: E.codec,
            role: u,
            config: E.config,
            processId: Object(a.a)()
          }, E.joinInfo.hasOwnProperty("stringUid") && (p.stringUid = E.joinInfo.stringUid), {
            _type: "join1",
            message: p
          }), function (t) {
            if (a.b.joinGateway(e.sid, {
              lts: c,
              succ: !0,
              ec: null,
              vid: t.vid,
              addr: E.socket.getURL()
            }), E.rejoinAttempt = 0, i && i(t.uid), E.dispatchEvent({
              type: "join"
            }), E.leaveOnConnected) {
              r.default.info("[".concat(E.clientId, "] Calling Leave() once joined"));
              var n = E.leaveOnConnected;
              E.leaveOnConnected = null, E.leave(n.onSuccess, n.onFailure);
            }
          }, function (t) {
            if (r.default.error("[".concat(E.clientId, "] User join failed [").concat(t, "]")), Pe[t] && E.rejoinAttempt < 4) {
              if (E._doWithAction(Pe[t], i, s), E.leaveOnConnected) {
                r.default.error("[".concat(E.clientId, "] Calling Leave() once joined: Join Failed"));
                var n = E.leaveOnConnected;
                E.leaveOnConnected = null, n.onFailure(A.JOIN_CHANNEL_FAILED);
              }
            } else s && s(t);

            a.b.joinGateway(e.sid, {
              lts: c,
              succ: !1,
              ec: t,
              addr: E.socket.getURL()
            });
          });
        }, function (t) {
          r.default.error("[".concat(E.clientId, "] User join failed [").concat(t, "]")), s && s(t), a.b.joinGateway(e.sid, {
            lts: c,
            succ: !1,
            ec: t,
            addr: E.socket.getURL()
          });
        }), clearInterval(E.timers.trafficStats), E.timers.trafficStats = setInterval(function () {
          w({
            _type: "traffic_stats"
          }, function (e) {
            E.traffic_stats = e;
            var t = E.joinInfo.stringUid,
                n = E.localStreams[d] || E.localStreams[t];
            n && (n.traffic_stats = {
              access_delay: e.access_delay
            }), e.peer_delay && e.peer_delay.forEach(function (t) {
              var n = E.remoteStreams[t.peer_uid];
              n && (n.traffic_stats = {
                access_delay: e.access_delay,
                e2e_delay: t.e2e_delay,
                audio_delay: t.audio_delay,
                video_delay: t.video_delay
              });
            });
          });
        }, 3e3), E.resetAudioVolumeIndication();
      }, E.leave = function (e, t) {
        switch (E.state) {
          case g:
            return r.default.debug("[".concat(E.clientId, "] Client Already in DISCONNECTED status")), void b(e);

          case h:
            return r.default.error("[".concat(E.clientId, "] Client Already in DISCONNECTING status")), void b(t, A.INVALID_OPERATION);

          case v:
            return E.leaveOnConnected ? (r.default.error("[".concat(E.clientId, "] Client.leave() already called")), void b(t, A.INVALID_OPERATION)) : (r.default.debug("[".concat(E.clientId, "] Client connecting. Waiting for Client Fully Connected(And leave)")), void (E.leaveOnConnected = {
              onSuccess: e,
              onFailure: t
            }));
        }

        var n = We.unregister(E);
        if (n) r.default.error("[".concat(E.clientId, "] "), n);else {
          for (var i in E.state = h, clearInterval(E.pingTimer), E.timers) {
            E.timers.hasOwnProperty(i) && clearInterval(E.timers[i]);
          }

          for (var i in E.inChannelInfo.joinAt && (E.inChannelInfo.duration += Date.now() - E.inChannelInfo.joinAt, E.inChannelInfo.joinAt = null), w({
            _type: "leave"
          }, function (t) {
            E.socket.close(), E.socket = void 0, r.default.info("[".concat(E.clientId, "] Leave channel success")), E.state = g, e && e(t);
          }, function (e) {
            r.default.error("[".concat(E.clientId, "] Leave Channel Failed"), e), E.state = I, t && t(e);
          }), E.localStreams) {
            if (E.localStreams.hasOwnProperty(i)) {
              var o = E.localStreams[i];
              delete E.localStreams[i], void 0 !== o.pc && (o.pc.close(), o.pc = void 0);
            }
          }

          k();
        }
      }, E.publish = function (e, t, n, o) {
        var s = new Date().getTime(),
            c = !1;
        if (e.publishLTS = s, "object" !== q()(e) || null === e) return r.default.error("[".concat(E.clientId, "] Invalid local stream")), o && o(A.INVALID_LOCAL_STREAM), void a.b.publish(E.joinInfo.sid, {
          lts: s,
          succ: !1,
          audioName: e.hasAudio() && e.audioName,
          videoName: e.hasVideo() && e.videoName,
          screenName: e.hasScreen() && e.screenName,
          ec: A.INVALID_LOCAL_STREAM
        });
        if (null === e.stream && void 0 === e.url) return r.default.error("[".concat(E.clientId, "] Invalid local media stream")), o && o(A.INVALID_LOCAL_STREAM), void a.b.publish(E.joinInfo.sid, {
          lts: s,
          succ: !1,
          audioName: e.hasAudio() && e.audioName,
          videoName: e.hasVideo() && e.videoName,
          screenName: e.hasScreen() && e.screenName,
          ec: A.INVALID_LOCAL_STREAM
        });
        if (E.state !== I) return r.default.error("[".concat(E.clientId, "] User is not in the session")), o && o(A.INVALID_OPERATION), void a.b.publish(E.joinInfo.sid, {
          lts: s,
          succ: !1,
          audioName: e.hasAudio() && e.audioName,
          videoName: e.hasVideo() && e.videoName,
          screenName: e.hasScreen() && e.screenName,
          ec: A.INVALID_OPERATION
        });
        var d = e.getAttributes() || {};

        if (e.local && void 0 === E.localStreams[e.getId()] && (e.hasAudio() || e.hasVideo() || e.hasScreen())) {
          var l = E.generateP2PId();
          if (E.p2ps.set(l, e), e.p2pId = l, void 0 !== e.url) N(m({
            state: "url",
            audio: e.hasAudio(),
            video: e.hasVideo(),
            attributes: e.getAttributes(),
            mode: E.mode
          }, e.url), function (t, n) {
            "success" === t ? (e.getUserId() !== n && e.setUserId(n), E.localStreams[n] = e, e.onClose = function () {
              E.unpublish(e);
            }) : r.default.error("[".concat(E.clientId, "] Publish local stream failed"), t);
          });else {
            E.localStreams[e.getId()] = e, e.connectionSpec = {
              callback: function callback(d) {
                r.default.debug("[".concat(E.clientId, "] SDP exchange in publish : send offer --  "), JSON.parse(d)), N(m({
                  state: "offer",
                  id: e.getId(),
                  audio: e.hasAudio(),
                  video: e.hasVideo() || e.hasScreen(),
                  attributes: e.getAttributes(),
                  streamType: t.streamType,
                  dtx: e.DTX,
                  hq: e.highQuality,
                  lq: e.lowQuality,
                  stereo: e.stereo,
                  speech: e.speech,
                  mode: E.mode,
                  codec: E.codec,
                  p2pid: l,
                  turnip: E.joinInfo.turnServer.url,
                  turnport: Number(E.joinInfo.turnServer.udpport),
                  turnusername: E.joinInfo.turnServer.username,
                  turnpassword: E.joinInfo.turnServer.credential
                }, d), function (p, f) {
                  if ("error" === p) return r.default.error("[".concat(E.clientId, "] Publish local stream failed")), o && o(A.PUBLISH_STREAM_FAILED), void a.b.publish(E.joinInfo.sid, {
                    lts: s,
                    succ: !1,
                    audioName: e.hasAudio() && e.audioName,
                    videoName: e.hasVideo() && e.videoName,
                    screenName: e.hasScreen() && e.screenName,
                    localSDP: d,
                    ec: A.PUBLISH_STREAM_FAILED
                  });
                  e.pc.onsignalingmessage = function (n) {
                    e.pc.onsignalingmessage = function () {}, N(m({
                      state: "ok",
                      id: e.getId(),
                      audio: e.hasAudio(),
                      video: e.hasVideo(),
                      screen: e.hasScreen(),
                      streamType: t.streamType,
                      attributes: e.getAttributes(),
                      mode: E.mode
                    }, n)), e.getUserId() !== f.id && e.setUserId(f.id), r.default.info("[".concat(E.clientId, "] Local stream published with uid"), f.id), e.onClose = function () {
                      E.unpublish(e);
                    }, e._onAudioUnmute = function () {
                      w(i({
                        action: "audio-out-on",
                        streamId: e.getId()
                      }), function () {}, function () {});
                    }, e._onVideoUnmute = function () {
                      w(i({
                        action: "video-out-on",
                        streamId: e.getId()
                      }), function () {}, function () {});
                    }, e._onAudioMute = function () {
                      w(i({
                        action: "audio-out-off",
                        streamId: e.getId()
                      }), function () {}, function () {});
                    }, e._onVideoMute = function () {
                      w(i({
                        action: "video-out-off",
                        streamId: e.getId()
                      }), function () {}, function () {});
                    }, e.getId() === e.getUserId() && (e.isAudioOn() || e.hasAudio() && (r.default.debug("[".concat(E.clientId, "] local stream audio mute")), e._onAudioMute()), e.isVideoOn() || (e.hasVideo() || e.hasScreen()) && (r.default.debug("[".concat(E.clientId, "] local stream video mute")), e._onVideoMute()));
                  }, e.pc.oniceconnectionstatechange = function (t) {
                    if ("failed" === t) {
                      if (null != E.timers[e.getId()] && (clearInterval(E.timers[e.getId()]), clearInterval(E.timers[e.getId()] + "_RelatedStats")), r.default.error("[".concat(E.clientId, "] Publisher connection is lost -- streamId: ").concat(e.getId(), ", p2pId: ").concat(l)), E.p2ps.delete(l), r.default.debug("[".concat(E.clientId, "] publish p2p failed: "), E.p2ps), !c) return c = !0, a.b.publish(E.joinInfo.sid, {
                        lts: s,
                        succ: !1,
                        audioName: e.hasAudio() && e.audioName,
                        videoName: e.hasVideo() && e.videoName,
                        screenName: e.hasScreen() && e.screenName,
                        ec: A.PEERCONNECTION_FAILED
                      }), E.dispatchEvent(u({
                        type: "pubP2PLost",
                        stream: e
                      })), o && o(A.PEERCONNECTION_FAILED);
                      E.dispatchEvent(u({
                        type: "pubP2PLost",
                        stream: e
                      }));
                    } else if ("connected" === t && (r.default.debug("[".concat(E.clientId, "] publish p2p connected: "), E.p2ps), !c)) return c = !0, a.b.publish(E.joinInfo.sid, {
                      lts: s,
                      succ: !0,
                      audioName: e.hasAudio() && e.audioName,
                      videoName: e.hasVideo() && e.videoName,
                      screenName: e.hasScreen() && e.screenName,
                      ec: null
                    }), n && n();
                  }, r.default.debug("[".concat(E.clientId, "] SDP exchange in publish : receive answer --  "), JSON.parse(p)), e.pc.processSignalingMessage(p);
                });
              },
              audio: e.hasAudio(),
              video: e.hasVideo(),
              screen: e.hasScreen(),
              isSubscriber: !1,
              stunServerUrl: E.stunServerUrl,
              turnServer: E.joinInfo.turnServer,
              maxAudioBW: d.maxAudioBW,
              minVideoBW: d.minVideoBW,
              maxVideoBW: d.maxVideoBW,
              mode: E.mode,
              codec: E.codec,
              isVideoMute: e.userMuteVideo || e.peerMuteVideo,
              isAudioMute: e.userMuteAudio || e.peerMuteAudio,
              maxFrameRate: e.attributes.maxFrameRate,
              clientId: E.clientId
            }, e.pc = W(e.connectionSpec), e.pc.addStream(e.stream), r.default.debug("[".concat(E.clientId, "] PeerConnection add stream :"), e.stream), e.pc.onnegotiationneeded = function (t) {
              N(m({
                state: "negotiation",
                p2pid: l
              }, t), function (t, n) {
                e.pc.processSignalingMessage(t);
              });
            }, E.timers[e.getId()] = setInterval(function () {
              var t = 0;
              e && e.pc && e.pc.getStats && e.pc.getStatsRate(function (n) {
                n.forEach(function (n) {
                  if (n && n.id && !/_recv$/.test(n.id) && !/^time$/.test(n.id) && e.getUserId()) if (-1 === n.id.indexOf("outbound_rtp") && -1 === n.id.indexOf("OutboundRTP") || "video" !== n.mediaType || (n.googFrameWidthSent = e.videoWidth + "", n.googFrameHeightSent = e.videoHeight + ""), e.getId() == e.getUserId()) {
                    var i = 200 * t;
                    t++, setTimeout(function () {
                      var e, t;
                      w((e = n, t = {}, Object.keys(e).forEach(function (n) {
                        t[Be(n)] = e[n];
                      }), {
                        _type: "publish_stats",
                        options: {
                          stats: t
                        },
                        sdp: null
                      }), null, null);
                    }, i);
                  } else {
                    i = 200 * t;
                    t++, setTimeout(function () {
                      var e, t;
                      w((e = n, t = {}, Object.keys(e).forEach(function (n) {
                        t[Be(n)] = e[n];
                      }), {
                        _type: "publish_stats_low",
                        options: {
                          stats: t
                        },
                        sdp: null
                      }), null, null);
                    }, i);
                  }
                });
              });
            }, 3e3);

            var p = function p() {
              e && e.pc && e.pc.getVideoRelatedStats && e.pc.getVideoRelatedStats(function (t) {
                var n, i;
                e.getId() === e.getUserId() ? w((n = t, i = {}, Object.keys(n).forEach(function (e) {
                  i[Be(e)] = n[e];
                }), {
                  _type: "publish_related_stats",
                  options: i
                }), null, null) : w(function (e) {
                  var t = {};
                  return Object.keys(e).forEach(function (n) {
                    t[Be(n)] = e[n];
                  }), {
                    _type: "publish_related_stats_low",
                    options: t
                  };
                }(t), null, null);
              });
            };

            p(), E.timers[e.getId() + "_RelatedStats"] = setInterval(p, 1e3);
          }
        }
      }, E.unpublish = function (e, t, n, i) {
        return "object" !== q()(e) || null === e ? (r.default.error("[".concat(E.clientId, "] Invalid local stream")), void b(i, A.INVALID_LOCAL_STREAM)) : E.state !== I ? (r.default.error("[".concat(E.clientId, "] User not in the session")), void b(i, A.INVALID_OPERATION)) : (null != E.timers[e.getId()] && (clearInterval(E.timers[e.getId()]), clearInterval(E.timers[e.getId() + "_RelatedStats"])), void (void 0 !== E.socket ? e.local && void 0 !== E.localStreams[e.getId()] ? (delete E.localStreams[e.getId()], w((o = e.getUserId(), a = t.streamType, {
          _type: "unpublish",
          message: o,
          streamType: a
        })), (e.hasAudio() || e.hasVideo() || e.hasScreen()) && void 0 === e.url && void 0 !== e.pc && (e.pc.close(), e.pc = void 0), e.onClose = void 0, e._onAudioMute = void 0, e._onAudioUnute = void 0, e._onVideoMute = void 0, e._onVideoUnmute = void 0, E.p2ps.delete(e.p2pId), n && n()) : (r.default.error("[".concat(E.clientId, "] Invalid local stream")), b(i, A.INVALID_LOCAL_STREAM)) : (r.default.error("[".concat(E.clientId, "] User not in the session")), b(i, A.INVALID_OPERATION))));
        var o, a;
      }, E.subscribe = function (e, t, n) {
        var s = new Date().getTime();
        e.subscribeLTS = s;
        var l = !1;
        if (r.default.info("[".concat(E.clientId, "] Gatewayclient ").concat(E.uid, " Subscribe ").concat(e.getId(), ": ").concat(JSON.stringify(e.subscribeOptions))), "object" !== q()(e) || null === e) return r.default.error("[".concat(E.clientId, "] Invalid remote stream")), n && n(A.INVALID_REMOTE_STREAM), void a.b.subscribe(E.joinInfo.sid, {
          lts: s,
          succ: !1,
          video: e.subscribeOptions && e.subscribeOptions.video,
          audio: e.subscribeOptions && e.subscribeOptions.audio,
          peerid: e.getId(),
          ec: A.INVALID_REMOTE_STREAM
        });
        if (E.state !== I && (r.default.error("[".concat(E.clientId, "] User is not in the session")), !l)) return l = !0, a.b.subscribe(E.joinInfo.sid, {
          lts: s,
          succ: !1,
          video: e.subscribeOptions && e.subscribeOptions.video,
          audio: e.subscribeOptions && e.subscribeOptions.audio,
          peerid: e.getId(),
          ec: A.INVALID_OPERATION
        }), n && n(A.INVALID_OPERATION);
        if (!e.local && E.remoteStreams.hasOwnProperty(e.getId())) {
          if (e.hasAudio() || e.hasVideo() || e.hasScreen()) {
            var p = E.generateP2PId();
            E.p2ps.set(p, e), e.p2pId = p, e.pc = W({
              callback: function callback(t) {
                r.default.debug("[".concat(E.clientId, "] SDP exchange in subscribe : send offer --  "), JSON.parse(t));
                var i,
                    c = S()({
                  streamId: e.getId(),
                  video: !0,
                  audio: !0,
                  mode: E.mode,
                  codec: E.codec,
                  p2pid: p,
                  turnip: E.joinInfo.turnServer.url,
                  turnport: Number(E.joinInfo.turnServer.udpport),
                  turnusername: E.joinInfo.turnServer.username,
                  turnpassword: E.joinInfo.turnServer.credential,
                  tcc: Object(o.getParameter)("SUBSCRIBE_TCC")
                }, e.subscribeOptions);
                N({
                  _type: "subscribe",
                  options: c,
                  sdp: t,
                  p2pid: i
                }, function (t) {
                  if ("error" === t) return r.default.error("[".concat(E.clientId, "] Subscribe remote stream failed, closing stream "), e.getId()), e.close(), n && n(A.SUBSCRIBE_STREAM_FAILED), void a.b.subscribe(E.joinInfo.sid, {
                    lts: s,
                    succ: !1,
                    video: e.subscribeOptions && e.subscribeOptions.video,
                    audio: e.subscribeOptions && e.subscribeOptions.audio,
                    peerid: e.getId(),
                    ec: A.SUBSCRIBE_STREAM_FAILED
                  });
                  r.default.debug("[".concat(E.clientId, "] SDP exchange in subscribe : receive answer --  "), JSON.parse(t)), e.pc.processSignalingMessage(t);
                });
              },
              nop2p: !0,
              audio: !0,
              video: !0,
              screen: e.hasScreen(),
              isSubscriber: !0,
              stunServerUrl: E.stunServerUrl,
              turnServer: E.joinInfo.turnServer,
              isVideoMute: e.userMuteVideo,
              isAudioMute: e.userMuteAudio,
              uid: e.getId(),
              clientId: E.clientId
            }), e.pc.onaddstream = function (t, n) {
              if (e._onAudioUnmute = function () {
                w(i({
                  action: "audio-in-on",
                  streamId: e.getId()
                }), function () {}, function () {});
              }, e._onAudioMute = function () {
                w(i({
                  action: "audio-in-off",
                  streamId: e.getId()
                }), function () {}, function () {});
              }, e._onVideoUnmute = function () {
                w(i({
                  action: "video-in-on",
                  streamId: e.getId()
                }), function () {}, function () {});
              }, e._onVideoMute = function () {
                w(i({
                  action: "video-in-off",
                  streamId: e.getId()
                }), function () {}, function () {});
              }, "ontrack" === n && "video" === t.track.kind || "onaddstream" === n) {
                r.default.info("[".concat(E.clientId, "] Remote stream subscribed with uid "), e.getId());
                var o = E.remoteStreams[e.getId()];

                if (E.remoteStreams[e.getId()].stream = "onaddstream" === n ? t.stream : t.streams[0], E.remoteStreams[e.getId()].hasVideo()) {
                  if (Object(f.isFireFox)() || Object(f.isSafari)()) {
                    var a = E.remoteStreams[e.getId()].stream;
                    Object(G.h)(a, function (t, n) {
                      e.videoWidth = t, e.videoHeight = n;
                    }, function (e) {
                      return r.default.warning("[".concat(E.clientId, "] vsResHack failed: ") + e);
                    });
                  }
                } else {
                  var s = E.remoteStreams[e.getId()];
                  s.peerMuteVideo = !0, E._adjustPCMuteStatus(s);
                }

                o && o.isPlaying() && o.elementID && (r.default.debug("[".concat(E.clientId, "] Reload Player ").concat(o.elementID, " StreamId ").concat(o.getId())), e.audioOutput = o.audioOutput, o.stop(), e.play(o.elementID, o.playOptions)), delete e.audioLevelHelper;
                var c = d({
                  type: "stream-subscribed",
                  stream: E.remoteStreams[e.getId()]
                });
                E.dispatchEvent(c);
              }
            }, E.timers[e.getId()] = setInterval(function () {
              var t = 0;
              e && e.pc && e.pc.getStats && e.pc.getStatsRate(function (n) {
                n.forEach(function (n) {
                  if (n && n.id) {
                    if (/_send$/.test(n.id) || /^time$/.test(n.id) || /^bweforvideo$/.test(n.id)) return;
                    -1 === n.id.indexOf("inbound_rtp") && -1 === n.id.indexOf("inbound-rtp") || "video" !== n.mediaType || (n.googFrameWidthReceived = e.videoWidth + "", n.googFrameHeightReceived = e.videoHeight + "");
                    var i = 200 * t;
                    t++;
                    var o = e.getId();
                    setTimeout(function () {
                      var e, t, i;
                      N((e = o, t = n, i = {}, Object.keys(t).forEach(function (e) {
                        i[Be(e)] = t[e];
                      }), {
                        _type: "subscribe_stats",
                        options: {
                          id: e,
                          stats: i
                        },
                        sdp: null
                      }), null, null);
                    }, i);
                  } else ;
                });
              });
            }, 3e3), E.timers[e.getId() + "_RelatedStats"] = setInterval(function () {
              e && e.pc && (e.pc.getVideoRelatedStats && e.pc.getVideoRelatedStats(function (e) {
                w(c(e), null, null);
              }), e.pc.getAudioRelatedStats && e.pc.getAudioRelatedStats(function (e) {
                w(c(e), null, null);
              }));
            }, 1e3), E.audioLevel[e.getId()] = 0, E.timers[e.getId() + "audio"] = setInterval(function () {
              E.hasListeners("active-speaker") && e && e.pc && "established" === e.pc.state && e.pc.getStats && e.pc.getStats(function (t) {
                t.forEach(function (t) {
                  if ("audio" === t.mediaType) {
                    if (t.audioOutputLevel > 5e3) for (var n in E.audioLevel[e.getId()] < 20 && (E.audioLevel[e.getId()] += 1), E.audioLevel) {
                      n !== "" + e.getId() && E.audioLevel[n] > 0 && (E.audioLevel[n] -= 1);
                    }
                    var i = Object.keys(E.audioLevel).sort(function (e, t) {
                      return E.audioLevel[t] - E.audioLevel[e];
                    });

                    if (E.activeSpeaker !== i[0]) {
                      var o = u({
                        type: "active-speaker",
                        uid: i[0]
                      });
                      E.dispatchEvent(o), E.activeSpeaker = i[0], r.default.debug("[".concat(E.clientId, "] Update active speaker: ").concat(E.activeSpeaker));
                    }
                  }
                });
              }, 50);
            }, 50), e.pc.oniceconnectionstatechange = function (i) {
              if ("failed" === i) null != E.timers[e.getId()] && (clearInterval(E.timers[e.getId()]), clearInterval(E.timers[e.getId()] + "audio")), r.default.error("[".concat(E.clientId, "] Subscriber connection is lost -- streamId: ").concat(e.getId(), ", p2pId: ").concat(p)), r.default.debug("[".concat(E.clientId, "] subscribe p2p failed: "), E.p2ps), l || (l = !0, n && n(A.PEERCONNECTION_FAILED), a.b.subscribe(E.joinInfo.sid, {
                lts: s,
                succ: !1,
                video: e.subscribeOptions && e.subscribeOptions.video,
                audio: e.subscribeOptions && e.subscribeOptions.audio,
                peerid: e.getId(),
                ec: A.PEERCONNECTION_FAILED
              })), E.remoteStreams[e.getId()] && E.p2ps.has(p) && (E.p2ps.delete(p), E.dispatchEvent(u({
                type: "subP2PLost",
                stream: e
              })));else if ("connected" === i && (r.default.debug("[".concat(E.clientId, "] subscribe p2p connected: "), E.p2ps), !l)) {
                l = !0, a.b.subscribe(E.joinInfo.sid, {
                  lts: s,
                  succ: !0,
                  video: e.subscribeOptions && e.subscribeOptions.video,
                  audio: e.subscribeOptions && e.subscribeOptions.audio,
                  peerid: e.getId(),
                  ec: null
                }), E._adjustPCMuteStatus(e);
                var o = !1,
                    c = setInterval(function () {
                  e.pc ? e.pc.getStats(function (t) {
                    t.forEach(function (t) {
                      -1 !== t.id.indexOf("recv") && "audio" === t.mediaType && parseInt(t.googDecodingNormal) > 0 && (o || (o = !0, E.dispatchEvent({
                        type: "first-audio-frame-decode",
                        stream: e
                      }), clearInterval(c), a.b.reportApiInvoke(E.joinInfo.sid, {
                        name: "firstAudioDecode"
                      })(null, {
                        elapse: Date.now() - e.subscribeLTS
                      })));
                    });
                  }, 100) : clearInterval(c);
                }, 100),
                    d = !1,
                    f = setInterval(function () {
                  e.pc ? e.pc.getStats(function (t) {
                    t.forEach(function (t) {
                      -1 === t.id.indexOf("recv") && -1 === t.id.indexOf("inbound_rtp") && -1 === t.id.indexOf("inbound-rtp") && -1 === t.id.indexOf("InboundRTP") || "video" === t.mediaType && (t.framesDecoded > 0 || t.googFramesDecoded > 0) && (d || (d = !0, E.dispatchEvent({
                        type: "first-video-frame-decode",
                        stream: e
                      }), clearInterval(f), e.firstFrameTime = new Date().getTime() - e.subscribeLTS, a.b.firstRemoteFrame(E.joinInfo.sid, {
                        lts: new Date().getTime(),
                        peerid: e.getId(),
                        succ: !0,
                        width: +t.googFrameWidthReceived,
                        height: +t.googFrameHeightReceived
                      })));
                    });
                  }, 100) : clearInterval(f);
                }, 100);
                return e.sid = E.joinInfo.sid, t && t();
              }
            };
          } else r.default.error("[".concat(E.clientId, "] Invalid remote stream")), l || (l = !0, n && n(A.INVALID_REMOTE_STREAM), a.b.subscribe(E.joinInfo.sid, {
            lts: s,
            succ: !1,
            video: e.subscribeOptions && e.subscribeOptions.video,
            audio: e.subscribeOptions && e.subscribeOptions.audio,
            peerid: e.getId(),
            ec: A.INVALID_REMOTE_STREAM
          }));
        } else r.default.error("[".concat(E.clientId, "] No such remote stream")), l || (l = !0, n && n(A.NO_SUCH_REMOTE_STREAM), a.b.subscribe(E.joinInfo.sid, {
          lts: s,
          succ: !1,
          video: e.subscribeOptions && e.subscribeOptions.video,
          audio: e.subscribeOptions && e.subscribeOptions.audio,
          peerid: e.getId(),
          ec: A.NO_SUCH_REMOTE_STREAM
        }));
      }, E.subscribeChange = function (e, t, n) {
        var i,
            o,
            s = Date.now();
        r.default.info("[".concat(E.clientId, "] Gatewayclient ").concat(E.uid, " SubscribeChange ").concat(e.getId(), ": ").concat(JSON.stringify(e.subscribeOptions))), E._adjustPCMuteStatus(e), w((i = e.getId(), o = e.subscribeOptions, {
          _type: "subscribe_change",
          options: S()({
            streamId: i
          }, o)
        }), function (i) {
          if ("error" === i) return r.default.error("[".concat(E.clientId, "] Subscribe Change Failed ").concat(e.getId())), void b(n, "SUBSCRIBE_CHANGE_FAILED");
          var o = d({
            type: "stream-subscribe-changed",
            stream: E.remoteStreams[e.getId()]
          });
          a.b.subscribe(E.joinInfo.sid, {
            lts: s,
            succ: !0,
            video: e.subscribeOptions && e.subscribeOptions.video,
            audio: e.subscribeOptions && e.subscribeOptions.audio,
            peerid: e.getId(),
            ec: null
          }), E.dispatchEvent(o), t && t();
        }, n);
      }, E._adjustPCMuteStatus = function (e) {
        !e.local && e.pc && e.pc.peerConnection.getReceivers && e.pc.peerConnection.getReceivers().forEach(function (t) {
          if (t && t.track && "audio" === t.track.kind) {
            var n = !e.userMuteAudio && !e.peerMuteAudio;
            e.subscribeOptions && !e.subscribeOptions.audio && (n = !1), t.track.enabled = !!n;
          } else if (t && t.track && "video" === t.track.kind) {
            var i = !e.userMuteVideo && !e.peerMuteVideo;
            e.subscribeOptions && !e.subscribeOptions.video && (i = !1), t.track.enabled = !!i;
          }
        });
      }, E.unsubscribe = function (e, t, n) {
        if ("object" !== q()(e) || null === e) return r.default.error("[".concat(E.clientId, "] Invalid remote stream")), void b(n, A.INVALID_REMOTE_STREAM);
        if (E.state !== I) return r.default.error("[".concat(E.clientId, "] User is not in the session")), void b(n, A.INVALID_OPERATION);

        if (null != E.timers[e.getId()] && (clearInterval(E.timers[e.getId()]), clearInterval(E.timers[e.getId()] + "audio")), null != E.audioLevel[e.getId()] && delete E.audioLevel[e.getId()], null != E.timer_counter[e.getId()] && delete E.timer_counter[e.getId()], E.remoteStreams.hasOwnProperty(e.getId())) {
          if (!E.socket) return r.default.error("[".concat(E.clientId, "] User is not in the session")), void b(n, A.INVALID_OPERATION);
          if (e.local) return r.default.error("[".concat(E.clientId, "] Invalid remote stream")), void b(n, A.INVALID_REMOTE_STREAM);
          e.close(), w({
            _type: "unsubscribe",
            message: e.getId()
          }, function (i) {
            if ("error" === i) return r.default.error("[".concat(E.clientId, "] Unsubscribe remote stream failed ").concat(e.getId())), void b(n, A.UNSUBSCRIBE_STREAM_FAILED);
            void 0 !== e.pc && (e.pc.close(), e.pc = void 0), e.onClose = void 0, e._onAudioMute = void 0, e._onAudioUnute = void 0, e._onVideoMute = void 0, e._onVideoUnmute = void 0, delete e.subscribeOptions, E.p2ps.delete(e.p2pId), r.default.info("[".concat(E.clientId, "] Unsubscribe stream success")), t && t();
          }, n);
        } else b(n, A.NO_SUCH_REMOTE_STREAM);
      }, E.setRemoteVideoStreamType = function (e, t) {
        if (r.default.debug("[".concat(E.clientId, "] Switching remote video stream ").concat(e.getId(), " to ").concat(t)), "object" === q()(e) && null !== e) {
          if (E.state === I) {
            if (!e.local) {
              switch (t) {
                case E.remoteVideoStreamTypes.REMOTE_VIDEO_STREAM_HIGH:
                case E.remoteVideoStreamTypes.REMOTE_VIDEO_STREAM_LOW:
                case E.remoteVideoStreamTypes.REMOTE_VIDEO_STREAM_MEDIUM:
                  break;

                default:
                  return;
              }

              w(function (e, t) {
                return {
                  _type: "switchVideoStream",
                  message: {
                    id: e,
                    type: t
                  }
                };
              }(e.getId(), t), null, null);
            }
          } else r.default.error("[".concat(E.clientId, "] User is not in the session"));
        } else r.default.error("[".concat(E.clientId, "] Invalid remote stream"));
      }, E.renewToken = function (e, t, n) {
        e ? E.key ? E.state !== I ? (r.default.debug("[".concat(E.clientId, "] Client is not connected. Trying to rejoin")), E.key = e, E.rejoin(), t && t()) : (r.default.debug("[".concat(E.clientId, "] renewToken from ").concat(E.key, " to ").concat(e)), w(function (e) {
          return {
            _type: "renew_token",
            message: {
              token: e
            }
          };
        }(e), t, n)) : (r.default.error("[".concat(E.clientId, "] Client is previously joined without token")), n && n(A.INVALID_PARAMETER)) : (r.default.error("[".concat(E.clientId, "] Invalid Token ").concat(e)), n && n(A.INVALID_PARAMETER));
      }, E.setStreamFallbackOption = function (e, t) {
        if (r.default.debug("[".concat(E.clientId, "] Set stream fallback option ").concat(e.getId(), " to ").concat(t)), "object" === q()(e) && null !== e) {
          if (E.state === I) {
            if (!e.local) {
              switch (t) {
                case E.streamFallbackTypes.STREAM_FALLBACK_OPTION_DISABLED:
                case E.streamFallbackTypes.STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW:
                case E.streamFallbackTypes.STREAM_FALLBACK_OPTION_AUDIO_ONLY:
                  break;

                default:
                  return;
              }

              w(function (e, t) {
                return {
                  _type: "setFallbackOption",
                  message: {
                    id: e,
                    type: t
                  }
                };
              }(e.getId(), t), null, null);
            }
          } else r.default.error("[".concat(E.clientId, "] User is not in the session"));
        } else r.default.error("[".concat(E.clientId, "] Invalid remote stream"));
      }, E.startLiveStreaming = function (e, t) {
        E.liveStreams.set(e, t), r.default.debug("[".concat(E.clientId, "] Start live streaming ").concat(e, " ").concat(t, " ").concat(t)), E.state === I ? w(function (e, t) {
          return {
            _type: "start_live_streaming",
            message: {
              url: e,
              transcodingEnabled: t
            }
          };
        }(e, t), null, null) : r.default.error("[".concat(E.clientId, "] User is not in the session"));
      }, E.stopLiveStreaming = function (e) {
        r.default.debug("[".concat(E.clientId, "] Stop live streaming ").concat(e)), E.state === I ? (E.liveStreams.delete(e), w(function (e) {
          return {
            _type: "stop_live_streaming",
            message: {
              url: e
            }
          };
        }(e), null, null)) : r.default.error("[".concat(E.clientId, "] User is not in the session"));
      }, E.setLiveTranscoding = function (e) {
        Object(G.d)(e) && (E.transcoding = e, r.default.debug("[".concat(E.clientId, "] Set live transcoding "), e), E.state === I ? w(function (e) {
          return {
            _type: "set_live_transcoding",
            message: {
              transcoding: e
            }
          };
        }(e), null, null) : r.default.error("[".concat(E.clientId, "] User is not in the session")));
      }, E.addInjectStreamUrl = function (e, t) {
        E.injectLiveStreams.set(e, t), r.default.debug("[".concat(E.clientId, "] Add inject stream url ").concat(e, " config "), t), E.state === I ? w(function (e, t) {
          return {
            _type: "add_inject_stream_url",
            message: {
              url: e,
              config: t
            }
          };
        }(e, t), null, null) : r.default.error("[".concat(E.clientId, "] User is not in the session"));
      }, E.removeInjectStreamUrl = function (e) {
        r.default.debug("[".concat(E.clientId, "] Remove inject stream url ").concat(e)), E.state === I ? (E.injectLiveStreams.delete(e), w(function (e) {
          return {
            _type: "remove_inject_stream_url",
            message: {
              url: e
            }
          };
        }(e), null, null)) : r.default.error("[".concat(E.clientId, "] User is not in the session"));
      }, E.enableAudioVolumeIndicator = function (e, t) {
        E.audioVolumeIndication.enabled = !0, E.audioVolumeIndication.interval = e, E.audioVolumeIndication.smooth = t, E.resetAudioVolumeIndication();
      }, E.resetAudioVolumeIndication = function () {
        if (clearInterval(E.timers.audioVolumeIndication), clearInterval(E.timers.audioVolumeSampling), E.audioVolumeIndication.enabled && E.audioVolumeIndication.interval) {
          var e = Math.floor(1e3 * E.audioVolumeIndication.smooth / 100);
          E.timers.audioVolumeSampling = setInterval(function () {
            E.audioVolumeSampling || (E.audioVolumeSampling = {});
            var t = {};

            for (var n in E.remoteStreams) {
              var i = E.remoteStreams[n];

              if (i.stream && i.hasAudio()) {
                var o = i.getAudioLevel();
                o > 0 && o < 1 && (o *= 100);
                var r = E.audioVolumeSampling[n] || [];

                for (r.push(o); r.length > e;) {
                  r.shift();
                }

                t[n] = r;
              }
            }

            E.audioVolumeSampling = t;
          }, 100), E.timers.audioVolumeIndication = setInterval(function () {
            var e = [];

            for (var t in E.remoteStreams) {
              if (E.audioVolumeSampling && E.audioVolumeSampling[t]) {
                var n = E.audioVolumeSampling[t],
                    i = 0;
                n.forEach(function (e) {
                  i += e;
                });
                var o = {
                  uid: t,
                  level: Math.floor(i / n.length)
                };
                o.level && e.push(o);
              }
            }

            var a = e.sort(function (e, t) {
              return e.level - t.level;
            });
            r.default.debug("[".concat(E.clientId, "] volume-indicator "), JSON.stringify(a)), E.audioVolumeIndication.sortedAudioVolumes = a;
            var s = u({
              type: "volume-indicator",
              attr: a
            });
            E.dispatchEvent(s);
          }, E.audioVolumeIndication.interval);
        }
      }, E.closeGateway = function () {
        r.default.debug("[".concat(E.clientId, "] close gateway")), E.state = g, E.socket.close(), R();
      };

      var R = function R() {
        for (var e in E.timers) {
          E.timers.hasOwnProperty(e) && clearInterval(E.timers[e]);
        }

        for (var e in E.remoteStreams) {
          if (E.remoteStreams.hasOwnProperty(e)) {
            var t = E.remoteStreams[e],
                n = u({
              type: "stream-removed",
              uid: t.getId(),
              stream: t
            });
            E.dispatchEvent(n);
          }
        }

        E.p2ps.clear(), k(), D(), clearInterval(E.pingTimer);
      };

      E.rejoin = function () {
        E.socket && (clearInterval(E.pingTimer), E.socket.close(), E.socket = void 0), E.state = v, C();
      };

      var C = function C(e, t) {
        E.dispatchEvent(u({
          type: "rejoin-start"
        })), e = e || function (e) {
          r.default.info("[".concat(E.clientId, "] User ").concat(e, " is re-joined to ").concat(E.joinInfo.cname)), E.dispatchEvent(u({
            type: "rejoin"
          })), E.liveStreams && E.liveStreams.size && E.liveStreams.forEach(function (e, t) {
            e && E.setLiveTranscoding(E.transcoding), E.startLiveStreaming(t, e);
          }), E.injectLiveStreams && E.injectLiveStreams.size && E.injectLiveStreams.forEach(function (e, t) {
            E.addInjectStreamUrl(t, e);
          });
        }, t = t || function (e) {
          r.default.error("[".concat(E.clientId, "] Re-join to channel failed "), e), E.dispatchEvent(d({
            type: "error",
            reason: e
          }));
        }, E.key ? (++E.rejoinAttempt, E.join(E.joinInfo, E.key, e, t)) : r.default.error("[".concat(E.clientId, "] Connection recover failed [Invalid channel key]"));
      },
          O = function O(e, t, i) {
        var o;
        E.onConnect = t, E.socket ? (E.dispatchEvent({
          type: "reconnect"
        }), "retry" === E.reconnectMode ? (r.default.debug("[".concat(E.clientId, "] Retry current gateway")), E.socket.reconnect()) : "tryNext" === E.reconnectMode ? (r.default.debug("[".concat(E.clientId, "] Try next gateway")), E.socket.connectNext()) : "recover" === E.reconnectMode && (r.default.debug("[".concat(E.clientId, "] Recover gateway")), r.default.debug("[".concat(E.clientId, "] Try to reconnect choose server and get gateway list again ")), ke(E.joinInfo, function (e) {
          E.socket.replaceHost(e.gateway_addr);
        }))) : (o = e.gatewayAddr, E.socket = ye(o, {
          sid: E.joinInfo.sid,
          clientId: E.clientId
        }), E.socket.on("onUplinkStats", function (e) {
          E.OutgoingAvailableBandwidth = e.uplink_available_bandwidth, E.localStreams[E.uid] && (E.localStreams[E.uid].uplinkStats = e);
        }), E.socket.on("connect", function () {
          E.dispatchEvent({
            type: "connected"
          }), E.attemps = 1, w(function (e) {
            var t = e;
            return e.uni_lbs_ip && (t = S()(e, {
              wanip: e.uni_lbs_ip,
              hasChange: E.hasChangeBGPAddress
            })), {
              _type: "token",
              message: t
            };
          }(e), E.onConnect, i);
        }), E.socket.on("recover", function () {
          E.state = v, r.default.debug("[".concat(E.clientId, "] Try to reconnect choose server and get gateway list again ")), ke(E.joinInfo, function (e) {
            E.socket.replaceHost(e.gateway_addr);
          });
        }), E.socket.on("disconnect", function (e) {
          if (E.state !== g) {
            E.state = g;
            var t = d({
              type: "error",
              reason: A.SOCKET_DISCONNECTED
            });

            if (E.dispatchEvent(t), 0 === E.p2ps.size ? E.reconnectMode = "tryNext" : E.reconnectMode = "retry", R(), 1 != n) {
              var i,
                  o = (i = E.attemps, 1e3 * Math.min(30, Math.pow(2, i) - 1));
              r.default.error("[".concat(E.clientId, "] Disconnect from server [").concat(JSON.stringify(e), "], attempt to recover [#").concat(E.attemps, "] after ").concat(o / 1e3, " seconds"));
              setTimeout(function () {
                E.attemps++, E.state = v, C();
              }, o);
            }
          }
        }), E.socket.on("onAddAudioStream", function (e) {
          if (r.default.info("[".concat(E.clientId, "] Newly added audio stream with uid ").concat(e.id)), E.joinInfo.stringUid && "string" != typeof e.id && r.default.error("StringUID is Mixed with UintUID"), E.remoteStreamsInChannel.has(e.id) || E.remoteStreamsInChannel.add(e.id), void 0 === E.remoteStreams[e.id]) {
            var t = pe({
              streamID: e.id,
              local: !1,
              audio: e.audio,
              video: e.video,
              screen: e.screen,
              attributes: e.attributes
            });
            t.peerMuteVideo = !0, E.remoteStreams[e.id] = t;
            var n = d({
              type: "stream-added",
              stream: t
            });
            E.dispatchEvent(n);
          }
        }), E.socket.on("onUpdateStream", function (e) {
          var t = E.remoteStreams[e.id];

          if (E.joinInfo.stringUid && "string" != typeof e.id && r.default.error("StringUID is Mixed with UintUID"), t) {
            delete e.id, t.audio = e.audio, t.video = e.video, t.screen = e.screen, t.pc && E._adjustPCMuteStatus(t);
            var n = d({
              type: "stream-updated",
              stream: t
            });
            E.dispatchEvent(n);
          } else r.default.debug("[".concat(E.clientId, "] Ignoring onUpdateStream event before onAddStream for uid ").concat(e.id));
        }), E.socket.on("onAddVideoStream", function (e) {
          if (r.default.info("[".concat(E.clientId, "] Newly added remote stream with uid ").concat(e.id, ".")), E.joinInfo.stringUid && "string" != typeof e.id && r.default.error("StringUID is Mixed with UintUID"), E.remoteStreamsInChannel.has(e.id) || E.remoteStreamsInChannel.add(e.id), void 0 === E.remoteStreams[e.id]) {
            var t = pe({
              streamID: e.id,
              local: !1,
              audio: e.audio,
              video: e.video,
              screen: e.screen,
              attributes: e.attributes
            });
            E.remoteStreams[e.id] = t;
            var n = d({
              type: "stream-added",
              stream: t
            });
            E.dispatchEvent(n);
          } else {
            var i = E.remoteStreams[e.id];

            if (i.peerMuteVideo = !1, i.video = !0, void 0 !== i.stream) {
              if ((t = E.remoteStreams[e.id]).pc && E._adjustPCMuteStatus(t), r.default.info("[".concat(E.clientId, "] Stream changed: enable video ").concat(e.id)), t.isPlaying()) {
                var o = t.player.elementID;
                t.stop(), t.play(o, t.playOptions);
              }
            } else if (i.p2pId) E.remoteStreams[e.id].video = !0;else {
              t = pe({
                streamID: e.id,
                local: !1,
                audio: !0,
                video: !0,
                screen: !1,
                attributes: e.attributes
              });
              E.remoteStreams[e.id] = t, r.default.info("[".concat(E.clientId, "] Stream changed: modify video ").concat(e.id));
            }
          }
        }), E.socket.on("onRemoveStream", function (e) {
          E.remoteStreamsInChannel.has(e.id) && E.remoteStreamsInChannel.delete(e.id);
          var t = E.remoteStreams[e.id];

          if (t) {
            delete E.remoteStreams[e.id];
            var n = d({
              type: "stream-removed",
              stream: t
            });
            E.dispatchEvent(n), t.close(), void 0 !== t.pc && (t.pc.close(), t.pc = void 0, E.p2ps.delete(t.p2pId));
          } else console.log("ERROR stream ", e.id, " not found onRemoveStream ", e);
        }), E.socket.on("onPublishStream", function (e) {
          var t = E.localStreams[e.id],
              n = d({
            type: "streamPublished",
            stream: t
          });
          E.dispatchEvent(n);
        }), E.socket.on("mute_audio", function (e) {
          r.default.info("[".concat(E.clientId, "] rcv peer mute audio: ").concat(e.peerid));
          var t = u({
            type: "mute-audio",
            uid: e.peerid
          }),
              n = E.remoteStreams[e.peerid];
          n ? (n.peerMuteAudio = !0, n.pc && E._adjustPCMuteStatus(n)) : r.default.debug("Ignoring event ".concat(e.type), e), E.dispatchEvent(t);
        }), E.socket.on("unmute_audio", function (e) {
          r.default.info("[".concat(E.clientId, "] rcv peer unmute audio: ").concat(e.peerid));
          var t = u({
            type: "unmute-audio",
            uid: e.peerid
          }),
              n = E.remoteStreams[e.peerid];
          n ? (n.peerMuteAudio = !1, n.pc && E._adjustPCMuteStatus(n)) : r.default.debug("Ignoring event ".concat(e.type), e), E.dispatchEvent(t);
        }), E.socket.on("mute_video", function (e) {
          r.default.info("[".concat(E.clientId, "] rcv peer mute video: ").concat(e.peerid));
          var t = u({
            type: "mute-video",
            uid: e.peerid
          }),
              n = E.remoteStreams[e.peerid];
          n ? (n.peerMuteVideo = !0, n.pc && E._adjustPCMuteStatus(n)) : r.default.debug("Ignoring event ".concat(e.type), e), E.dispatchEvent(t);
        }), E.socket.on("unmute_video", function (e) {
          r.default.info("[".concat(E.clientId, "] rcv peer unmute video: ").concat(e.peerid));
          var t = u({
            type: "unmute-video",
            uid: e.peerid
          }),
              n = E.remoteStreams[e.peerid];
          n ? (n.peerMuteVideo = !1, n.pc && E._adjustPCMuteStatus(n)) : r.default.debug("Ignoring event ".concat(e.type), e), E.dispatchEvent(t);
        }), E.socket.on("user_banned", function (e) {
          r.default.info("[".concat(E.clientId, "] user banned uid: ").concat(e.id, " error: ").concat(e.errcode));
          var t = u({
            type: "client-banned",
            uid: e.id,
            attr: e.errcode
          });
          E.dispatchEvent(t), n = !0;
        }), E.socket.on("stream_fallback", function (e) {
          r.default.info("[".concat(E.clientId, "] stream fallback uid: ").concat(e.id, " peerId: ").concat(e.peerid, " type: ").concat(e.type));
          var t = u({
            type: "stream-fallback",
            uid: e.id,
            stream: e.peerid,
            attr: e.type
          });
          E.dispatchEvent(t);
        }), E.socket.on("stream_recover", function (e) {
          r.default.info("[".concat(E.clientId, "] stream recover uid: ").concat(e.id, " peerId: ").concat(e.peerid, " type: ").concat(e.type));
          var t = u({
            type: "stream-recover",
            uid: e.id,
            stream: e.peerid,
            attr: e.type
          });
          E.dispatchEvent(t);
        }), E.socket.on("onP2PLost", function (e) {
          r.default.debug("[".concat(E.clientId, "] p2plost: "), e, "p2ps:", E.p2ps);
          var t,
              n = "DTLS failed";
          (t = E.localStreams[e.uid] || E.remoteStreams[e.uid]) ? (t.pc && t.pc.offerCandidates && 0 === t.pc.offerCandidates.length && (n = "NO_CANDIDATES_IN_OFFER"), "publish" === e.event && a.b.publish(E.joinInfo.sid, {
            lts: t.publishLTS,
            succ: !1,
            audioName: t.hasAudio() && t.audioName,
            videoName: t.hasVideo() && t.videoName,
            screenName: t.hasScreen() && t.screenName,
            ec: n
          }), "subscribe" === e.event && a.b.subscribe(E.joinInfo.sid, {
            lts: t.subscribeLTS,
            succ: !1,
            video: t.subscribeOptions && t.subscribeOptions.video,
            audio: t.subscribeOptions && t.subscribeOptions.audio,
            peerid: e.uid + "",
            ec: n
          })) : r.default.warning("P2PLost Stream Not found", e), r.default.debug("[".concat(E.clientId, "] p2plost:"), e.p2pid), (t = E.p2ps.get(e.p2pid)) && (E.p2ps.delete(e.p2pid), t.local ? E.dispatchEvent(u({
            type: "pubP2PLost",
            stream: t,
            attr: n
          })) : E.remoteStreams[t.getId()] && E.dispatchEvent(u({
            type: "subP2PLost",
            stream: t,
            attr: n
          })));
        }), E.socket.on("onTokenPrivilegeWillExpire", function (e) {
          r.default.debug("[".concat(E.clientId, "] Received Message onTokenPrivilegeWillExpire")), E.dispatchEvent(u({
            type: "onTokenPrivilegeWillExpire"
          }));
        }), E.socket.on("onTokenPrivilegeDidExpire", function () {
          r.default.warning("[".concat(E.clientId, "] Received Message onTokenPrivilegeDidExpire, please get new token and join again")), E.closeGateway(), E.dispatchEvent(u({
            type: "onTokenPrivilegeDidExpire"
          }));
        }), E._doWithAction = function (e, t, n) {
          "tryNext" === e ? function (e, t) {
            r.default.debug("[".concat(E.clientId, "] Connect next gateway")), E.state = g, E.socket.close(), R(), E.reconnectMode = "tryNext", C(e, t);
          }(t, n) : "retry" === e ? function (e, t) {
            r.default.debug("[".concat(E.clientId, "] Reconnect gateway")), E.state = g, E.socket.close(), R(), E.reconnectMode = "retry", C(e, t);
          }(t, n) : "quit" === e ? (r.default.debug("[".concat(E.clientId, "] quit gateway")), E.state = g, E.socket.close(), R()) : "recover" === e && (r.default.debug("[".concat(E.clientId, "] Reconnect gateway")), E.state = g, E.socket.close(), R(), E.reconnectMode = "recover", C());
        }, E.socket.on("notification", function (e) {
          if (r.default.debug("[".concat(E.clientId, "] Receive notification: "), e), "ERR_JOIN_BY_MULTI_IP" === _[e.code]) return E.dispatchEvent({
            type: "onMultiIP",
            arg: e
          });
          e.detail ? E._doWithAction(Pe[_[e.code]]) : e.action && E._doWithAction(e.action);
        }), E.socket.on("onPeerLeave", function (e) {
          var t = u({
            type: "peer-leave",
            uid: e.id
          });

          if (E.remoteStreamsInChannel.has(e.id) && E.remoteStreamsInChannel.delete(e.id), E.remoteStreams.hasOwnProperty(e.id) && (t.stream = E.remoteStreams[e.id]), E.dispatchEvent(t), E.remoteStreams.hasOwnProperty(e.id)) {
            r.default.info("[".concat(E.clientId, "] closing stream on peer leave"), e.id);
            var n = E.remoteStreams[e.id];
            n.close(), delete E.remoteStreams[e.id], void 0 !== n.pc && (n.pc.close(), n.pc = void 0, E.p2ps.delete(n.p2pId));
          }

          E.timers.hasOwnProperty(e.id) && (clearInterval(E.timers[e.id]), clearInterval(E.timers[e.id] + "_RelatedStats"), delete E.timers[e.id]), null != E.audioLevel[e.id] && delete E.audioLevel[e.id], null != E.timer_counter[e.id] && delete E.timer_counter[e.id];
        }), E.socket.on("onUplinkStats", function (e) {}), E.socket.on("liveStreamingStarted", function (e) {
          var t = p({
            type: "liveStreamingStarted",
            url: e.url
          });
          E.dispatchEvent(t);
        }), E.socket.on("liveStreamingFailed", function (e) {
          var t = p({
            type: "liveStreamingFailed",
            url: e.url
          });
          E.dispatchEvent(t);
        }), E.socket.on("liveStreamingStopped", function (e) {
          var t = p({
            type: "liveStreamingStopped",
            url: e.url
          });
          E.dispatchEvent(t);
        }), E.socket.on("liveTranscodingUpdated", function (e) {
          var t = p({
            type: "liveTranscodingUpdated",
            reason: e.reason
          });
          E.dispatchEvent(t);
        }), E.socket.on("streamInjectedStatus", function (e) {
          var t = p({
            type: "streamInjectedStatus",
            url: e.url,
            uid: e.uid,
            status: e.status
          });
          E.dispatchEvent(t);
        }), E.socket.on("onUserOnline", function (e) {
          E.joinInfo.stringUid && "string" != typeof e.id && r.default.error("StringUID is Mixed with UintUID"), E.dispatchEvent({
            type: "peer-online",
            uid: e.id
          });
        }));
      },
          w = function w(e, t, n) {
        if (void 0 === E.socket) return r.default.error("[".concat(E.clientId, "] No socket available")), void b(n, A.INVALID_OPERATION);

        try {
          E.socket.emitSimpleMessage(e, function (e, i) {
            "success" === e ? "function" == typeof t && t(i) : "function" == typeof n && n(_[i] || i);
          });
        } catch (t) {
          r.default.error("[".concat(E.clientId, "] Socket emit message failed ").concat(JSON.stringify(e))), r.default.error("[".concat(E.clientId, "] "), t), b(n, A.SOCKET_ERROR);
        }
      },
          N = function N(e, t) {
        if (void 0 !== E.socket) try {
          E.socket.emitSimpleMessage(e, function (e, n) {
            t && t(e, n);
          });
        } catch (e) {
          r.default.error("[".concat(E.clientId, "] Error in sendSimpleSdp [").concat(e, "]"));
        } else r.default.error("[".concat(E.clientId, "] Error in sendSimpleSdp [socket not ready]"));
      },
          D = function D() {
        for (var e in E.localStreams) {
          if (void 0 !== E.localStreams[e]) {
            var t = E.localStreams[e];
            delete E.localStreams[e], void 0 !== t.pc && (t.pc.close(), t.pc = void 0);
          }
        }
      },
          k = function k() {
        for (var e in E.remoteStreamsInChannel.clear(), E.remoteStreams) {
          if (E.remoteStreams.hasOwnProperty(e)) {
            var t = E.remoteStreams[e];
            t.isPlaying() && t.stop(), t.close(), delete E.remoteStreams[e], void 0 !== t.pc && (t.pc.close(), t.pc = void 0);
          }
        }
      };

      return E;
    },
        We = {
      _gatewayClients: {},
      register: function register(e, t) {
        if (!t.uid) {
          var n = "NO_UID_PROVIDED";
          return r.default.error("[".concat(e.clientId, "] "), n, t), n;
        }

        if (t.cname) {
          if (this._gatewayClients[t.cname] && this._gatewayClients[t.cname][t.uid] && this._gatewayClients[t.cname][t.uid] !== e) {
            n = "UID_CONFLICT";
            return r.default.error("[".concat(e.clientId, "] "), n, t), n;
          }

          return r.default.debug("[".concat(e.clientId, "] register client Channel"), t.cname, "Uid", t.uid), this._gatewayClients[t.cname] || (this._gatewayClients[t.cname] = {}), this._gatewayClients[t.cname][t.uid] = e, null;
        }

        var n = "NO_CHANNEL_PROVIDED";
        return r.default.error("[".concat(e.clientId, "] "), n, t), n;
      },
      unregister: function unregister(e) {
        var t = e && e.uid,
            n = e.joinInfo && e.joinInfo.cname;

        if (!t || !n) {
          var i = "INVALID_GATEWAYCLIENT";
          return r.default.error("[".concat(e.clientId, "] "), i), i;
        }

        if (this._gatewayClients[n] && this._gatewayClients[n][t]) {
          if (this._gatewayClients[n][t] !== e) {
            i = "GATEWAYCLIENT_UID_CONFLICT";
            return r.default.error("[".concat(e.clientId, "] "), i), i;
          }

          return r.default.debug("[".concat(e.clientId, "] unregister client "), e.uid), delete this._gatewayClients[n][t], null;
        }

        var i = "GATEWEAY_CLIENT_UNREGISTERED";
        r.default.error("[".concat(e.clientId, "] "), i);
      }
    };

    je.DISCONNECTED = 0, je.CONNECTING = 1, je.CONNECTED = 2, je.DISCONNECTING = 3, je.connetionStateMap = {
      0: "DISCONNECTED",
      1: "CONNECTING",
      2: "CONNECTED",
      3: "DISCONNECTING"
    };

    var He = je,
        Ge = function Ge(e) {
      var t;

      switch (e) {
        case "120p":
        case "120p_1":
          t = ["120p_1", "120p_1", "120p_1"];
          break;

        case "120p_3":
          t = ["120p_3", "120p_3", "120p_3"];
          break;

        case "180p":
        case "180p_1":
          t = ["90p_1", "90p_1", "180p_1"];
          break;

        case "180p_3":
          t = ["120p_3", "120p_3", "180p_3"];
          break;

        case "180p_4":
          t = ["120p_1", "120p_1", "180p_4"];
          break;

        case "240p":
        case "240p_1":
          t = ["120p_1", "120p_1", "240p_1"];
          break;

        case "240p_3":
          t = ["120p_3", "120p_3", "240p_3"];
          break;

        case "240p_4":
          t = ["120p_4", "120p_4", "240p_4"];
          break;

        case "360p":
        case "360p_1":
        case "360p_4":
        case "360p_9":
        case "360p_10":
        case "360p_11":
          t = ["90p_1", "90p_1", "360p_1"];
          break;

        case "360p_3":
        case "360p_6":
          t = ["120p_3", "120p_3", "360p_3"];
          break;

        case "360p_7":
        case "360p_8":
          t = ["120p_1", "120p_1", "360p_7"];
          break;

        case "480p":
        case "480p_1":
        case "480p_2":
        case "480p_4":
        case "480p_10":
          t = ["120p_1", "120p_1", "480p_1"];
          break;

        case "480p_3":
        case "480p_6":
          t = ["120p_3", "120p_3", "480p_3"];
          break;

        case "480p_8":
        case "480p_9":
          t = ["120p_4", "120p_4", "480p_8"];
          break;

        case "720p":
        case "720p_1":
        case "720p_2":
        case "720p_3":
          t = ["90p_1", "90p_1", "720p_1"];
          break;

        case "720p_5":
        case "720p_6":
          t = ["120p_1", "120p_1", "720p_5"];
          break;

        case "1080p":
        case "1080p_1":
        case "1080p_2":
        case "1080p_3":
        case "1080p_5":
          t = ["90p_1", "90p_1", "1080p_1"];
          break;

        case "1440p":
        case "1440p_1":
        case "1440p_2":
          t = ["90p_1", "90p_1", "1440p_1"];
          break;

        case "4k":
        case "4k_1":
        case "4k_3":
          t = ["90p_1", "90p_1", "4k_1"];
          break;

        default:
          t = ["120p_1", "120p_1", "360p_7"];
      }

      return Object(f.isOpera)() ? [e, 15, 50] : Object(f.isFireFox)() ? [t[1], 15, 100] : Object(f.isSafari)() ? [t[2], 15, 50] : [t[0], 15, 50];
    },
        Je = {
      1001: "FRAMERATE_INPUT_TOO_LOW",
      1002: "FRAMERATE_SENT_TOO_LOW",
      1003: "SEND_VIDEO_BITRATE_TOO_LOW",
      1005: "RECV_VIDEO_DECODE_FAILED",
      2001: "AUDIO_INPUT_LEVEL_TOO_LOW",
      2002: "AUDIO_OUTPUT_LEVEL_TOO_LOW",
      2003: "SEND_AUDIO_BITRATE_TOO_LOW",
      2005: "RECV_AUDIO_DECODE_FAILED",
      3001: "FRAMERATE_INPUT_TOO_LOW_RECOVER",
      3002: "FRAMERATE_SENT_TOO_LOW_RECOVER",
      3003: "SEND_VIDEO_BITRATE_TOO_LOW_RECOVER",
      3005: "RECV_VIDEO_DECODE_FAILED_RECOVER",
      4001: "AUDIO_INPUT_LEVEL_TOO_LOW_RECOVER",
      4002: "AUDIO_OUTPUT_LEVEL_TOO_LOW_RECOVER",
      4003: "SEND_AUDIO_BITRATE_TOO_LOW_RECOVER",
      4005: "RECV_AUDIO_DECODE_FAILED_RECOVER"
    },
        Ye = {
      FramerateInput: 1001,
      FramerateSent: 1002,
      SendVideoBitrate: 1003,
      VideoDecode: 1005,
      AudioIntputLevel: 2001,
      AudioOutputLevel: 2002,
      SendAudioBitrate: 2003,
      AudioDecode: 2005
    },
        ze = function ze(e) {
      var t = {
        remoteStreamStorage: {},
        localStreamStorage: {}
      };
      return t.gatewayClient = e, t.checkAudioOutputLevel = function (e) {
        return !(e && parseInt(e.audioRecvBytesDelta) > 0 && parseInt(e.audioDecodingNormalDelta) > 0 && 0 === parseInt(e.audioOutputLevel));
      }, t.checkAudioIntputLevel = function (e) {
        return !e || 0 !== parseInt(e.audioInputLevel);
      }, t.checkFramerateInput = function (e, t) {
        if (!e || !t.attributes) return !0;
        var n = parseInt(t.attributes.maxFrameRate),
            i = parseInt(e.googFrameRateInput);
        return !n || !i || !(n > 10 && i < 5 || n < 10 && n >= 5 && i <= 1);
      }, t.checkFramerateSent = function (e) {
        return !(e && parseInt(e.googFrameRateInput) > 5 && parseInt(e.googFrameRateSent) <= 1);
      }, t.checkSendVideoBitrate = function (e) {
        return !e || 0 !== parseInt(e.videoSendBytesDelta);
      }, t.checkSendAudioBitrate = function (e) {
        return !e || 0 !== parseInt(e.audioSendBytesDelta);
      }, t.checkVideoDecode = function (e) {
        return !e || 0 === parseInt(e.videoRecvBytesDelta) || 0 !== parseInt(e.googFrameRateDecoded);
      }, t.checkAudioDecode = function (e) {
        return !e || 0 === parseInt(e.audioRecvBytesDelta) || 0 !== parseInt(e.audioDecodingNormalDelta);
      }, t.record = function (e, n, i, o, r) {
        i[e] || (i[e] = {
          isPrevNormal: !0,
          record: []
        });
        var a = i[e],
            s = t["check" + e](n, r);

        if (a.record.push(s), a.record.length >= 5) {
          a.isCurNormal = -1 !== a.record.indexOf(!0);
          var c = Ye[e];
          a.isPrevNormal && !a.isCurNormal && t.gatewayClient.dispatchEvent({
            type: "exception",
            code: c,
            msg: Je[c],
            uid: o
          }), !a.isPrevNormal && a.isCurNormal && t.gatewayClient.dispatchEvent({
            type: "exception",
            code: c + 2e3,
            msg: Je[c + 2e3],
            uid: o
          }), a.isPrevNormal = a.isCurNormal, a.record = [];
        }
      }, t.setLocalStats = function (e) {
        var n = {};
        Object.keys(e).map(function (i) {
          var o = e[i],
              r = t.gatewayClient.localStreams[parseInt(i)],
              a = t.localStreamStorage[i] || {};
          r && r.hasVideo() && (t.record("SendVideoBitrate", o.videoStats, a, i), t.record("FramerateInput", o.videoStats, a, i, r), t.record("FramerateSent", o.videoStats, a, i)), r && r.hasAudio() && (t.record("AudioIntputLevel", o.audioStats, a, i), t.record("SendAudioBitrate", o.audioStats, a, i)), n[i] = a;
        }), t.localStreamStorage = n;
      }, t.setRemoteStats = function (n) {
        var i = {};
        Object.keys(n).map(function (o) {
          var r = n[o],
              a = e.remoteStreams[o],
              s = t.remoteStreamStorage[o] || {};
          a && a.hasVideo() && a.isPlaying() && t.record("VideoDecode", r.videoStats, s, o), a && a.hasAudio() && a.isPlaying() && (t.record("AudioOutputLevel", r.audioStats, s, o), t.record("AudioDecode", r.audioStats, s, o)), i[o] = s;
        }), t.remoteStreamStorage = i;
      }, t;
    },
        qe = new function () {
      var e = s();
      return e.states = {
        UNINIT: "UNINIT",
        INITING: "INITING",
        INITED: "INITED"
      }, e.state = e.states.UNINIT, e.type = null, e.lastConnectedAt = null, e.lastDisconnectedAt = null, e.lastTypeChangedAt = null, e.networkChangeTimer = null, e._init = function (t, n) {
        if (e.state = e.states.INITING, navigator.connection && navigator.connection.addEventListener) {
          var i = e._getNetworkInfo();

          e.type = i && i.type, e.state = e.states.INITED, t && t();
        } else e.state = e.states.UNINIT, n && n("DO_NOT_SUPPORT");
      }, e._getNetworkInfo = function () {
        return navigator.connection;
      }, e._reloadNetworkInfo = function () {
        var t = e._getNetworkInfo(),
            n = t && t.type || "UNSUPPORTED",
            i = Date.now();

        if (n !== e.type) {
          e.lastTypeChangedAt = i, "none" == n ? e.lastDisconnectedAt = i : "none" == e.type && (e.lastConnectedAt = i), e.type = n;
          var o = {
            type: "networkTypeChanged",
            networkType: n
          };
          e.dispatchEvent(o);
        }
      }, e.getStats = function (t, n) {
        var i = {},
            o = e._getNetworkInfo();

        o && (i.NetworkType = o.type || "UNSUPPORTED"), setTimeout(function () {
          t(i);
        }, 0);
      }, e._init(function () {
        navigator.connection.addEventListener("change", function () {
          e._reloadNetworkInfo();
        }), e.networkChangeTimer = setInterval(function () {
          e._reloadNetworkInfo();
        }, 5e3);
      }, function (e) {}), e;
    }(),
        Ke = function Ke(e) {
      var t = {
        key: void 0,
        highStream: null,
        lowStream: null,
        lowStreamParameter: null,
        isDualStream: !1,
        highStreamState: 2,
        lowStreamState: 2,
        proxyServer: null,
        turnServer: {},
        useProxyServer: !1
      };
      t.mode = e.mode, t.clientId = Object(G.b)().slice(0, 5), t.uintUid = null;
      e = S()({}, e);
      return t.aespassword = null, t.aesmode = "none", t.hasPublished = !1, t.getConnectionState = function () {
        var n = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.getConnectionState",
          options: arguments,
          tag: "tracer"
        }),
            i = He.connetionStateMap[t.gatewayClient.state];
        return n(), i;
      }, t.setClientRole = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          callback: i,
          name: "Client.setClientRole",
          options: arguments,
          tag: "tracer"
        });

        if (K(n, "setClientRole", ["host", "audience"]), "rtc" === t.mode) {
          var s = "RTC mode can not use setClientRole";
          return r.default.warning("[".concat(t.clientId, "] ").concat(s)), o && o(s);
        }

        t.gatewayClient && t.gatewayClient.state === He.CONNECTED ? ("audience" === n && (0 === this.highStreamState ? this._unpublish(this.highStream, function () {
          o && o(null, {
            role: n
          });
        }, function (e) {
          o && o(e);
        }) : t.gatewayClient.setClientRole("audience", o)), "host" === n && t.gatewayClient.setClientRole("host", o)) : (t.gatewayClient.role = n, o && o(null, {
          role: n
        }));
      }, t.getGatewayInfo = function (e) {
        if (t.gatewayClient.state !== He.CONNECTED) {
          var n = "Client is not in connected state";
          return r.default.error("[".concat(t.clientId, "] ").concat(n)), void e(n);
        }

        t.gatewayClient.getGatewayInfo(function (t) {
          e(null, t);
        }, e);
      }, t.renewToken = function (n, i, o) {
        var s = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return o && o(e);
            i && i(t);
          },
          name: "Client.renewToken",
          options: arguments,
          tag: "tracer"
        });
        if (!ie(n)) throw new Error("Invalid token: Token is of the string type .Length of the string: [1,255]. ASCII characters only.");
        return t.gatewayClient ? t.key ? (t.key = n, void t.gatewayClient.renewToken(n, function (e) {
          return s(null, e);
        }, s)) : (r.default.error("[".concat(t.clientId, "] renewToken should not be called before user join")), s(A.INVALID_OPERATION)) : (r.default.error("[".concat(t.clientId, "] renewToken Failed. GatewayClient not Exist")), s(A.INVALID_OPERATION));
      }, t.setLowStreamParameter = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setLowStreamParameter",
          options: arguments,
          tag: "tracer"
        });
        X(n, "param");
        var o = n.width,
            s = n.height,
            c = n.framerate,
            d = n.bitrate;
        se(o) || $(o, "width"), se(s) || $(s, "height"), se(c) || $(c, "framerate"), se(d) || $(d, "bitrate", 1, 1e7), (!o && s || o && !s) && r.default.warning("[".concat(t.clientId, "] The width and height parameters take effect only when both are set")), t.lowStreamParameter = n, i();
      }, t.init = function (n, i, o) {
        var s = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return o && o(e);
            i && i(t);
          },
          name: "Client.init",
          options: arguments,
          tag: "tracer"
        });
        Q(n), Object(f.isChromeKernel)() && Object(f.getChromeKernelVersion)() <= 48 ? o ? s(A.BAD_ENVIRONMENT) : Object(G.f)() : (r.default.info("[".concat(t.clientId, "] Initializing AgoraRTC client, appId: ").concat(n, ".")), e.appId = n, e.sessionId = Object(G.b)(), s());
      }, t.setTurnServer = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setTurnServer",
          options: arguments,
          tag: "tracer"
        });
        if (t.gatewayClient && t.gatewayClient.state !== He.DISCONNECTED) throw new Error("Set turn server before join channel");
        if (t.useProxyServer) throw new Error("You have already set the proxy");
        X(n, "turnServer");
        var o = n.turnServerURL,
            s = n.username,
            c = n.password,
            d = n.udpport,
            u = n.forceturn,
            l = n.tcpport;
        Q(o, "turnServerURL"), Q(s, "username"), Q(c, "password"), Q(d, "udpport"), se(u) || Z(u, "forceturn"), t.turnServer.url = o, t.turnServer.udpport = d, t.turnServer.username = s, t.turnServer.credential = c, t.turnServer.forceturn = u || !1, se(l) || (Q(l, "tcpport"), t.turnServer.tcpport = l, r.default.info("[".concat(t.clientId, "] Set turnserver tcpurl. ").concat(t.turnServer.url, ":").concat(t.turnServer.tcpport))), r.default.info("[".concat(t.clientId, "] Set turnserver udpurl. ").concat(t.turnServer.url, ":").concat(t.turnServer.udpport, ",username: ").concat(t.turnServer.uername, ",password: ").concat(t.turnServer.credential)), i();
      }, t.setProxyServer = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setProxyServer",
          options: arguments,
          tag: "tracer"
        });
        if (t.gatewayClient && t.gatewayClient.state !== He.DISCONNECTED) throw new Error("Set proxy server before join channel");
        if (!n) throw new Error("Do not set the proxyServer parameter as empty");
        if (t.useProxyServer) throw new Error("You have already set the proxy");
        Q(n, "proxyServer"), t.proxyServer = n, a.b.setProxyServer(n), r.default.setProxyServer(n), i();
      }, t.startProxyServer = function () {
        var n = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.startProxyServer",
          options: arguments,
          tag: "tracer"
        });
        if (t.gatewayClient && t.gatewayClient.state !== He.DISCONNECTED) throw new Error("Start proxy server before join channel");
        if (t.proxyServer || t.turnServer.url) throw new Error("You have already set the proxy");
        t.useProxyServer = !0, n();
      }, t.stopProxyServer = function () {
        var n = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.stopProxyServer",
          options: arguments,
          tag: "tracer"
        });
        if (t.gatewayClient && t.gatewayClient.state !== He.DISCONNECTED) throw new Error("Stop proxy server after leave channel");
        a.b.setProxyServer(), r.default.setProxyServer(), t.turnServer = {}, t.proxyServer = null, t.useProxyServer = !1, n();
      }, t.setEncryptionSecret = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setEncryptionSecret",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "password"), t.aespassword = n, i();
      }, t.setEncryptionMode = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setEncryptionMode",
          options: arguments,
          tag: "tracer"
        });
        if (Q(n, "encryptionMode"), -1 === ve.indexOf(n)) throw new Error('Invalid encryptionMode: encryptionMode should be "aes-128-xts" | "aes-256-xts" | "aes-128-ecb"');
        t.aesmode = n, i();
      }, t.configPublisher = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.configPublisher",
          options: arguments,
          tag: "tracer"
        });
        X(n, "config");
        var o = n.width,
            r = n.height,
            s = n.framerate,
            c = n.bitrate,
            d = n.publisherUrl;
        $(o, "width"), $(r, "height"), $(s, "framerate"), $(c, "bitrate", 1, 1e7), d && Q(d, "publisherUrl"), t.gatewayClient.configPublisher(n), i();
      }, t.enableDualStream = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Client.enableDualStream",
          options: arguments,
          tag: "tracer"
        });
        return "iOS" === Object(f.getBrowserOS)() ? (a.b.streamSwitch(e.sessionId, {
          lts: new Date().getTime(),
          isdual: !0,
          succ: !1
        }), o(A.IOS_NOT_SUPPORT)) : Object(f.isWeChatBrowser)() ? (a.b.streamSwitch(e.sessionId, {
          lts: new Date().getTime(),
          isdual: !0,
          succ: !1
        }), o(A.WECHAT_NOT_SUPPORT)) : (a.b.streamSwitch(e.sessionId, {
          lts: new Date().getTime(),
          isdual: !0,
          succ: !0
        }), t.isDualStream = !0, void (0 === t.highStreamState ? t._publishLowStream(function (e) {
          return o(null, e);
        }, function (e) {
          r.default.warning("[".concat(t.clientId, "]"), e), o(A.ENABLE_DUALSTREAM_FAILED);
        }) : 1 === t.highStreamState ? o(A.STILL_ON_PUBLISHING) : o(null)));
      }, t.disableDualStream = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Client.disableDualStream",
          options: arguments,
          tag: "tracer"
        });
        a.b.streamSwitch(e.sessionId, {
          lts: new Date().getTime(),
          isdual: !1,
          succ: !0
        }), t.isDualStream = !1, 0 === t.highStreamState ? t._unpublishLowStream(function () {
          t.highStream.lowStream = null, o();
        }, function (e) {
          r.default.warning("[".concat(t.clientId, "]"), e), o(A.DISABLE_DUALSTREAM_FAILED);
        }) : 1 === t.highStreamState ? o(A.STILL_ON_PUBLISHING) : o();
      }, t._createLowStream = function (e, n) {
        if (t.highStream && t.highStream.stream) {
          var i = S()({}, t.highStream.params);

          if (i.streamID += 1, i.audio = !1, i.video) {
            var a = t.highStream.stream.getVideoTracks()[0];
            a ? Y.getVideoCameraIdByLabel(a.label, function (a) {
              i.cameraId = a;
              var s = new pe(i);

              if (s.streamId = t.highStream.getId() + 1, t.lowStreamParameter) {
                var c = S()({}, t.lowStreamParameter);

                if (!c.width || !c.height) {
                  var d = Ge(t.highStream.profile),
                      u = o.SUPPORT_RESOLUTION_LIST[d[0]];
                  c.width = u[0], c.height = u[1];
                }

                if (c.framerate = c.framerate || 5, c.bitrate = c.bitrate || 50, Object(f.isSafari)() || Object(f.isOpera)()) {
                  r.default.debug("[".concat(t.clientId, "] Shimming lowStreamParameter"));
                  u = o.SUPPORT_RESOLUTION_LIST[t.highStream.profile];
                  c.width = u[0], c.height = u[1];
                }

                s.setVideoProfileCustomPlus(c);
              } else s.setVideoProfileCustom(Ge(t.highStream.profile));

              s.init(function () {
                t.highStream.lowStream = s, t.highStream.userMuteVideo && s.muteVideo(), e && e(s);
              }, n);
            }, n) : n && n(A.HIGH_STREAM_NOT_VIDEO_TRACE);
          } else n && n(A.HIGH_STREAM_NOT_VIDEO_TRACE);
        } else n && n(A.HIGH_STREAM_NOT_VIDEO_TRACE);
      }, t._getLowStream = function (e, n) {
        t.lowStream ? e(t.lowStream) : t._createLowStream(function (n) {
          t.lowStream = n, e(t.lowStream);
        }, n);
      }, t._publishLowStream = function (e, n) {
        return 2 !== t.lowStreamState ? n && n(A.LOW_STREAM_ALREADY_PUBLISHED) : t.highStream && t.highStream.hasScreen() ? n && n(A.SHARING_SCREEN_NOT_SUPPORT) : void t._getLowStream(function (i) {
          t.lowStreamState = 1, t.gatewayClient.publish(i, {
            streamType: 1
          }, function () {
            t.lowStreamState = 0, e && e();
          }, function (e) {
            r.default.debug("[".concat(t.clientId, "] publish low stream failed")), n && n(e);
          });
        }, n);
      }, t._unpublishLowStream = function (e, n) {
        if (0 !== t.lowStreamState) return n && n(A.LOW_STREAM_NOT_YET_PUBLISHED);
        t.lowStream && (t.gatewayClient.unpublish(t.lowStream, {
          streamType: 1
        }, function () {}, function (e) {
          r.default.debug("[".concat(t.clientId, "] unpublish low stream failed")), n && n(e);
        }), t.lowStream.close(), t.lowStream = null, t.lowStreamState = 2, e && e());
      }, t.join = function (n, i, o, s, c) {
        var d,
            u = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return c && c(e);
            s && s(t);
          },
          name: "Client.join",
          options: arguments,
          tag: "tracer"
        });
        if (n && !ie(n)) return r.default.warning("[".concat(t.clientId, "] Param channelKey should be string")), u(A.INVALID_PARAMETER);
        if (!ae(d = i) || !/^[a-zA-Z0-9!#$%&()+-:;<=.>?@[\]^_{}|~,\s]{1,64}$/.test(d)) return r.default.error("Invalid Channel Name ".concat(i)), r.default.warning("[".concat(t.clientId, "] The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,")), u(A.INVALID_PARAMETER);
        if ("string" == typeof i && "" === i) return r.default.warning("[".concat(t.clientId, "] Param channel should not be empty")), u(A.INVALID_PARAMETER);
        if (o && !Object(G.c)(o) && !ee(o, 1, 255)) return r.default.error("Invalid UID ".concat(o, " ").concat(q()(o))), r.default.warning("[".concat(t.clientId, "] [String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]")), u(A.INVALID_PARAMETER);
        if ("string" == typeof o && 0 == o.length) return r.default.warning("[".concat(t.clientId, "] String uid should not be empty")), u(A.INVALID_PARAMETER);
        if ("string" == typeof o && o.length > 256) return r.default.warning("[".concat(t.clientId, "] Length of string uid should be less than 255")), u(A.INVALID_PARAMETER);
        t.highStream = null, t.lowStream = null, t.lowStreamParameter = null, t.isDualStream = !1, t.highStreamState = 2, t.lowStreamState = 2;
        var l = {
          clientId: t.clientId,
          appId: e.appId,
          sid: e.sessionId,
          cname: i,
          uid: o,
          turnServer: t.turnServer,
          proxyServer: t.proxyServer,
          token: n || e.appId,
          useProxyServer: t.useProxyServer
        };
        if ("string" == typeof o && (l.stringUid = o, t.uintUid ? (l.uid = t.uintUid, delete t.uintUid) : l.uid = 0), t.aespassword && "none" !== t.aesmode && S()(l, {
          aespassword: t.aespassword,
          aesmode: t.aesmode
        }), a.b.sessionInit(e.sessionId, {
          lts: new Date().getTime(),
          cname: i,
          appid: e.appId,
          mode: e.mode,
          succ: !0
        }), t.onSuccess = function (e) {
          t.rtcStatsCollector.startNetworkQualityTimer(), t.onSuccess = null, u(null, e);
        }, t.onFailure = function (e) {
          return u(e);
        }, t.channel = i, t.gatewayClient.state !== He.DISCONNECTED) return r.default.error("[".concat(t.clientId, "] Client already in connecting/connected state")), u(A.INVALID_OPERATION), void a.b.joinGateway(e.sessionId, {
          lts: Date.now(),
          succ: !1,
          ec: A.INVALID_OPERATION,
          addr: null
        });
        t.gatewayClient.state = He.CONNECTING;

        var p = function p(o, a) {
          r.default.info("[".concat(t.clientId, "] Joining channel: ").concat(i)), t.gatewayClient.dispatchEvent({
            type: "config-distribute",
            config: a,
            joinInfo: l
          }), t.key = n || e.appId, l.cid = o.cid, l.uid || (l.uid = o.uid), l.clientId = t.clientId, o.uni_lbs_ip && o.uni_lbs_ip[1] && (l.uni_lbs_ip = o.uni_lbs_ip[1]), l.gatewayAddr = o.gateway_addr, t.joinInfo = l, t.gatewayClient.join(l, t.key, function (e) {
            r.default.info("[".concat(t.clientId, "] Join channel ").concat(i, " success, join with uid: ").concat(e, ".")), t.onSuccess = null, t.rtcStatsCollector.startNetworkQualityTimer(), u(null, e);
          }, function (e) {
            return u(e);
          });
        };

        l.stringUid && !l.uid ? (self.userAccountReq && !self.userAccountReq.isFinished() && self.userAccountReq.cancel(), self.userAccountReq = Le(l), self.userAccountReq.then(function (e) {
          r.default.debug("getUserAccount Success ".concat(e.url, " ").concat(l.stringUid, " => ").concat(e.uid)), l.uid = e.uid, ke(l, p);
        }).catch(function (e) {
          r.default.error("getUserAccount rejected", e), u(e);
        })) : ke(l, p);
      }, t.renewChannelKey = function (n, i, o) {
        var s = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return o && o(e);
            i && i(t);
          },
          name: "Client.renewChannelKey",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "key", 1, 2047), void 0 === t.key ? (r.default.error("[".concat(t.clientId, "] renewChannelKey should not be called before user join")), s(A.INVALID_OPERATION)) : (t.key = n, t.gatewayClient.key = n, t.gatewayClient.rejoin(), s());
      }, t.leave = function (n, i) {
        var s = !1,
            c = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, o) {
            if (e) return i && i(e);
            var r, a;
            r = t.clientId, a = !1, Ne[r] = a, t._renewSession(), t.rtcStatsCollector.clearNetworkQualityTimer(), n && n(o);
          },
          name: "Client.leave",
          options: arguments,
          tag: "tracer"
        });
        r.default.info("[".concat(t.clientId, "] Leaving channel")), self.userAccountReq && !self.userAccountReq.isFinished() && (self.userAccountReq.cancel(), t.gatewayClient.state === He.CONNECTING && (t.gatewayClient.state = He.DISCONNECTED)), t.gatewayClient.leave(function (e) {
          s = !0, c(null, e);
        }, c), setTimeout(function () {
          s || (t.gatewayClient.socket && (t.gatewayClient.socket.close(), t.gatewayClient.socket = null), t.gatewayClient.state = He.DISCONNECTED, c(null, "LEAVE_MSG_TIMEOUT"));
        }, Object(o.getParameter)("LEAVE_MSG_TIMEOUT"));
      }, t._renewSession = function () {
        var n = Object(G.b)();
        if (r.default.debug("renewSession ".concat(e.sessionId, " => ").concat(n)), e.sessionId = n, t.joinInfo && (t.joinInfo.sid = n), t.gatewayClient && (t.gatewayClient.joinInfo && (t.gatewayClient.joinInfo.sid = n), t.gatewayClient.localStreams)) for (var i in t.gatewayClient.localStreams) {
          var o = t.gatewayClient.localStreams[i];
          o && (o.sid = n);
        }
      }, t._publish = function (n, i, o) {
        if (2 !== t.highStreamState) return r.default.warning("[".concat(t.clientId, "] Can't publish stream when stream already publish ").concat(n.getId())), o && o(A.STREAM_ALREADY_PUBLISHED);
        r.default.info("[".concat(t.clientId, "] Publishing stream, uid ").concat(n.getId())), t.highStream = n, t.highStreamState = 1, t.highStream.streamId = t.joinInfo.stringUid || t.joinInfo.uid, t.hasPublished = !1;

        var a = function a(n, i, o) {
          t.gatewayClient.publish(n, {
            streamType: 0
          }, function () {
            n.sid = e.sessionId, t.highStreamState = 0, r.default.info("[".concat(t.clientId, "] Publish success, uid: ").concat(n.getId())), t.isDualStream ? t._publishLowStream(function () {
              i && i();
            }, function (e) {
              r.default.warning("[".concat(t.clientId, "] "), e), i && i();
            }) : i && i();
          }, o);
        };

        "audience" === t.gatewayClient.role && "live" === t.mode ? t.gatewayClient.setClientRole("host", function (e) {
          if (e) return o && o(e);
          a(n, i, o);
        }) : a(n, i, o);
      }, t._unpublish = function (e, n, i) {
        if (0 !== t.highStreamState) return r.default.warning("[".concat(t.clientId, "] Can't unpublish stream when stream not publish")), i && i(A.STREAM_NOT_YET_PUBLISHED);
        r.default.info("[".concat(t.clientId, "] Unpublish stream, uid ").concat(e.getId()));

        var o = function o(e, n, i) {
          t.isDualStream && t.lowStream && t._unpublishLowStream(null, i), t.gatewayClient.unpublish(e, {
            streamType: 0
          }, function () {
            t.highStreamState = 2, r.default.info("[".concat(t.clientId, "] Unpublish stream success, uid: ").concat(e.getId())), n && n();
          }, function (n) {
            r.default.info("[".concat(t.clientId, "] Unpublish stream fail, uid: ").concat(e.getId())), i && i(n);
          });
        };

        "host" === t.gatewayClient.role && "live" === t.mode ? t.gatewayClient.setClientRole("audience", function (t) {
          if (t) return i && i(t);
          o(e, n, i);
        }) : o(e, n, i);
      }, t.publish = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
          },
          name: "Client.publish",
          tag: "tracer",
          options: {
            stream: "too long to show",
            onFailure: !!i
          }
        });
        2 === t.highStreamState ? t._publish(n, function (e) {
          return o(null, e);
        }, function (e) {
          return o(e);
        }) : o(A.STREAM_ALREADY_PUBLISHED);
      }, t.unpublish = function (n, i, o) {
        var r = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            o && o(t);
          },
          name: "Client.unpublish",
          tag: "tracer",
          options: {
            stream: "too long to show",
            onFailure: !!i
          }
        });
        0 === t.highStreamState ? t._unpublish(n, function (e) {
          return r(null, e);
        }, function (e) {
          return r(e);
        }) : r(A.STREAM_NOT_YET_PUBLISHED);
      }, t.subscribe = function (n, i, o) {
        var s = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return o && o(e);
          },
          name: "Client.subscribe",
          tag: "tracer",
          options: {
            stream: "too long to show",
            options: i,
            onFailure: !!o
          }
        });
        "function" == typeof i && (o = i, i = null), X(n, "stream"), se(i) || (X(i, "options"), se(i.video) || Z(i.video, "options.video"), se(i.audio) || Z(i.audio, "options.audio"));
        var c = {
          video: !0,
          audio: !0
        };

        if (!se(i)) {
          if (Object(f.isSafari)() && (!i.video || !i.audio)) {
            var d = "SAFARI_NOT_SUPPORTED_FOR_TRACK_SUBSCRIPTION";
            return r.default.error("[".concat(t.clientId, "] "), d), void s(d);
          }

          if (!se(i.video) && !ne(i.video) || !se(i.audio) && !ne(i.audio) || !1 === i.audio && !1 === i.video) {
            d = "INVALID_PARAMETER ".concat(JSON.stringify(i));
            return r.default.error("[".concat(t.clientId, "] "), d), void s(d);
          }
        }

        n.subscribeOptions ? (S()(n.subscribeOptions, c, i), t.gatewayClient.subscribeChange(n, function (e) {
          return s(null, e);
        }, s)) : (n.subscribeOptions = S()({}, c, i), t.gatewayClient.subscribe(n, function (e) {
          return s(null, e);
        }, s));
      }, t.unsubscribe = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
          },
          name: "Client.unsubscribe",
          tag: "tracer",
          options: {
            stream: "too long to show",
            onFailure: !!i
          }
        });
        r.default.info("[".concat(t.clientId, "] Unsubscribe stream, uid: ").concat(n.getId())), t.gatewayClient.unsubscribe(n, function (e) {
          return o(null, e);
        }, o);
      }, t.setRemoteVideoStreamType = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setRemoteVideoStreamType",
          tag: "tracer",
          options: {
            stream: "too long to show",
            streamType: i
          }
        });
        K(i, "streamType", [0, 1]), t.gatewayClient.setRemoteVideoStreamType(n, i), o();
      }, t.setStreamFallbackOption = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setStreamFallbackOption",
          tag: "tracer",
          options: {
            stream: "too long to show",
            fallbackType: i
          }
        });
        K(i, "fallbackType", [0, 1, 2]), t.gatewayClient.setStreamFallbackOption(n, i), o();
      }, t.startLiveStreaming = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.startLiveStreaming",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "url"), se(i) || Z(i, "transcodingEnabled"), t.gatewayClient.startLiveStreaming(n, i), o();
      }, t.stopLiveStreaming = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.stopLiveStreaming",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "url"), t.gatewayClient.stopLiveStreaming(n), i();
      }, t.setLiveTranscoding = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setLiveTranscoding",
          options: arguments,
          tag: "tracer"
        });
        X(n, "transcoding");
        var o = n.width,
            r = n.height,
            s = n.videoBitrate,
            c = n.videoFramerate,
            d = n.lowLatency,
            u = n.audioSampleRate,
            l = n.audioBitrate,
            p = n.audioChannels,
            f = n.videoGop,
            m = n.videoCodecProfile,
            g = n.userCount,
            v = n.backgroundColor,
            I = n.transcodingUsers;

        if (se(o) || $(o, "width"), se(r) || $(r, "height"), se(s) || $(s, "videoBitrate", 1, 1e6), se(c) || $(c, "videoFramerate"), se(d) || Z(d, "lowLatency"), se(u) || K(u, "audioSampleRate", [32e3, 44100, 48e3]), se(l) || $(l, "audioBitrate", 1, 128), se(p) || K(p, "audioChannels", [1, 2, 3, 4, 5]), se(f) || $(f, "videoGop"), se(m) || K(m, "videoCodecProfile", [66, 77, 100]), se(g) || $(g, "userCount", 0, 17), se(v) || $(v, "backgroundColor", 0, 16777215), !se(I)) {
          if (!(I instanceof Array)) throw new Error("[transcodingUsers]: transcodingUsers should be Array");
          if (I.length > 17) throw new Error("The length of transcodingUsers cannot greater than 17");
          I.map(function (e, t) {
            if (!se(e.uid) && !Object(G.c)(e.uid) && !ee(e.uid, 1, 255)) throw new Error("[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
            if (se(e.x) || $(e.x, "transcodingUser[".concat(t, "].x"), 0, 1e4), se(e.y) || $(e.y, "transcodingUser[".concat(t, "].y"), 0, 1e4), se(e.width) || $(e.width, "transcodingUser[".concat(t, "].width"), 0, 1e4), se(e.height) || $(e.height, "transcodingUser[".concat(t, "].height"), 0, 1e4), se(e.zOrder) || $(e.zOrder, "transcodingUser[".concat(t, "].zOrder"), 0, 100), !(se(e.alpha) || "number" == typeof e.alpha && e.alpha <= 1 && e.alpha >= 0)) throw new Error("transcodingUser[${index}].alpha: The value range is [0, 1]");
          });
        }

        S()(Xe, n), t.gatewayClient.setLiveTranscoding(Xe), i();
      }, t.addInjectStreamUrl = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.addInjectStreamUrl",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "url", 1, 255), X(i, "config"), !se(i && i.width) && $(i.width, "config.width", 0, 1e4), !se(i && i.height) && $(i.height, "config.height", 0, 1e4), !se(i && i.videoGop) && $(i.videoGop, "config.videoGop", 1, 1e4), !se(i && i.videoFramerate) && $(i.videoFramerate, "config.videoFramerate", 1, 1e4), !se(i && i.videoBitrate) && $(i.videoBitrate, "config.videoBitrate", 1, 1e4), !se(i && i.audioSampleRate) && K(i.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), !se(i && i.audioBitrate) && $(i.audioBitrate, "config.audioBitrate", 1, 1e4), !se(i && i.audioChannels) && $(i.audioChannels, "config.audioChannels", 1, 2), S()(Qe, i), t.gatewayClient.addInjectStreamUrl(n, Qe), o();
      }, t.removeInjectStreamUrl = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.removeInjectStreamUrl",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "url", 1, 255), t.gatewayClient.removeInjectStreamUrl(n), i();
      }, t.enableAudioVolumeIndicator = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.enableAudioVolumeIndicator",
          options: arguments,
          tag: "tracer"
        });
        n = n || 2e3, $(i = i || 3, "smooth", 1, 100), $(n, "interval", 50, 1e5), t.audioVolumeIndication = t.audioVolumeIndication || {
          enabled: !0
        }, t.audioVolumeIndication.interval = n, t.audioVolumeIndication.smooth = i, t.audioVolumeIndication = {
          interval: n,
          smooth: i
        }, r.default.info("[".concat(t.clientId, "] enableAudioVolumeIndicator interval ").concat(n, " smooth ").concat(i)), t.gatewayClient.enableAudioVolumeIndicator(n, i), o();
      }, t.getNetworkStats = function (e, n) {
        return r.default.deprecate("[".concat(t.clientId, "] client.getNetworkStats is deprecated. Use client.getTransportStats instead.")), qe.getStats(e, n);
      }, t.getSystemStats = function (e, t) {
        return g.getStats(e, t);
      }, t.getRecordingDevices = function (e, t) {
        return Y.getRecordingDevices(e, t);
      }, t.getPlayoutDevices = function (e, t) {
        return Y.getPlayoutDevices(e, t);
      }, t.getCameras = function (e, t) {
        return Y.getCameras(e, t);
      }, t.getRemoteAudioStats = function (e, n) {
        return t.rtcStatsCollector.getRemoteAudioStats(e, n);
      }, t.getLocalAudioStats = function (e, n) {
        return t.rtcStatsCollector.getLocalAudioStats(e, n);
      }, t.getRemoteVideoStats = function (e, n) {
        return t.rtcStatsCollector.getRemoteVideoStats(e, n);
      }, t.getLocalVideoStats = function (e, n) {
        return t.rtcStatsCollector.getLocalVideoStats(e, n);
      }, t._getRemoteVideoQualityStats = function (e, n) {
        return t.rtcStatsCollector.getRemoteVideoQualityStats(e, n);
      }, t._getRemoteAudioQualityStats = function (e, n) {
        return t.rtcStatsCollector.getRemoteAudioQualityStats(e, n);
      }, t.getTransportStats = function (e, n) {
        return t.rtcStatsCollector.getTransportStats(function (t) {
          return qe.getStats(function (n) {
            var i = S()({}, t, n);
            e && e(i);
          }, n);
        }, n);
      }, t.getSessionStats = function (e, n) {
        return t.rtcStatsCollector.getSessionStats(e, n);
      }, t.onNetworkQuality = function () {
        return t.rtcStatsCollector.onNetworkQuality(onSuccess, onFailure);
      }, e.clientId = t.clientId, t.gatewayClient = He(e), t.on = t.gatewayClient.on, t.off = t.gatewayClient.removeEventListener, t.rtcStatsCollector = function (e) {
        var t = s();
        return t.gatewayClient = e, t.exceptionMonitor = new ze(e), t.localStats = {}, t.remoteStats = {}, t.session = {
          sendBytes: 0,
          recvBytes: 0,
          WSSendBytes: 0,
          WSSendBytesDelta: 0,
          WSRecvBytes: 0,
          WSRecvBytesDelta: 0,
          HTTPSendBytes: 0,
          HTTPSendBytesDelta: 0,
          HTTPRecvBytes: 0,
          HTTPRecvBytesDelta: 0
        }, t.getRemoteAudioStats = function (e) {
          var n = {};

          for (var i in t.remoteStats) {
            var o = {},
                r = t.remoteStats[i];
            J(o, "End2EndDelay", r.peer_delay && r.peer_delay.audio_delay), J(o, "TransportDelay", r.peer_delay && r.peer_delay.e2e_delay), J(o, "PacketLossRate", r.peer_delay && r.peer_delay.e2e_audio_lost_ratio_400ms), J(o, "RecvLevel", r.audioStats && r.audioStats.audioOutputLevel), J(o, "RecvBitrate", r.audioRecvBitrate), J(o, "CodecType", r.audioStats && r.audioStats.googCodecName), J(o, "MuteState", r.audioDisabled), J(o, "TotalFreezeTime", r.audioStats && r.audioStats.audioTotalFreezeTime), J(o, "TotalPlayDuration", r.audioStats && r.audioStats.audioTotalPlayDuration), n[i] = o;
          }

          e && e(n);
        }, t.getLocalAudioStats = function (e) {
          var n = {};

          for (var i in t.localStats) {
            var o = {},
                r = t.localStats[i];
            J(o, "RecordingLevel", r.audioStats && r.audioStats.audioInputLevel), J(o, "SendLevel", r.audioStats && r.audioStats.totalAudioEnergy), J(o, "SamplingRate", r.audioStats && r.audioStats.totalSamplesDuration), J(o, "SendBitrate", r.audioSendBitrate), J(o, "CodecType", r.audioStats && r.audioStats.googCodecName), J(o, "MuteState", r.audioDisabled);
            var a = t.gatewayClient.localStreams[i];
            a && a.isPlaying() && J(o, "MuteState", a.userMuteAudio ? "1" : "0"), n[i] = o;
          }

          e && e(n);
        }, t.getRemoteVideoStats = function (e) {
          var n = {};

          for (var i in t.remoteStats) {
            var o = {},
                r = t.remoteStats[i];
            J(o, "End2EndDelay", r.peer_delay && r.peer_delay.video_delay), J(o, "TransportDelay", r.peer_delay && r.peer_delay.e2e_delay), J(o, "PacketLossRate", r.peer_delay && r.peer_delay.e2e_video_lost_ratio_400ms), J(o, "RecvBitrate", r.videoRecvBitrate), J(o, "RecvResolutionWidth", r.videoStats && r.videoStats.googFrameWidthReceived), J(o, "RecvResolutionHeight", r.videoStats && r.videoStats.googFrameHeightReceived), J(o, "RenderResolutionWidth", r.videoStats && r.videoStats.renderRemoteWidth), J(o, "RenderResolutionHeight", r.videoStats && r.videoStats.renderRemoteHeight), J(o, "RenderFrameRate", r.videoStats && r.videoStats.googFrameRateOutput), J(o, "MuteState", r.videoDisabled), J(o, "TotalFreezeTime", r.videoStats && r.videoStats.videoTotalFreezeTime), J(o, "TotalPlayDuration", r.videoStats && r.videoStats.videoTotalPlayDuration), n[i] = o;
          }

          e && e(n);
        }, t.getLocalVideoStats = function (e) {
          var n = {};

          for (var i in t.localStats) {
            var o = {},
                r = t.localStats[i];
            J(o, "TargetSendBitrate", r.videoTargetSendBitrate), J(o, "SendFrameRate", r.videoStats && r.videoStats.googFrameRateSent), J(o, "SendBitrate", r.videoSendBitrate), J(o, "SendResolutionWidth", r.videoStats && r.videoStats.googFrameWidthSent), J(o, "SendResolutionHeight", r.videoStats && r.videoStats.googFrameHeightSent), J(o, "CaptureResolutionWidth", r.videoStats && r.videoStats.googFrameWidthInput), J(o, "CaptureResolutionHeight", r.videoStats && r.videoStats.googFrameHeightInput), J(o, "EncodeDelay", r.videoStats && r.videoStats.googAvgEncodeMs), J(o, "MuteState", r.videoDisabled), J(o, "TotalFreezeTime", r.videoStats && r.videoStats.videoTotalFreezeTime), J(o, "TotalDuration", r.videoStats && r.videoStats.videoTotalPlayDuration), J(o, "CaptureFrameRate", r.videoStats && r.videoStats.googFrameRateSent), r.videoStats.googFrameWidthInput || J(o, "CaptureResolutionWidth", r.videoStats && r.videoStats.renderLocalWidth), r.videoStats.googFrameHeightInput || J(o, "CaptureResolutionHeight", r.videoStats && r.videoStats.renderLocalHeight), n[i] = o, e && e(n);
          }
        }, t.getRemoteVideoQualityStats = function (e) {
          var n = {};

          for (var i in t.remoteStats) {
            var o = {},
                r = t.remoteStats[i];
            J(o, "videoReceiveDelay", r.videoStats && r.videoStats.googCurrentDelayMs), J(o, "VideoFreezeRate", r.videoStats && r.videoStats.videoFreezeRate), J(o, "FirstFrameTime", r.firstFrameTime), n[i] = o;
          }

          e && e(n);
        }, t.getRemoteAudioQualityStats = function (e) {
          var n = {};

          for (var i in t.remoteStats) {
            var o = {},
                r = t.remoteStats[i];
            J(o, "audioReceiveDelay", r.audioStats && r.audioStats.googCurrentDelayMs), J(o, "AudioFreezeRate", r.videoStats && r.videoStats.videoFreezeRate), n[i] = o;
          }

          e && e(n);
        }, t.getTransportStats = function (e) {
          var n = {},
              i = {},
              o = t.gatewayClient.traffic_stats,
              r = o.peer_delay;

          if (J(n, "OutgoingAvailableBandwidth", t.gatewayClient.OutgoingAvailableBandwidth / 1e3), J(n, "RTT", o && o.access_delay), r) {
            var a = !0,
                s = !1,
                c = void 0;

            try {
              for (var d, u = r[Symbol.iterator](); !(a = (d = u.next()).done); a = !0) {
                var l = d.value;
                l.downlink_estimate_bandwidth && (i[l.peer_uid] = l.downlink_estimate_bandwidth / 1e3 + "");
              }
            } catch (e) {
              s = !0, c = e;
            } finally {
              try {
                a || null == u.return || u.return();
              } finally {
                if (s) throw c;
              }
            }
          }

          n.IncomingAvailableBandwidth = i, e && e(n);
        }, t.getSessionStats = function (e) {
          var n = {},
              i = t.gatewayClient.traffic_stats,
              o = t.gatewayClient.socket,
              r = 0,
              a = 0;

          for (var s in t.remoteStats) {
            (c = t.remoteStats[s]) && c.videoStats && c.videoStats.videoRecvBytesDelta && (a += parseInt(c.videoStats.videoRecvBytesDelta)), c && c.audioStats && c.audioStats.audioRecvBytesDelta && (a += parseInt(c.audioStats.audioRecvBytesDelta));
          }

          for (var s in t.localStats) {
            var c;
            (c = t.localStats[s]) && c.videoStats && c.videoStats.videoSendBytesDelta && (r += parseInt(c.videoStats.videoSendBytesDelta)), c && c.audioStats && c.audioStats.audioSendBytesDelta && (r += parseInt(c.audioStats.audioSendBytesDelta));
          }

          var d = r + t.session.WSSendBytesDelta + t.session.HTTPSendBytesDelta,
              u = a + t.session.WSRecvBytesDelta + t.session.HTTPRecvBytesDelta,
              l = t.session.sendBytes + Object(Ie.b)(),
              p = t.session.recvBytes + Object(Ie.a)();
          t.gatewayClient.socket && t.gatewayClient.socket.state === t.gatewayClient.CONNECTED && (l += o.getSendBytes(), p += o.getRecvBytes());
          var f = 1;
          i.peer_delay && (f = i.peer_delay.length, f += 1), J(n, "Duration", o.getDuration()), J(n, "UserCount", f), J(n, "SendBytes", l), J(n, "RecvBytes", p), J(n, "SendBitrate", 8 * d / 1e3), J(n, "RecvBitrate", 8 * u / 1e3), e && e(n);
        }, t.isLocalVideoFreeze = function (e, t) {
          var n = 0,
              i = 0;
          if (!e || !t) return !1;
          if (Object(f.isChrome)() || Object(f.isOpera)()) n = e.googFrameRateInput, i = e.googFrameRateSent;else if (Object(f.isSafari)()) n = parseInt(e.framerateMean), i = parseInt(e.framesEncoded) - parseInt(t.framesEncoded);else {
            if (!Object(f.isFireFox)()) return !1;
            n = parseInt(e.framerateMean), i = parseInt(e.framesEncoded) - parseInt(t.framesEncoded);
          }
          return n > 5 && i < 3;
        }, t.isRemoteVideoFreeze = function (e, t) {
          var n = 0,
              i = 0;
          if (!e || !t) return !1;
          if (Object(f.isChrome)() || Object(f.isOpera)()) n = e.googFrameRateReceived, i = e.googFrameRateDecoded;else if (Object(f.isSafari)()) n = e.framerateMean, i = parseInt(e.framesDecoded) - parseInt(t.framesDecoded);else {
            if (!Object(f.isFireFox)()) return !1;
            n = parseInt(e.framesReceived) - parseInt(t.framesReceived), i = parseInt(e.framesDecoded) - parseInt(t.framesDecoded);
          }
          return n > 5 && n < 10 && i < 3 || n > 10 && n < 20 && i < 4 || n > 20 && i < 5;
        }, t.isAudioFreeze = function (e) {
          if (Object(f.isChrome)() && e) {
            if (e.googDecodingPLC && e.googDecodingPLCCNG && e.googDecodingCTN) return (parseInt(e.googDecodingPLC) + parseInt(e.googDecodingPLCCNG)) / parseInt(e.googDecodingCTN) > .2;
          } else if ((Object(f.isSafari)() || Object(f.isFireFox)()) && e.packetsLost && e.packetsReceived) return parseInt(e.packetsLost) / (parseInt(e.packetsLost) + parseInt(e.packetsReceived)) > .2;

          return !1;
        }, t.isAudioDecodeFailed = function (e) {
          return !!((Object(f.isChrome)() || Object(f.isOpera)()) && e && parseInt(e.bytesReceived) > 0 && 0 === parseInt(e.googDecodingNormal));
        }, t.startNetworkQualityTimer = function () {
          t.clearNetworkQualityTimer(), t.networkQualityTimer = setInterval(function () {
            if (t.gatewayClient.state !== He.CONNECTED) t.gatewayClient.dispatchEvent({
              type: "network-quality",
              uplinkNetworkQuality: 0,
              downlinkNetworkQuality: 0
            });else {
              var e = t.gatewayClient.traffic_stats;
              t.gatewayClient.dispatchEvent({
                type: "network-quality",
                uplinkNetworkQuality: t.networkQualityTrans(e.uplink_network_quality),
                downlinkNetworkQuality: t.networkQualityTrans(e.downlink_network_quality)
              });
            }
          }, 2e3);
        }, t.clearNetworkQualityTimer = function () {
          t.networkQualityTimer && clearInterval(t.networkQualityTimer);
        }, t.networkQualityTrans = function (e) {
          return e >= 0 && e < .17 ? 1 : e >= .17 && e < .36 ? 2 : e >= .36 && e < .59 ? 3 : e >= .59 && e <= 1 ? 4 : e > 1 ? 5 : 0;
        }, t.getStatsTimer = setInterval(function () {
          var e = t.gatewayClient.traffic_stats,
              n = Date.now();
          t.gatewayClient.dispatchEvent({
            type: "_testException"
          }), Object.keys(t.localStats).length && t.exceptionMonitor.setLocalStats(t.localStats), Object.keys(t.remoteStats).length && t.exceptionMonitor.setRemoteStats(t.remoteStats);
          var i = {};
          Object.keys(t.gatewayClient.remoteStreams).forEach(function (o) {
            var r = t.gatewayClient.remoteStreams[o],
                a = t.remoteStats[o],
                s = {
              id: o,
              updatedAt: n
            };
            i[o] = s, s.firstFrameTime = r.firstFrameTime, a ? (s.audioTotalPlayDuration = a.audioTotalPlayDuration + 1, s.audioTotalFreezeTime = a.audioTotalFreezeTime, s.isAudioFreeze = !1, s.isAudioDecodeFailed = !1, s.videoTotalPlayDuration = a.videoTotalPlayDuration + 1, s.videoTotalFreezeTime = a.videoTotalFreezeTime, s.isVideoFreeze = !1) : (s.audioTotalPlayDuration = 1, s.audioTotalFreezeTime = 0, s.videoTotalPlayDuration = 1, s.videoTotalFreezeTime = 0);
            var c = e && e.peer_delay && e.peer_delay.find(function (e) {
              return e.peer_uid == o;
            });
            c && (s.peer_delay = c), r && (r.isPlaying() && (s.audioDisabled = r.userMuteAudio || r.peerMuteAudio ? "1" : "0", s.videoDisabled = r.userMuteVideo || r.peerMuteVideo ? "1" : "0"), a && a.peer_delay && c && a.peer_delay.stream_type !== c.stream_type && t.gatewayClient.dispatchEvent({
              type: "streamTypeChange",
              uid: o,
              streamType: c.stream_type
            }), r.pc && "established" == r.pc.state && r.pc.getStats(function (e) {
              if (s.pcStats = e, s.audioStats = e.find(function (e) {
                return "audio" == e.mediaType && (e.id.indexOf("_recv") > -1 || e.id.toLowerCase().indexOf("inbound") > -1);
              }), s.videoStats = e.find(function (e) {
                return "video" == e.mediaType && (e.id.indexOf("_recv") > -1 || e.id.toLowerCase().indexOf("inbound") > -1);
              }), a && a.audioStats && s.audioStats) {
                var n = parseInt(s.audioStats.bytesReceived) - parseInt(a.audioStats.bytesReceived),
                    i = parseInt(s.audioStats.googDecodingNormal) - parseInt(a.audioStats.googDecodingNormal);

                if (s.audioStats.audioRecvBytesDelta = n, s.audioStats.audioDecodingNormalDelta = i, t.session.recvBytes += n, isFinite(n) && s.audioStats.timestamp) {
                  var o = s.audioStats.timestamp.getTime() - a.audioStats.timestamp.getTime();
                  s.audioRecvBitrate = Math.floor(8 * n / o);
                }

                t.isAudioFreeze(s.audioStats) && s.audioTotalPlayDuration > 10 && (s.audioTotalFreezeTime++, s.isAudioFreeze = !0), t.isAudioDecodeFailed(s.audioStats) && s.audioTotalPlayDuration > 10 && (s.isAudioDecodeFailed = !0), s.audioStats.audioTotalFreezeTime = s.audioTotalFreezeTime, s.audioStats.audioTotalPlayDuration = s.audioTotalPlayDuration, s.audioStats.audioFreezeRate = Math.ceil(100 * s.audioTotalFreezeTime / s.audioTotalPlayDuration);
              }

              if (a && a.videoStats && s.videoStats) {
                var c = parseInt(s.videoStats.bytesReceived) - parseInt(a.videoStats.bytesReceived);
                s.videoStats.videoRecvBytesDelta = c, t.session.recvBytes += c, isFinite(c) && s.videoStats.timestamp && (o = s.videoStats.timestamp.getTime() - a.videoStats.timestamp.getTime(), s.videoRecvBitrate = Math.floor(8 * c / o)), t.isRemoteVideoFreeze(s.videoStats, a.videoStats) && (s.videoTotalFreezeTime++, s.isVideoFreeze = !0), s.videoStats.videoTotalFreezeTime = s.videoTotalFreezeTime, s.videoStats.videoTotalPlayDuration = s.videoTotalPlayDuration, s.videoStats.videoFreezeRate = Math.ceil(100 * s.videoTotalFreezeTime / s.videoTotalPlayDuration), r.player && r.player.video && r.player.video.videoWidth && r.player.video.videoHeight ? (s.videoStats.renderRemoteWidth = r.player.video.videoWidth, s.videoStats.renderRemoteHeight = r.player.video.videoHeight) : (s.videoStats.renderRemoteWidth = r.videoWidth || s.videoStats.googFrameWidthReceived, s.videoStats.renderRemoteHeight = r.videoHeight || s.videoStats.googFrameHeightReceived);
              }
            }));
          }), t.remoteStats = i;
          var o = {};

          if (Object.keys(t.gatewayClient.localStreams).forEach(function (e) {
            var i = t.gatewayClient.localStreams[e],
                r = t.localStats[e],
                a = {
              id: e,
              updatedAt: n
            };
            o[e] = a, r ? (a.videoTotalPlayDuration = r.videoTotalPlayDuration + 1, a.videoTotalFreezeTime = r.videoTotalFreezeTime, a.isVideoFreeze = !1) : (a.videoTotalPlayDuration = 1, a.videoTotalFreezeTime = 0), i && (i.isPlaying() && (a.audioDisabled = i.userMuteAudio ? "1" : "0", a.videoDisabled = i.userMuteVideo ? "1" : "0"), i.video && i.attributes.maxVideoBW ? a.videoTargetSendBitrate = i.attributes.maxVideoBW : i.video && i.screenAttributes && (a.videoTargetSendBitrate = i.screenAttributes.maxVideoBW), i.pc && "established" == i.pc.state && i.pc.getStats(function (e) {
              if (a.pcStats = e.reverse(), a.audioStats = e.find(function (e) {
                return "audio" == e.mediaType && (e.id.indexOf("_send") > -1 || e.id.toLowerCase().indexOf("outbound") > -1);
              }), a.videoStats = e.find(function (e) {
                return "video" == e.mediaType && (e.id.indexOf("_send") > -1 || e.id.toLowerCase().indexOf("outbound") > -1);
              }), a.audioStats && r && r.audioStats) {
                var n = parseInt(a.audioStats.bytesSent) - parseInt(r.audioStats.bytesSent);

                if (a.audioStats.audioSendBytesDelta = n, t.session.sendBytes += n, isFinite(n) && a.audioStats.timestamp) {
                  var o = a.audioStats.timestamp.getTime() - r.audioStats.timestamp.getTime();
                  a.audioSendBitrate = Math.floor(8 * n / o);
                }
              }

              if (a.videoStats && r && r.videoStats) {
                var s = parseInt(a.videoStats.bytesSent) - parseInt(r.videoStats.bytesSent);
                a.videoStats.videoSendBytesDelta = s, t.session.sendBytes += s, isFinite(s) && a.videoStats.timestamp && (o = a.videoStats.timestamp.getTime() - r.videoStats.timestamp.getTime(), a.videoSendBitrate = Math.floor(8 * s / o)), t.isLocalVideoFreeze(a.videoStats, r.videoStats) && (a.videoTotalFreezeTime++, a.isVideoFreeze = !0), a.videoStats.videoTotalFreezeTime = a.videoTotalFreezeTime, a.videoStats.videoTotalPlayDuration = a.videoTotalPlayDuration, a.videoStats.videoFreezeRate = Math.ceil(100 * a.videoTotalFreezeTime / a.videoTotalPlayDuration), a.videoStats.renderLocalWidth = i.videoWidth || a.videoStats.googFrameWidthSent, a.videoStats.renderLocalHeight = i.videoHeight || a.videoStats.googFrameHeightSent;
              }
            }));
          }), t.localStats = o, t.session.HTTPSendBytesDelta = Object(Ie.b)() - t.session.HTTPSendBytes, t.session.HTTPSendBytes = Object(Ie.b)(), t.session.HTTPRecvBytesDelta = Object(Ie.a)() - t.session.HTTPRecvBytes, t.session.HTTPRecvBytes = Object(Ie.a)(), t.gatewayClient.socket && t.gatewayClient.socket.state === t.gatewayClient.CONNECTED) {
            var r = t.gatewayClient.socket;
            t.session.WSSendBytesDelta = r.getSendBytes() - t.session.WSSendBytes, t.session.WSSendBytes = r.getSendBytes(), t.session.WSRecvBytesDelta = r.getRecvBytes() - t.session.WSRecvBytes, t.session.WSRecvBytes = r.getRecvBytes();
          }
        }, 1e3), t.gatewayClient.on("join", function () {
          t.session = {
            sendBytes: 0,
            recvBytes: 0,
            WSSendBytes: 0,
            WSSendBytesDelta: 0,
            WSRecvBytes: 0,
            WSRecvBytesDelta: 0,
            HTTPSendBytes: 0,
            HTTPSendBytesDelta: 0,
            HTTPRecvBytes: 0,
            HTTPRecvBytesDelta: 0
          };
        }), t;
      }(t.gatewayClient), t.configDistributManager = function (e) {
        var t = {};
        return t.client = e, t.client.on("config-distribute", function (n) {
          var i = n.joinInfo,
              r = n.config;

          if (r) {
            se(r.uploadLog) || (Object(o.setParameter)("UPLOAD_LOG", r.uploadLog), a.b.reportApiInvoke(i.sid, {
              name: "_configDistribute",
              options: {
                feature: "uploadLog",
                value: r.uploadLog
              }
            })()), se(r.dualStream) || (e.isDualStream = r.dualStream, a.b.reportApiInvoke(i.sid, {
              name: "_configDistribute",
              options: {
                feature: "dualStream",
                value: r.dualStream
              }
            })()), se(r.streamFallbackOption) || t.client.on("stream-subscribed", function (e) {
              var n = e.stream;
              n ? (t.client.gatewayClient.setStreamFallbackOption(n, r.streamFallbackOption), a.b.reportApiInvoke(i.sid, {
                name: "_configDistribute",
                options: {
                  feature: "streamFallbackOption",
                  value: r.streamFallbackOption,
                  streamId: n.getId()
                }
              })()) : a.b.reportApiInvoke(i.sid, {
                name: "_configDistribute",
                options: {
                  feature: "streamFallbackOption",
                  value: r.streamFallbackOption,
                  streamId: n.getId(),
                  err: "invalid stream"
                }
              })();
            });

            try {
              Object.keys(r).map(function (e) {
                return Object(o.setParameter)(e, r[e]);
              });
            } catch (e) {}
          }
        }), t;
      }(t), se(e.turnServer) || t.setTurnServer(e.turnServer), se(e.proxyServer) || t.setProxyServer(e.proxyServer), "live" === t.mode && (t.gatewayClient.role = "audience"), "rtc" === t.mode && (t.gatewayClient.role = "host"), t.on("onMultiIP", function (e) {
        t.gatewayClient.closeGateway(), t.gatewayClient.socket = void 0, t.gatewayClient.hasChangeBGPAddress = !0, t.joinInfo.multiIP = e.arg.option, t.gatewayClient.state = He.CONNECTING;

        var n = function n(e) {
          r.default.info("[".concat(t.clientId, "] Joining channel: ").concat(t.channel)), t.joinInfo.cid = e.cid, t.joinInfo.uid || (t.joinInfo.uid = e.uid), t.joinInfo.uni_lbs_ip = e.uni_lbs_ip, t.joinInfo.gatewayAddr = e.gateway_addr, t.onSuccess ? t.gatewayClient.join(t.joinInfo, t.key, function (e) {
            r.default.info("[".concat(t.clientId, "] Join channel ").concat(t.channel, " success"));
            var n = t.onSuccess;
            t.onSuccess = null, t.onFailure = null, n(e);
          }, t.onFailure) : (t.gatewayClient.joinInfo = S()({}, t.joinInfo), t.gatewayClient.rejoin());
        };

        t.joinInfo.stringUid && !t.joinInfo.uid ? (self.userAccountReq && !self.userAccountReq.isFinished() && self.userAccountReq.cancel(), self.userAccountReq = Le(joinInfo), self.userAccountReq.then(function (e) {
          r.default.error("getUserAccount Success ".concat(e.url, " ").concat(joinInfo.stringUid, " => ").concat(e.uid)), t.joinInfo.uid = e.uid, ke(t.joinInfo, n, t.onFailure);
        }).catch(function (e) {
          r.default.error("getUserAccount rejected", e), t.onFailure(e);
        })) : ke(t.joinInfo, n, t.onFailure);
      }), t.on("rejoin-start", function () {
        t._renewSession(), a.b.sessionInit(e.sessionId, {
          lts: new Date().getTime(),
          extend: {
            rejoin: !0
          },
          cname: t.channel,
          appid: e.appId,
          mode: e.mode,
          succ: !0
        });
      }), t.on("recover", function () {
        t._renewSession(), a.b.sessionInit(e.sessionId, {
          lts: new Date().getTime(),
          extend: {
            recover: !0
          },
          cname: t.channel,
          appid: e.appId,
          mode: e.mode,
          succ: !0
        });
      }), t.on("rejoin", function () {
        var e = 2 === t.highStreamState ? 2 : 0;

        if (t.onSuccess) {
          var n = t.onSuccess;
          t.onSuccess = null, t.onFailure = null, n();
        }

        t.highStream && 0 === e && (r.default.info("[".concat(t.clientId, "] publish after rejoin")), t.highStreamState = 2, t.lowStreamState = 2, t.publish(t.highStream, function (e) {
          e && r.default.info("[".concat(t.clientId, "] "), e);
        }));
      }), t.on("streamPublished", function (e) {
        t.hasPublished || (t.hasPublished = !0, t.gatewayClient.dispatchEvent(d({
          type: "stream-published",
          stream: e.stream
        })));
      }), t.on("pubP2PLost", function (e) {
        r.default.debug("[".concat(t.clientId, "] Start reconnect local peerConnection: ").concat(t.highStream.getId())), t.gatewayClient.dispatchEvent({
          type: "stream-reconnect-start",
          uid: t.highStream.getId()
        }), 1 === t.highStreamState && (t.highStreamState = 0, t.lowStreamState = 0), t._unpublish(t.highStream, function () {
          t._publish(t.highStream, function () {
            r.default.debug("[".concat(t.clientId, "] Reconnect local peerConnection success: ").concat(t.highStream.getId())), t.gatewayClient.dispatchEvent({
              type: "stream-reconnect-end",
              uid: t.highStream.getId(),
              success: !0,
              reason: ""
            });
          }, function (e) {
            r.default.debug("[".concat(t.clientId, "] Reconnect local peerConnection failed: ").concat(e)), t.gatewayClient.dispatchEvent({
              type: "stream-reconnect-end",
              uid: t.highStream.getId(),
              success: !1,
              reason: e
            });
          });
        }, function (e) {
          r.default.debug("[".concat(t.clientId, "] Reconnect local peerConnection failed: ").concat(e)), t.gatewayClient.dispatchEvent({
            type: "stream-reconnect-end",
            uid: t.highStream.getId(),
            success: !1,
            reason: e
          });
        });
      }), t.on("subP2PLost", function (e) {
        r.default.debug("[".concat(t.clientId, "] Start reconnect remote peerConnection: ").concat(e.stream.getId())), t.gatewayClient.dispatchEvent({
          type: "stream-reconnect-start",
          uid: e.stream.getId()
        }), t.gatewayClient.unsubscribe(e.stream, function () {
          t.gatewayClient.subscribe(e.stream, function () {
            r.default.debug("[".concat(t.clientId, "] Reconnect remote peerConnection success: ").concat(e.stream.getId())), t.gatewayClient.dispatchEvent({
              type: "stream-reconnect-end",
              uid: e.stream.getId(),
              success: !1,
              reason: ""
            });
          }, function (n) {
            r.default.debug("[".concat(t.clientId, "] Reconnect remote peerConnection failed: "), n), t.gatewayClient.dispatchEvent({
              type: "stream-reconnect-end",
              uid: e.stream.getId(),
              success: !1,
              reason: n
            });
          });
        }, function (n) {
          r.default.debug("[".concat(t.clientId, "] \" + 'Reconnect remote peerConnection failed: "), n), t.gatewayClient.dispatchEvent({
            type: "stream-reconnect-end",
            uid: e.stream.getId(),
            success: !1,
            reason: n
          });
        });
      }), qe.on("networkTypeChanged", function (e) {
        t.gatewayClient && t.gatewayClient.dispatchEvent(e);
        var n = S()({}, e, {
          type: "network-type-changed"
        });
        t.gatewayClient.dispatchEvent(n);
      }), Y.on("recordingDeviceChanged", function (e) {
        t.gatewayClient && t.gatewayClient.dispatchEvent(e);
        var n = S()({}, e, {
          type: "recording-device-changed"
        });
        t.gatewayClient.dispatchEvent(n);
      }), Y.on("playoutDeviceChanged", function (e) {
        t.gatewayClient && t.gatewayClient.dispatchEvent(e);
        var n = S()({}, e, {
          type: "playout-device-changed"
        });
        t.gatewayClient.dispatchEvent(n);
      }), Y.on("cameraChanged", function (e) {
        t.gatewayClient && t.gatewayClient.dispatchEvent(e);
        var n = S()({}, e, {
          type: "camera-changed"
        });
        t.gatewayClient.dispatchEvent(n);
      }), t.gatewayClient.on("streamTypeChange", function (n) {
        var i = S()({}, n, {
          type: "stream-type-changed"
        });
        t.gatewayClient.dispatchEvent(i), a.b.reportApiInvoke(e.sessionId, {
          name: "streamTypeChange"
        })(null, JSON.stringify(n));
      }), t;
    },
        Xe = {
      width: 640,
      height: 360,
      videoBitrate: 400,
      videoFramerate: 15,
      lowLatency: !1,
      audioSampleRate: 48e3,
      audioBitrate: 48,
      audioChannels: 1,
      videoGop: 30,
      videoCodecProfile: 100,
      userCount: 0,
      userConfigExtraInfo: {},
      backgroundColor: 0,
      transcodingUsers: []
    },
        Qe = {
      width: 0,
      height: 0,
      videoGop: 30,
      videoFramerate: 15,
      videoBitrate: 400,
      audioSampleRate: 44100,
      audioBitrate: 48,
      audioChannels: 1
    },
        $e = Y.getDevices,
        Ze = U,
        et = JSON.parse(JSON.stringify(o.SUPPORT_RESOLUTION_LIST));

    t.default = {
      TranscodingUser: {
        uid: 0,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        zOrder: 0,
        alpha: 1
      },
      LiveTranscoding: Xe,
      createClient: function createClient(e) {
        var t = a.b.reportApiInvoke(null, {
          name: "createClient",
          options: arguments,
          tag: "tracer"
        });
        (e = S()({}, e || {})).codec || (e.codec = function (e) {
          switch (e) {
            case "h264_interop":
              return "h264";

            default:
              return "vp8";
          }
        }(e.mode));

        var n = function (e) {
          return -1 === me.indexOf(e.mode) ? A.INVALID_CLIENT_MODE : -1 === ge.indexOf(e.codec) ? A.INVALID_CLIENT_CODEC : "h264_interop" == e.mode && "h264" !== e.codec && A.CLIENT_MODE_CODEC_MISMATCH;
        }(e);

        if (n) throw r.default.error("Invalid parameter setting MODE: ".concat(e.mode, " CODEC: ").concat(e.codec, " ERROR ").concat(n)), t(n), new Error(n);
        return r.default.info("Creating client, MODE: ".concat(e.mode, " CODEC: ").concat(e.codec)), function (e) {
          switch (e.mode) {
            case "interop":
            case "h264_interop":
              e.mode = "live";
              break;

            case "web-only":
              e.mode = "rtc";
          }
        }(e), t(null, e), Ke(e);
      },
      createStream: function createStream(e) {
        var t = a.b.reportApiInvoke(null, {
          name: "createStream",
          options: arguments,
          tag: "tracer"
        });
        X(e, "StreamSpec");
        var n = e.streamID,
            i = e.audio,
            o = e.video,
            s = e.screen,
            c = (e.audioSource, e.videoSource, e.cameraId),
            d = e.microphoneId,
            u = e.mirror,
            l = e.extensionId,
            p = e.mediaSource,
            f = e.audioProcessing;
        if (!se(n) && !Object(G.c)(n) && !ee(n, 1, 255)) throw new Error("[String streamID] Length of the string: [1,255]. ASCII characters only. [Number streamID] The value range is Uint32");

        if (Z(i, "audio"), Z(o, "video"), se(s) || Z(s, "screen"), se(c) || Q(c, "cameraId", 0, 255, !1), se(d) || Q(d, "microphoneId", 0, 255, !1), se(l) || Q(l, "extensionId"), se(p) || K(p, "mediaSource", ["screen", "application", "window"]), se(u) || Z(u, "mirror"), !se(f)) {
          var m = f.AGC,
              g = f.AEC,
              v = f.ANS;
          se(m) || Z(m, "AGC"), se(g) || Z(g, "AEC"), se(v) || Z(v, "ANS");
        }

        r.default.debug("Create stream");
        var S = pe(e);
        return t(), S;
      },
      Logger: r.default,
      getDevices: $e,
      getScreenSources: Ze,
      getParameter: o.getParameter,
      setParameter: o.setParameter,
      checkSystemRequirements: function checkSystemRequirements() {
        var e = a.b.reportApiInvoke(null, {
          name: "checkSystemRequirements",
          options: arguments,
          tag: "tracer"
        }),
            t = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection,
            n = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia || navigator.mediaDevices && navigator.mediaDevices.getUserMedia,
            i = window.WebSocket,
            o = !!t && !!n && !!i,
            s = !1;
        r.default.debug(f.getBrowserInfo(), "isAPISupport:" + o), f.isChrome() && f.getBrowserVersion() >= 58 && "iOS" !== f.getBrowserOS() && (s = !0), f.isFireFox() && f.getBrowserVersion() >= 56 && (s = !0), f.isOpera() && f.getBrowserVersion() >= 45 && (s = !0), f.isSafari() && f.getBrowserVersion() >= 11 && (s = !0), f.isEdge() && (s = !0), (f.isWeChatBrowser() || f.isQQBrowser()) && "iOS" !== f.getBrowserOS() && (s = !0), f.isSupportedPC() || f.isSupportedMobile() || (s = !1);
        var c = o && s;
        return e(null, c), c;
      },
      getSupportedCodec: fe.getSupportedCodec,
      VERSION: o.VERSION,
      BUILD: o.BUILD,
      PROFILE_TABLE: et,
      AUDIO_SAMPLE_RATE_32000: 32e3,
      AUDIO_SAMPLE_RATE_44100: 44100,
      AUDIO_SAMPLE_RATE_48000: 48e3,
      VIDEO_CODEC_PROFILE_BASELINE: 66,
      VIDEO_CODEC_PROFILE_MAIN: 77,
      VIDEO_CODEC_PROFILE_HIGH: 100,
      REMOTE_VIDEO_STREAM_HIGH: 0,
      REMOTE_VIDEO_STREAM_LOW: 1,
      REMOTE_VIDEO_STREAM_MEDIUM: 2
    };
  }]).default;
});
},{}],"src/webAgora.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebAgora = void 0;

var _rtcKit = require("./rtcKit");

var _util = require("./util");

var _constants = require("./constants");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var AgoraRTC = require('./libs/AgoraRTCSDK-2.8.0');

var client = null;
var streams = {}; //AgoraRTC.Logger.disableLogUpload();

var WebAgora =
/*#__PURE__*/
function (_RtcKit) {
  _inherits(WebAgora, _RtcKit);

  function WebAgora(options) {
    var _this;

    _classCallCheck(this, WebAgora);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebAgora).call(this, options));
    _this.rtcName = 'web agora';
    _this.loggerColor = 'green';
    _this.timeId = null;
    return _this;
  }

  _createClass(WebAgora, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      if (!AgoraRTC.checkSystemRequirements()) {
        this.rtcCb({
          name: 'error',
          data: {
            msg: '初始化失败浏览器不支持WebRTC',
            code: this._code_enum_.MESSAGE_CODE_INIT
          }
        });
        return;
      }

      if (client) {
        this.rtcCb({
          name: 'error',
          data: {
            msg: '请不要重复实例化',
            code: this._code_enum_.MESSAGE_CODE_INIT
          }
        });
        return;
      }

      var localCid = localStorage.getItem('ss.media.video_source_id');
      var localMid = localStorage.getItem('ss.media.audio_source_id');
      AgoraRTC.getDevices(function (devices) {
        if (devices) {
          _this2.logger('getDevices', devices);

          for (var i = 0; i < devices.length; i++) {
            if (devices[i].deviceId === localCid) _this2.cameraId = localCid;
            if (devices[i].deviceId === localMid) _this2.microphoneId = localMid;
          }
        }

        _this2.logger('cameraId,microphoneId:', _this2.cameraId, _this2.microphoneId);

        client = AgoraRTC.createClient({
          mode: "live",
          codec: "vp8"
        });
        client.on('stream-published', function (evt) {
          _this2.logger("本地推流成功");

          _this2.rtcCb({
            name: 'stream-published',
            data: {
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        client.on('error', function (err) {
          _this2.logger("Got error msg:", err.reason);

          _this2.rtcCb({
            name: 'error',
            data: {
              msg: (0, _util.showErrorMsg)(err),
              code: _this2._code_enum_.MESSAGE_CODE_UNKONOWN
            }
          });
        });
        client.on('stream-added', function (evt) {
          var stream = evt.stream;

          _this2.logger("\u8FDC\u7AEF\u89C6\u9891\u6D41\u52A0\u5165: ".concat(stream.getId()));

          _this2.logger("\u5F00\u59CB\u8BA2\u9605\u89C6\u9891\u6D41: ".concat(stream.getId()));

          _this2.rtcCb({
            name: 'stream-added',
            data: {
              uid: stream.getId(),
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });

          client.subscribe(stream, function (err) {
            var msg = "\u8BA2\u9605\u5931\u8D25: ".concat((0, _util.showErrorMsg)(err));

            _this2.logger(msg);

            _this2.rtcCb({
              name: 'error',
              data: {
                msg: msg,
                code: _this2._code_enum_.MESSAGE_CODE_STREAM
              }
            });
          });
        });
        client.on('stream-subscribed', function (evt) {
          var stream = evt.stream;
          var id = stream.getId();

          _this2.logger("\u8BA2\u9605\u8FDC\u7AEF\u6D41\u6210\u529F: ".concat(id));

          streams[id] = stream;

          _this2.playById(id);

          _this2.rtcCb({
            name: 'stream-subscribed',
            data: {
              uid: id,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });

          _this2.rtcCb({
            name: 'RemoteJoin',
            data: {
              uid: id,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        client.on('stream-removed', function (evt) {
          var stream = evt.stream;
          stream.stop();
          delete streams[stream.getId()];

          _this2.logger("\u8FDC\u7AEF\u6D41\u88AB\u79FB\u9664 ".concat(stream.getId()));

          _this2.rtcCb({
            name: 'stream-removed',
            data: {
              uid: stream.getId(),
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        client.on('peer-leave', function (evt) {
          var stream = evt.stream;

          if (stream) {
            stream.stop();
            delete streams[evt.uid];

            _this2.logger("".concat(evt.uid, " \u79BB\u5F00\u623F\u95F4"));

            _this2.rtcCb({
              name: 'peer-leave',
              data: {
                uid: evt.uid,
                code: _this2._code_enum_.MESSAGE_CODE_ROOM
              }
            });
          }
        });
        client.on('network-quality', function (_ref) {
          var downlinkNetworkQuality = _ref.downlinkNetworkQuality,
              uplinkNetworkQuality = _ref.uplinkNetworkQuality;

          //this.logger('network-quality',a,b);
          _this2.rtcCb({
            name: 'NetQA',
            data: {
              rxQuality: downlinkNetworkQuality,
              txQuality: uplinkNetworkQuality,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        client.on("mute-audio", function (evt) {
          var uid = evt.uid;

          _this2.rtcCb({
            name: "mute_remote_audio",
            data: {
              uid: uid,
              mute: true,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        client.on("unmute-audio", function (evt) {
          var uid = evt.uid;

          _this2.rtcCb({
            name: "mute_remote_audio",
            data: {
              uid: uid,
              mute: false,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        client.on("mute-video", function (evt) {
          var uid = evt.uid;

          _this2.rtcCb({
            name: "mute_remote_video",
            data: {
              uid: uid,
              mute: true,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        client.on("unmute-video", function (evt) {
          var uid = evt.uid;

          _this2.rtcCb({
            name: "mute_remote_video",
            data: {
              uid: uid,
              mute: false,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        client.init(_constants.APP_ID, function () {
          _this2.logger('初始化成功');

          _this2.rtcCb({
            name: 'inited',
            data: {
              code: _this2._code_enum_.MESSAGE_CODE_INIT
            }
          });

          _this2.joinRoom();

          _this2._getVideoStatus_();
        }, function (err) {
          var msg = "\u521D\u59CB\u5316\u5931\u8D25: ".concat((0, _util.showErrorMsg)(err));

          _this2.logger(msg);

          _this2.rtcCb({
            name: 'error',
            data: {
              msg: msg,
              code: _this2._code_enum_.MESSAGE_CODE_INIT
            }
          });
        });
      });
    }
  }, {
    key: "_getVideoStatus_",
    value: function _getVideoStatus_() {
      var _this3 = this;

      if (this.timeId) {
        clearInterval(this.timeId);
        this.timeId = null;
      }

      this.timeId = setInterval(function () {
        _this3._getLocalVideoStats();

        _this3._getRemoteVideoStats();
      }, 3000);
    }
  }, {
    key: "joinRoom",
    value: function joinRoom() {
      var _this4 = this;

      var userId = this.uid;
      var roomId = this.roomId;
      var isWatcher = this.isWatcher;
      this.logger("\u7528\u6237:".concat(userId, " isWatcher:").concat(!!isWatcher, " \u6B63\u5728\u89C6\u56FE\u52A0\u5165\u623F\u95F4:").concat(roomId, "\u4E2D..."));
      client.join(null, roomId, userId, function (uid) {
        _this4.logger("\u7528\u6237 ".concat(uid, " \u52A0\u5165\u623F\u95F4\u6210\u529F"));

        _this4.rtcCb({
          name: 'room joined',
          data: {
            code: _this4._code_enum_.MESSAGE_CODE_ROOM
          }
        });

        if (!isWatcher) {
          var localStream = AgoraRTC.createStream({
            streamID: uid,
            audio: true,
            cameraId: _this4.cameraId,
            microphoneId: _this4.microphoneId,
            video: true,
            screen: false
          });
          streams[uid] = localStream;
          localStream.setVideoProfile('240P'); // The user has granted access to the camera and mic.

          localStream.on("accessAllowed", function () {
            _this4.logger("本地设备允许访问");

            _this4.rtcCb({
              name: 'accessAllowed',
              data: {
                code: _this4._code_enum_.MESSAGE_CODE_STREAM
              }
            });
          }); // The user has denied access to the camera and mic.

          localStream.on("accessDenied", function () {
            _this4.logger("本地设备拒绝访问");

            var msg = "本地设备拒绝访问";

            _this4.rtcCb({
              name: 'accessDenied',
              data: {
                msg: msg,
                code: _this4._code_enum_.MESSAGE_CODE_STREAM
              }
            });

            _this4.rtcCb({
              name: 'error',
              data: {
                msg: msg,
                name: 'onFirstLocalVideoFrame',
                code: _this4._code_enum_.MESSAGE_CODE_STREAM
              }
            });
          });
          localStream.init(function () {
            _this4.logger("本地化初始流第一帧成功");

            _this4.rtcCb({
              name: 'onFirstLocalVideoFrame',
              data: {
                code: _this4._code_enum_.MESSAGE_CODE_STREAM
              }
            }); //localStream.play('agora_local');


            _this4.playById(uid);

            client.publish(localStream, function (err) {
              var msg = "\u672C\u5730\u63A8\u6D41\u5931\u8D25: ".concat((0, _util.showErrorMsg)(err));

              _this4.logger(msg);

              _this4.rtcCb({
                name: 'error',
                data: {
                  msg: msg,
                  code: _this4._code_enum_.MESSAGE_CODE_STREAM
                }
              });
            });
          }, function (err) {
            var msg = "\u672C\u5730\u5316\u521D\u59CB\u6D41\u7B2C\u4E00\u5E27\u5931\u8D25: ".concat((0, _util.showErrorMsg)(err));

            _this4.logger(msg);

            _this4.rtcCb({
              name: 'error',
              data: {
                msg: msg,
                name: 'onFirstLocalVideoFrame',
                code: _this4._code_enum_.MESSAGE_CODE_STREAM
              }
            });
          });
        }
      }, function (err) {
        var msg = "\u52A0\u5165\u623F\u95F4\u5931\u8D25: ".concat((0, _util.showErrorMsg)(err));

        _this4.logger(msg);

        _this4.rtcCb({
          name: 'error',
          data: {
            msg: msg,
            code: _this4._code_enum_.MESSAGE_CODE_ROOM
          }
        });
      });
    }
  }, {
    key: "leaveRoom",
    value: function leaveRoom() {
      var _this5 = this;

      client && client.leave(function () {
        _this5.logger('离开房间成功');

        _this5.rtcCb({
          name: 'leave channel',
          data: {
            code: _this5._code_enum_.MESSAGE_CODE_ROOM
          }
        });
      }, function (err) {
        var msg = "\u79BB\u5F00\u623F\u95F4\u5931\u8D25".concat((0, _util.showErrorMsg)(err));

        _this5.logger(msg);

        _this5.rtcCb({
          name: 'error',
          data: {
            msg: msg,
            code: _this5._code_enum_.MESSAGE_CODE_ROOM
          }
        });
      });
      var localStream = streams[this.uid];

      if (localStream) {
        localStream.stop();
        localStream.close();
        delete streams[this.uid];
      }
    }
  }, {
    key: "playById",
    value: function playById(id) {
      var _this6 = this;

      (0, _util.waitFor)(function () {
        return streams[id] && _this6.document.getElementById("".concat(id));
      }).then(function () {
        if (streams[id].isPlaying()) {
          streams[id].stop();
        }

        streams[id].play("".concat(id));

        _this6.logger("playById ".concat(id));
      });
    }
  }, {
    key: "disableVideo",
    value: function disableVideo(_ref2) {
      var id = _ref2.id,
          flag = _ref2.flag;
      this.logger("disableVideo ".concat(id, " ").concat(flag));
      var stream = streams[id];
      if (!stream) return;

      if (flag) {
        stream.enableVideo(id);
      } else {
        stream.disableVideo(id);
      }
    }
  }, {
    key: "disableAudio",
    value: function disableAudio(_ref3) {
      var id = _ref3.id,
          flag = _ref3.flag;
      var stream = streams[id];
      if (!stream) return;

      if (flag) {
        stream.enableAudio();
      } else {
        stream.disableAudio();
      }
    }
  }, {
    key: "hideVideoById",
    value: function hideVideoById(id) {}
  }, {
    key: "showVideoById",
    value: function showVideoById(id) {}
  }, {
    key: "_getRemoteVideoStats",
    value: function _getRemoteVideoStats() {
      var _this7 = this;

      client && client.getRemoteVideoStats(function (remoteVideoStatsMap) {
        for (var uid in remoteVideoStatsMap) {
          _this7.logger(remoteVideoStatsMap[uid]);

          var _remoteVideoStatsMap$ = remoteVideoStatsMap[uid],
              RenderResolutionHeight = _remoteVideoStatsMap$.RenderResolutionHeight,
              RenderResolutionWidth = _remoteVideoStatsMap$.RenderResolutionWidth,
              RecvBitrate = _remoteVideoStatsMap$.RecvBitrate,
              RenderFrameRate = _remoteVideoStatsMap$.RenderFrameRate;
          var data = {
            name: 'RemoteVideoStats',
            data: {
              uid: uid,
              width: RenderResolutionWidth,
              // 视频宽度
              height: RenderResolutionHeight,
              // 视频宽度
              receivedBitrate: RecvBitrate,
              // 接收码率（Kbps）
              receivedFrameRate: RenderFrameRate,
              code: _this7._code_enum_.MESSAGE_CODE_STREAM
            }
          };

          _this7.rtcCb(data);
        }
      });
    }
  }, {
    key: "_getLocalVideoStats",
    value: function _getLocalVideoStats() {
      var _this8 = this;

      client && client.getLocalVideoStats(function (localVideoStats) {
        for (var uid in localVideoStats) {
          var _localVideoStats$uid = localVideoStats[uid],
              SendBitrate = _localVideoStats$uid.SendBitrate,
              SendFrameRate = _localVideoStats$uid.SendFrameRate;
          var data = {
            name: 'LocalVideoStats',
            data: {
              uid: uid,
              sentBitrate: SendBitrate,
              sentFrameRate: SendFrameRate,
              code: _this8._code_enum_.MESSAGE_CODE_STREAM
            }
          };

          _this8.rtcCb(data);
        }
      });
    }
  }, {
    key: "switchDevice",
    value: function switchDevice(deviceType, deviceId) {
      var stream = streams[this.uid];

      if (stream) {
        stream.switchDevice(deviceType, deviceId);
      }
    }
  }]);

  return WebAgora;
}(_rtcKit.RtcKit);

exports.WebAgora = WebAgora;
},{"./rtcKit":"src/rtcKit.js","./util":"src/util.js","./constants":"src/constants.js","./libs/AgoraRTCSDK-2.8.0":"src/libs/AgoraRTCSDK-2.8.0.js"}],"src/libs/erizo.js":[function(require,module,exports) {
var global = arguments[3];
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

try {
  var $jscomp = $jscomp || {};
  $jscomp.scope = {};
  $jscomp.ASSUME_ES5 = !1;
  $jscomp.ASSUME_NO_NATIVE_MAP = !1;
  $jscomp.ASSUME_NO_NATIVE_SET = !1;
  $jscomp.defineProperty = $jscomp.ASSUME_ES5 || "function" == typeof Object.defineProperties ? Object.defineProperty : function (p, r, n) {
    p != Array.prototype && p != Object.prototype && (p[r] = n.value);
  };

  $jscomp.getGlobal = function (p) {
    return "undefined" != typeof window && window === p ? p : "undefined" != typeof global && null != global ? global : p;
  };

  $jscomp.global = $jscomp.getGlobal(this);
  $jscomp.SYMBOL_PREFIX = "jscomp_symbol_";

  $jscomp.initSymbol = function () {
    $jscomp.initSymbol = function () {};

    $jscomp.global.Symbol || ($jscomp.global.Symbol = $jscomp.Symbol);
  };

  $jscomp.Symbol = function () {
    var p = 0;
    return function (r) {
      return $jscomp.SYMBOL_PREFIX + (r || "") + p++;
    };
  }();

  $jscomp.initSymbolIterator = function () {
    $jscomp.initSymbol();
    var p = $jscomp.global.Symbol.iterator;
    p || (p = $jscomp.global.Symbol.iterator = $jscomp.global.Symbol("iterator"));
    "function" != typeof Array.prototype[p] && $jscomp.defineProperty(Array.prototype, p, {
      configurable: !0,
      writable: !0,
      value: function value() {
        return $jscomp.arrayIterator(this);
      }
    });

    $jscomp.initSymbolIterator = function () {};
  };

  $jscomp.arrayIterator = function (p) {
    var r = 0;
    return $jscomp.iteratorPrototype(function () {
      return r < p.length ? {
        done: !1,
        value: p[r++]
      } : {
        done: !0
      };
    });
  };

  $jscomp.iteratorPrototype = function (p) {
    $jscomp.initSymbolIterator();
    p = {
      next: p
    };

    p[$jscomp.global.Symbol.iterator] = function () {
      return this;
    };

    return p;
  };

  $jscomp.makeIterator = function (p) {
    $jscomp.initSymbolIterator();
    var r = p[Symbol.iterator];
    return r ? r.call(p) : $jscomp.arrayIterator(p);
  };

  $jscomp.arrayFromIterator = function (p) {
    for (var r, n = []; !(r = p.next()).done;) {
      n.push(r.value);
    }

    return n;
  };

  $jscomp.arrayFromIterable = function (p) {
    return p instanceof Array ? p : $jscomp.arrayFromIterator($jscomp.makeIterator(p));
  };

  $jscomp.iteratorFromArray = function (p, r) {
    $jscomp.initSymbolIterator();
    p instanceof String && (p += "");
    var n = 0,
        h = {
      next: function next() {
        if (n < p.length) {
          var k = n++;
          return {
            value: r(k, p[k]),
            done: !1
          };
        }

        h.next = function () {
          return {
            done: !0,
            value: void 0
          };
        };

        return h.next();
      }
    };

    h[Symbol.iterator] = function () {
      return h;
    };

    return h;
  };

  $jscomp.polyfill = function (p, r, n, h) {
    if (r) {
      n = $jscomp.global;
      p = p.split(".");

      for (h = 0; h < p.length - 1; h++) {
        var k = p[h];
        k in n || (n[k] = {});
        n = n[k];
      }

      p = p[p.length - 1];
      h = n[p];
      r = r(h);
      r != h && null != r && $jscomp.defineProperty(n, p, {
        configurable: !0,
        writable: !0,
        value: r
      });
    }
  };

  $jscomp.polyfill("Array.prototype.keys", function (p) {
    return p ? p : function () {
      return $jscomp.iteratorFromArray(this, function (p) {
        return p;
      });
    };
  }, "es6", "es3");

  $jscomp.findInternal = function (p, r, n) {
    p instanceof String && (p = String(p));

    for (var h = p.length, k = 0; k < h; k++) {
      var e = p[k];
      if (r.call(n, e, k, p)) return {
        i: k,
        v: e
      };
    }

    return {
      i: -1,
      v: void 0
    };
  };

  $jscomp.polyfill("Array.prototype.find", function (p) {
    return p ? p : function (p, n) {
      return $jscomp.findInternal(this, p, n).v;
    };
  }, "es6", "es3");

  $jscomp.owns = function (p, r) {
    return Object.prototype.hasOwnProperty.call(p, r);
  };

  $jscomp.polyfill("WeakMap", function (p) {
    function r(d) {
      $jscomp.owns(d, h) || $jscomp.defineProperty(d, h, {
        value: {}
      });
    }

    function n(d) {
      var c = Object[d];
      c && (Object[d] = function (d) {
        r(d);
        return c(d);
      });
    }

    if (function () {
      if (!p || !Object.seal) return !1;

      try {
        var d = Object.seal({}),
            c = Object.seal({}),
            g = new p([[d, 2], [c, 3]]);
        if (2 != g.get(d) || 3 != g.get(c)) return !1;
        g.delete(d);
        g.set(c, 4);
        return !g.has(d) && 4 == g.get(c);
      } catch (a) {
        return !1;
      }
    }()) return p;
    var h = "$jscomp_hidden_" + Math.random().toString().substring(2);
    n("freeze");
    n("preventExtensions");
    n("seal");

    var k = 0,
        e = function e(d) {
      this.id_ = (k += Math.random() + 1).toString();

      if (d) {
        $jscomp.initSymbol();
        $jscomp.initSymbolIterator();
        d = $jscomp.makeIterator(d);

        for (var c; !(c = d.next()).done;) {
          c = c.value, this.set(c[0], c[1]);
        }
      }
    };

    e.prototype.set = function (d, c) {
      r(d);
      if (!$jscomp.owns(d, h)) throw Error("WeakMap key fail: " + d);
      d[h][this.id_] = c;
      return this;
    };

    e.prototype.get = function (d) {
      return $jscomp.owns(d, h) ? d[h][this.id_] : void 0;
    };

    e.prototype.has = function (d) {
      return $jscomp.owns(d, h) && $jscomp.owns(d[h], this.id_);
    };

    e.prototype.delete = function (d) {
      return $jscomp.owns(d, h) && $jscomp.owns(d[h], this.id_) ? delete d[h][this.id_] : !1;
    };

    return e;
  }, "es6", "es3");

  $jscomp.MapEntry = function () {};

  $jscomp.polyfill("Map", function (p) {
    if (!$jscomp.ASSUME_NO_NATIVE_MAP && function () {
      if (!p || !p.prototype.entries || "function" != typeof Object.seal) return !1;

      try {
        var c = Object.seal({
          x: 4
        }),
            d = new p($jscomp.makeIterator([[c, "s"]]));
        if ("s" != d.get(c) || 1 != d.size || d.get({
          x: 4
        }) || d.set({
          x: 4
        }, "t") != d || 2 != d.size) return !1;
        var a = d.entries(),
            b = a.next();
        if (b.done || b.value[0] != c || "s" != b.value[1]) return !1;
        b = a.next();
        return b.done || 4 != b.value[0].x || "t" != b.value[1] || !a.next().done ? !1 : !0;
      } catch (q) {
        return !1;
      }
    }()) return p;
    $jscomp.initSymbol();
    $jscomp.initSymbolIterator();

    var r = new WeakMap(),
        n = function n(c) {
      this.data_ = {};
      this.head_ = e();
      this.size = 0;

      if (c) {
        c = $jscomp.makeIterator(c);

        for (var d; !(d = c.next()).done;) {
          d = d.value, this.set(d[0], d[1]);
        }
      }
    };

    n.prototype.set = function (c, d) {
      var a = h(this, c);
      a.list || (a.list = this.data_[a.id] = []);
      a.entry ? a.entry.value = d : (a.entry = {
        next: this.head_,
        previous: this.head_.previous,
        head: this.head_,
        key: c,
        value: d
      }, a.list.push(a.entry), this.head_.previous.next = a.entry, this.head_.previous = a.entry, this.size++);
      return this;
    };

    n.prototype.delete = function (c) {
      c = h(this, c);
      return c.entry && c.list ? (c.list.splice(c.index, 1), c.list.length || delete this.data_[c.id], c.entry.previous.next = c.entry.next, c.entry.next.previous = c.entry.previous, c.entry.head = null, this.size--, !0) : !1;
    };

    n.prototype.clear = function () {
      this.data_ = {};
      this.head_ = this.head_.previous = e();
      this.size = 0;
    };

    n.prototype.has = function (c) {
      return !!h(this, c).entry;
    };

    n.prototype.get = function (c) {
      return (c = h(this, c).entry) && c.value;
    };

    n.prototype.entries = function () {
      return k(this, function (c) {
        return [c.key, c.value];
      });
    };

    n.prototype.keys = function () {
      return k(this, function (c) {
        return c.key;
      });
    };

    n.prototype.values = function () {
      return k(this, function (c) {
        return c.value;
      });
    };

    n.prototype.forEach = function (c, d) {
      for (var a = this.entries(), b; !(b = a.next()).done;) {
        b = b.value, c.call(d, b[1], b[0], this);
      }
    };

    n.prototype[Symbol.iterator] = n.prototype.entries;

    var h = function h(c, g) {
      var a = g && _typeof(g);

      "object" == a || "function" == a ? r.has(g) ? a = r.get(g) : (a = "" + ++d, r.set(g, a)) : a = "p_" + g;
      var b = c.data_[a];
      if (b && $jscomp.owns(c.data_, a)) for (c = 0; c < b.length; c++) {
        var q = b[c];
        if (g !== g && q.key !== q.key || g === q.key) return {
          id: a,
          list: b,
          index: c,
          entry: q
        };
      }
      return {
        id: a,
        list: b,
        index: -1,
        entry: void 0
      };
    },
        k = function k(c, d) {
      var a = c.head_;
      return $jscomp.iteratorPrototype(function () {
        if (a) {
          for (; a.head != c.head_;) {
            a = a.previous;
          }

          for (; a.next != a.head;) {
            return a = a.next, {
              done: !1,
              value: d(a)
            };
          }

          a = null;
        }

        return {
          done: !0,
          value: void 0
        };
      });
    },
        e = function e() {
      var c = {};
      return c.previous = c.next = c.head = c;
    },
        d = 0;

    return n;
  }, "es6", "es3");
  $jscomp.FORCE_POLYFILL_PROMISE = !1;
  $jscomp.polyfill("Promise", function (p) {
    function r() {
      this.batch_ = null;
    }

    function n(d) {
      return d instanceof k ? d : new k(function (c, g) {
        c(d);
      });
    }

    if (p && !$jscomp.FORCE_POLYFILL_PROMISE) return p;

    r.prototype.asyncExecute = function (d) {
      null == this.batch_ && (this.batch_ = [], this.asyncExecuteBatch_());
      this.batch_.push(d);
      return this;
    };

    r.prototype.asyncExecuteBatch_ = function () {
      var d = this;
      this.asyncExecuteFunction(function () {
        d.executeBatch_();
      });
    };

    var h = $jscomp.global.setTimeout;

    r.prototype.asyncExecuteFunction = function (d) {
      h(d, 0);
    };

    r.prototype.executeBatch_ = function () {
      for (; this.batch_ && this.batch_.length;) {
        var d = this.batch_;
        this.batch_ = [];

        for (var c = 0; c < d.length; ++c) {
          var g = d[c];
          delete d[c];

          try {
            g();
          } catch (a) {
            this.asyncThrow_(a);
          }
        }
      }

      this.batch_ = null;
    };

    r.prototype.asyncThrow_ = function (d) {
      this.asyncExecuteFunction(function () {
        throw d;
      });
    };

    var k = function k(d) {
      this.state_ = 0;
      this.result_ = void 0;
      this.onSettledCallbacks_ = [];
      var c = this.createResolveAndReject_();

      try {
        d(c.resolve, c.reject);
      } catch (g) {
        c.reject(g);
      }
    };

    k.prototype.createResolveAndReject_ = function () {
      function d(a) {
        return function (b) {
          g || (g = !0, a.call(c, b));
        };
      }

      var c = this,
          g = !1;
      return {
        resolve: d(this.resolveTo_),
        reject: d(this.reject_)
      };
    };

    k.prototype.resolveTo_ = function (d) {
      if (d === this) this.reject_(new TypeError("A Promise cannot resolve to itself"));else if (d instanceof k) this.settleSameAsPromise_(d);else {
        a: switch (_typeof(d)) {
          case "object":
            var c = null != d;
            break a;

          case "function":
            c = !0;
            break a;

          default:
            c = !1;
        }

        c ? this.resolveToNonPromiseObj_(d) : this.fulfill_(d);
      }
    };

    k.prototype.resolveToNonPromiseObj_ = function (d) {
      var c = void 0;

      try {
        c = d.then;
      } catch (g) {
        this.reject_(g);
        return;
      }

      "function" == typeof c ? this.settleSameAsThenable_(c, d) : this.fulfill_(d);
    };

    k.prototype.reject_ = function (d) {
      this.settle_(2, d);
    };

    k.prototype.fulfill_ = function (d) {
      this.settle_(1, d);
    };

    k.prototype.settle_ = function (d, c) {
      if (0 != this.state_) throw Error("Cannot settle(" + d + ", " + c | "): Promise already settled in state" + this.state_);
      this.state_ = d;
      this.result_ = c;
      this.executeOnSettledCallbacks_();
    };

    k.prototype.executeOnSettledCallbacks_ = function () {
      if (null != this.onSettledCallbacks_) {
        for (var d = this.onSettledCallbacks_, c = 0; c < d.length; ++c) {
          d[c].call(), d[c] = null;
        }

        this.onSettledCallbacks_ = null;
      }
    };

    var e = new r();

    k.prototype.settleSameAsPromise_ = function (d) {
      var c = this.createResolveAndReject_();
      d.callWhenSettled_(c.resolve, c.reject);
    };

    k.prototype.settleSameAsThenable_ = function (d, c) {
      var g = this.createResolveAndReject_();

      try {
        d.call(c, g.resolve, g.reject);
      } catch (a) {
        g.reject(a);
      }
    };

    k.prototype.then = function (d, c) {
      function g(c, d) {
        return "function" == typeof c ? function (d) {
          try {
            a(c(d));
          } catch (t) {
            b(t);
          }
        } : d;
      }

      var a,
          b,
          q = new k(function (c, d) {
        a = c;
        b = d;
      });
      this.callWhenSettled_(g(d, a), g(c, b));
      return q;
    };

    k.prototype.catch = function (d) {
      return this.then(void 0, d);
    };

    k.prototype.callWhenSettled_ = function (d, c) {
      function g() {
        switch (a.state_) {
          case 1:
            d(a.result_);
            break;

          case 2:
            c(a.result_);
            break;

          default:
            throw Error("Unexpected state: " + a.state_);
        }
      }

      var a = this;
      null == this.onSettledCallbacks_ ? e.asyncExecute(g) : this.onSettledCallbacks_.push(function () {
        e.asyncExecute(g);
      });
    };

    k.resolve = n;

    k.reject = function (d) {
      return new k(function (c, g) {
        g(d);
      });
    };

    k.race = function (d) {
      return new k(function (c, g) {
        for (var a = $jscomp.makeIterator(d), b = a.next(); !b.done; b = a.next()) {
          n(b.value).callWhenSettled_(c, g);
        }
      });
    };

    k.all = function (d) {
      var c = $jscomp.makeIterator(d),
          g = c.next();
      return g.done ? n([]) : new k(function (a, b) {
        function d(b) {
          return function (c) {
            m[b] = c;
            l--;
            0 == l && a(m);
          };
        }

        var m = [],
            l = 0;

        do {
          m.push(void 0), l++, n(g.value).callWhenSettled_(d(m.length - 1), b), g = c.next();
        } while (!g.done);
      });
    };

    return k;
  }, "es6", "es3");
  $jscomp.polyfill("Object.assign", function (p) {
    return p ? p : function (p, n) {
      for (var h = 1; h < arguments.length; h++) {
        var k = arguments[h];
        if (k) for (var e in k) {
          $jscomp.owns(k, e) && (p[e] = k[e]);
        }
      }

      return p;
    };
  }, "es6", "es3");

  var Erizo = window.Erizo = function (p) {
    function r(h) {
      if (n[h]) return n[h].exports;
      var k = n[h] = {
        i: h,
        l: !1,
        exports: {}
      };
      p[h].call(k.exports, k, k.exports, r);
      k.l = !0;
      return k.exports;
    }

    var n = {};
    r.m = p;
    r.c = n;

    r.d = function (h, k, e) {
      r.o(h, k) || Object.defineProperty(h, k, {
        configurable: !1,
        enumerable: !0,
        get: e
      });
    };

    r.n = function (h) {
      var k = h && h.__esModule ? function () {
        return h["default"];
      } : function () {
        return h;
      };
      r.d(k, "a", k);
      return k;
    };

    r.o = function (h, k) {
      return Object.prototype.hasOwnProperty.call(h, k);
    };

    r.p = "";
    return r(r.s = 9);
  }([function (p, r, n) {
    var h = function () {
      var k = "";

      var e = function e(d) {
        console.log.apply(console, [].concat($jscomp.arrayFromIterable(d)));
      };

      return {
        DEBUG: 0,
        TRACE: 1,
        INFO: 2,
        WARNING: 3,
        ERROR: 4,
        NONE: 5,
        setLogLevel: function setLogLevel(d) {
          var c = d;
          d > h.NONE ? c = h.NONE : d < h.DEBUG && (c = h.DEBUG);
          h.logLevel = c;
        },
        setOutputFunction: function setOutputFunction(d) {
          e = d;
        },
        setLogPrefix: function setLogPrefix(d) {
          k = d;
        },
        log: function log(d, c) {
          for (var g = [], a = 1; a < arguments.length; ++a) {
            g[a - 1] = arguments[a];
          }

          a = k;
          if (!(d < h.logLevel)) if (d === h.DEBUG ? a += "DEBUG" : d === h.TRACE ? a += "TRACE" : d === h.INFO ? a += "INFO" : d === h.WARNING ? a += "WARNING" : d === h.ERROR && (a += "ERROR"), g = [a + ": "].concat(g), void 0 !== h.panel) {
            a = "";

            for (var b = 0; b < g.length; b += 1) {
              a += g[b];
            }

            h.panel.value = h.panel.value + "\n" + a;
          } else e.apply(h, [g]);
        },
        debug: function debug(d) {
          for (var c = [], g = 0; g < arguments.length; ++g) {
            c[g - 0] = arguments[g];
          }

          h.log.apply(h, [].concat([h.DEBUG], $jscomp.arrayFromIterable(c)));
        },
        trace: function trace(d) {
          for (var c = [], g = 0; g < arguments.length; ++g) {
            c[g - 0] = arguments[g];
          }

          h.log.apply(h, [].concat([h.TRACE], $jscomp.arrayFromIterable(c)));
        },
        info: function info(d) {
          for (var c = [], g = 0; g < arguments.length; ++g) {
            c[g - 0] = arguments[g];
          }

          h.log.apply(h, [].concat([h.INFO], $jscomp.arrayFromIterable(c)));
        },
        warning: function warning(d) {
          for (var c = [], g = 0; g < arguments.length; ++g) {
            c[g - 0] = arguments[g];
          }

          h.log.apply(h, [].concat([h.WARNING], $jscomp.arrayFromIterable(c)));
        },
        error: function error(d) {
          for (var c = [], g = 0; g < arguments.length; ++g) {
            c[g - 0] = arguments[g];
          }

          h.log.apply(h, [].concat([h.ERROR], $jscomp.arrayFromIterable(c)));
        }
      };
    }();

    r.a = h;
  }, function (p, r, n) {
    n.d(r, "a", function () {
      return k;
    });
    n.d(r, "b", function () {
      return e;
    });
    n.d(r, "c", function () {
      return d;
    });
    n.d(r, "d", function () {
      return c;
    });

    var h = n(0),
        k = function k() {
      var c = {},
          a = {};

      c.addEventListener = function (b, c) {
        void 0 === a[b] && (a[b] = []);
        a[b].push(c);
      };

      c.removeEventListener = function (b, c) {
        a[b] && (c = a[b].indexOf(c), -1 !== c && a[b].splice(c, 1));
      };

      c.dispatchEvent = function (b) {
        if (!b || !b.type) throw Error("Undefined event");
        h.a.debug("Event: " + b.type);

        for (var c = a[b.type] || [], d = 0; d < c.length; d += 1) {
          c[d](b);
        }
      };

      c.on = c.addEventListener;
      c.off = c.removeEventListener;
      c.emit = c.dispatchEvent;
      return c;
    },
        e = function e(c) {
      var a = {};
      a.type = c.type;
      return a;
    },
        d = function d(c) {
      var a = e(c);
      a.streams = c.streams;
      a.message = c.message;
      return a;
    },
        c = function c(_c) {
      var a = e(_c);
      a.stream = _c.stream;
      a.msg = _c.msg;
      a.bandwidth = _c.bandwidth;
      return a;
    };
  }, function (p, r, n) {
    var h = n(1);

    r.a = function () {
      var k = Object(h.a)({});
      k.url = "";
      return k;
    };
  }, function (p, r, n) {
    (function (h) {
      var k = n(12),
          e = n(13),
          d = n(14),
          c = n(0),
          g = 103,
          a = function a() {
        var a = "none";
        "undefined" !== typeof h && h.exports ? a = "fake" : null !== window.navigator.userAgent.match("Firefox") ? a = "mozilla" : null !== window.navigator.userAgent.match("Chrome") ? (a = "chrome-stable", null !== window.navigator.userAgent.match("Electron") && (a = "electron")) : null !== window.navigator.userAgent.match("Safari") ? a = "safari" : null !== window.navigator.userAgent.match("AppleWebKit") && (a = "safari");
        return a;
      };

      r.a = {
        GetUserMedia: function GetUserMedia(b, d, g) {
          d = void 0 === d ? function () {} : d;
          g = void 0 === g ? function () {} : g;

          var l,
              e = function e(f, a, b) {
            navigator.mediaDevices.getUserMedia(f).then(a).catch(b);
          },
              q = function q() {
            c.a.debug("Screen access requested");

            switch (a()) {
              case "electron":
                c.a.debug("Screen sharing in Electron");
                l = {};
                l.video = b.video || {};
                l.video.mandatory = b.video.mandatory || {};
                l.video.mandatory.chromeMediaSource = "screen";
                e(l, d, g);
                break;

              case "mozilla":
                c.a.debug("Screen sharing in Firefox");
                l = {};
                void 0 !== b.video ? (l.video = b.video, l.video.mediaSource = "window") : l = {
                  audio: b.audio,
                  video: {
                    mediaSource: "window"
                  }
                };
                e(l, d, g);
                break;

              case "chrome-stable":
                c.a.debug("Screen sharing in Chrome");
                l = {};
                if (b.desktopStreamId) l.video = b.video || {
                  mandatory: {}
                }, l.video.mandatory = l.video.mandatory || {}, l.video.mandatory.chromeMediaSource = "desktop", l.video.mandatory.chromeMediaSourceId = b.desktopStreamId, e(l, d, g);else {
                  var f = "okeephmleflklcdebijnponpabbmmgeo";
                  b.extensionId && (c.a.debug("extensionId supplied, using " + b.extensionId), f = b.extensionId);
                  c.a.debug("Screen access on chrome stable, looking for extension");

                  try {
                    chrome.runtime.sendMessage(f, {
                      getStream: !0
                    }, function (a) {
                      void 0 === a ? (c.a.error("Access to screen denied"), g({
                        code: "Access to screen denied"
                      })) : (a = a.streamId, void 0 !== b.video.mandatory ? (l.video = b.video, l.video.mandatory.chromeMediaSource = "desktop", l.video.mandatory.chromeMediaSourceId = a) : l = {
                        video: {
                          mandatory: {
                            chromeMediaSource: "desktop",
                            chromeMediaSourceId: a
                          }
                        }
                      }, e(l, d, g));
                    });
                  } catch (u) {
                    c.a.debug("Screensharing plugin is not accessible "), g({
                      code: "no_plugin_present"
                    });
                  }
                }
                break;

              default:
                c.a.error("This browser does not support ScreenSharing");
            }
          };

          b.screen ? q() : "undefined" !== typeof h && h.exports ? c.a.error("Video/audio streams not supported in erizofc yet") : (c.a.debug("Calling getUserMedia with config", b), e(b, d, g));
        },
        buildConnection: function buildConnection(b) {
          var q = {};
          g += 1;
          b.sessionId = g;
          q.browser = a();
          if ("fake" === q.browser) c.a.warning("Publish/subscribe video/audio streams not supported in erizofc yet"), q = Object(d.a)(b);else if ("mozilla" === q.browser) c.a.debug("Firefox Stack"), q = Object(e.a)(b);else if ("safari" === q.browser) c.a.debug("Safari using Firefox Stack"), q = Object(e.a)(b);else if ("chrome-stable" === q.browser || "electron" === q.browser) c.a.debug("Chrome Stable Stack"), q = Object(k.a)(b);else throw c.a.error("No stack available for this browser"), Error("WebRTC stack not available");
          q.updateSpec || (q.updateSpec = function (a, b) {
            b = void 0 === b ? function () {} : b;
            c.a.error("Update Configuration not implemented in this browser");
            b("unimplemented");
          });
          return q;
        },
        getBrowser: a
      };
    }).call(r, n(11)(p));
  }, function (p, r, n) {
    var h = n(5),
        k = n(0);

    r.a = function (e) {
      var d = {},
          c,
          g;
      k.a.info("Starting Base stack", e);
      d.pcConfig = {
        iceServers: []
      };
      d.con = {};
      void 0 !== e.iceServers && (d.pcConfig.iceServers = e.iceServers);
      void 0 === e.audio && (e.audio = !0);
      void 0 === e.video && (e.video = !0);
      e.remoteCandidates = [];
      e.localCandidates = [];
      e.remoteDescriptionSet = !1;
      d.mediaConstraints = {
        offerToReceiveVideo: void 0 !== e.video && !1 !== e.video,
        offerToReceiveAudio: void 0 !== e.audio && !1 !== e.audio
      };
      d.peerConnection = new RTCPeerConnection(d.pcConfig, d.con);

      var a = function a(_a, f, b) {
        k.a.error("message:", b, "in baseStack at", _a);
        void 0 !== f && f("error");
      },
          b = function b(a) {
        k.a.info("Success in BaseStack", a);
      },
          q = function q(a, f) {
        c = f;
        a || (c.sdp = d.enableSimulcast(c.sdp));
        c.sdp = h.a.setMaxBW(c.sdp, e);
        e.callback({
          type: c.type,
          sdp: c.sdp
        });
      },
          m = function m(g) {
        c = g;
        c.sdp = h.a.setMaxBW(c.sdp, e);
        e.callback({
          type: c.type,
          sdp: c.sdp
        });
        k.a.info("Setting local description p2p", c);
        d.peerConnection.setLocalDescription(c).then(b).catch(a);
      },
          l = function l(b) {
        b.sdp = h.a.setMaxBW(b.sdp, e);
        d.peerConnection.setRemoteDescription(b).then(function () {
          d.peerConnection.createAnswer(d.mediaConstraints).then(m).catch(a.bind(null, "createAnswer p2p", void 0));
          e.remoteDescriptionSet = !0;
        }).catch(a.bind(null, "process Offer", void 0));
      },
          v = function v(b) {
        k.a.info("Set remote and local description");
        k.a.debug("Remote Description", b.sdp);
        k.a.debug("Local Description", c.sdp);
        b.sdp = h.a.setMaxBW(b.sdp, e);
        g = b;
        d.peerConnection.setLocalDescription(c).then(function () {
          d.peerConnection.setRemoteDescription(new RTCSessionDescription(b)).then(function () {
            e.remoteDescriptionSet = !0;

            for (k.a.info("Candidates to be added: ", e.remoteCandidates.length, e.remoteCandidates); 0 < e.remoteCandidates.length;) {
              d.peerConnection.addIceCandidate(e.remoteCandidates.shift());
            }

            for (k.a.info("Local candidates to send:", e.localCandidates.length); 0 < e.localCandidates.length;) {
              e.callback({
                type: "candidate",
                candidate: e.localCandidates.shift()
              });
            }
          }).catch(a.bind(null, "processAnswer", void 0));
        }).catch(a.bind(null, "processAnswer", void 0));
      };

      d.peerConnection.onicecandidate = function (a) {
        (a = a.candidate) ? (a.candidate.match(/a=/) || (a.candidate = "a\x3d" + a.candidate), a = {
          sdpMLineIndex: a.sdpMLineIndex,
          sdpMid: a.sdpMid,
          candidate: a.candidate
        }) : (k.a.info("Gathered all candidates. Sending END candidate"), a = {
          sdpMLineIndex: -1,
          sdpMid: "end",
          candidate: "end"
        });
        e.remoteDescriptionSet ? e.callback({
          type: "candidate",
          candidate: a
        }) : (e.localCandidates.push(a), k.a.info("Storing candidate: ", e.localCandidates.length, a));
      };

      d.peerConnection.onaddstream = function (a) {
        if (d.onaddstream) d.onaddstream(a);
      };

      d.peerConnection.onremovestream = function (a) {
        if (d.onremovestream) d.onremovestream(a);
      };

      d.peerConnection.oniceconnectionstatechange = function (a) {
        if (d.oniceconnectionstatechange) d.oniceconnectionstatechange(a.target.iceConnectionState);
      };

      d.enableSimulcast = function (a) {
        k.a.error("Simulcast not implemented");
        return a;
      };

      d.close = function () {
        d.state = "closed";
        d.peerConnection.close();
      };

      d.updateSpec = function (b, f) {
        f = void 0 === f ? function () {} : f;
        if (b.maxVideoBW || b.maxAudioBW) b.maxVideoBW && (k.a.debug("Maxvideo Requested:", b.maxVideoBW, "limit:", e.limitMaxVideoBW), b.maxVideoBW > e.limitMaxVideoBW && (b.maxVideoBW = e.limitMaxVideoBW), e.maxVideoBW = b.maxVideoBW, k.a.debug("Result", e.maxVideoBW)), b.maxAudioBW && (b.maxAudioBW > e.limitMaxAudioBW && (b.maxAudioBW = e.limitMaxAudioBW), e.maxAudioBW = b.maxAudioBW), c.sdp = h.a.setMaxBW(c.sdp, e), b.Sdp || b.maxAudioBW ? (k.a.debug("Updating with SDP renegotiation", e.maxVideoBW, e.maxAudioBW), d.peerConnection.setLocalDescription(c).then(function () {
          g.sdp = h.a.setMaxBW(g.sdp, e);
          d.peerConnection.setRemoteDescription(new RTCSessionDescription(g)).then(function () {
            e.remoteDescriptionSet = !0;
            e.callback({
              type: "updatestream",
              sdp: c.sdp
            });
          }).catch(a.bind(null, "updateSpec", void 0));
        }).catch(a.bind(null, "updateSpec", f))) : (k.a.debug("Updating without SDP renegotiation, newVideoBW:", e.maxVideoBW, "newAudioBW:", e.maxAudioBW), e.callback({
          type: "updatestream",
          sdp: c.sdp
        }));
        if (b.minVideoBW || void 0 !== b.slideShowMode || void 0 !== b.muteStream || void 0 !== b.qualityLayer) k.a.debug("MinVideo Changed to ", b.minVideoBW), k.a.debug("SlideShowMode Changed to ", b.slideShowMode), k.a.debug("muteStream changed to ", b.muteStream), e.callback({
          type: "updatestream",
          config: b
        });
      };

      d.createOffer = function (b) {
        !0 !== b && (d.mediaConstraints = {
          offerToReceiveVideo: !1,
          offerToReceiveAudio: !1
        });
        k.a.debug("Creating offer", d.mediaConstraints);
        d.peerConnection.createOffer(d.mediaConstraints).then(q.bind(null, b)).catch(a.bind(null, "Create Offer", void 0));
      };

      d.addStream = function (a) {
        d.peerConnection.addStream(a);
      };

      d.processSignalingMessage = function (a) {
        if ("offer" === a.type) l(a);else if ("answer" === a.type) v(a);else if ("candidate" === a.type) try {
          var f = "object" === _typeof(a.candidate) ? a.candidate : JSON.parse(a.candidate);

          if ("end" !== f.candidate) {
            f.candidate = f.candidate.replace(/a=/g, "");
            f.sdpMLineIndex = parseInt(f.sdpMLineIndex, 10);
            var b = new RTCIceCandidate(f);
            e.remoteDescriptionSet ? d.peerConnection.addIceCandidate(b) : e.remoteCandidates.push(b);
          }
        } catch (x) {
          k.a.error("Error parsing candidate", a.candidate);
        }
      };

      return d;
    };
  }, function (p, r, n) {
    r.a = {
      addSim: function addSim(h) {
        var k = "a\x3dssrc-group:SIM";
        h.forEach(function (e) {
          k += " " + e;
        });
        return k + "\r\n";
      },
      addGroup: function addGroup(h, k) {
        return "a\x3dssrc-group:FID " + h + " " + k + "\r\n";
      },
      addSpatialLayer: function addSpatialLayer(h, k, e, d, c, g) {
        return "a\x3dssrc:" + c + " cname:" + h + "\r\n" + ("a\x3dssrc:" + c + " msid:" + k + "\r\n") + ("a\x3dssrc:" + c + " mslabel:" + e + "\r\n") + ("a\x3dssrc:" + c + " label:" + d + "\r\n") + ("a\x3dssrc:" + g + " cname:" + h + "\r\n") + ("a\x3dssrc:" + g + " msid:" + k + "\r\n") + ("a\x3dssrc:" + g + " mslabel:" + e + "\r\n") + ("a\x3dssrc:" + g + " label:" + d + "\r\n");
      },
      setMaxBW: function setMaxBW(h, k) {
        var e = h;

        if (k.video && k.maxVideoBW) {
          e = e.replace(/b=AS:.*\r\n/g, "");
          var d = e.match(/m=video.*\r\n/);
          null == d && (d = e.match(/m=video.*\n/));
          d && 0 < d.length && (h = d[0] + "b\x3dAS:" + k.maxVideoBW + "\r\n", e = e.replace(d[0], h));
        }

        k.audio && k.maxAudioBW && (d = e.match(/m=audio.*\r\n/), null == d && (d = e.match(/m=audio.*\n/)), d && 0 < d.length && (h = d[0] + "b\x3dAS:" + k.maxAudioBW + "\r\n", e = e.replace(d[0], h)));
        return e;
      },
      enableOpusNacks: function enableOpusNacks(h) {
        var k = h.match(/a=rtpmap:(.*)opus.*\r\n/);
        null !== k && (h = h.replace(k[0], k[0] + "a\x3drtcp-fb:" + k[1] + "nack\r\n"));
        return h;
      }
    };
  }, function (p, r, n) {
    var h = n(1),
        k = n(3),
        e = n(17),
        d = n(19),
        c = n(0);

    r.a = function (g, a) {
      var b = Object(h.a)(a);
      b.stream = a.stream;
      b.url = a.url;
      b.recording = a.recording;
      b.room = void 0;
      b.showing = !1;
      b.local = !1;
      b.video = a.video;
      b.audio = a.audio;
      b.screen = a.screen;
      b.videoSize = a.videoSize;
      b.videoFrameRate = a.videoFrameRate;
      b.extensionId = a.extensionId;
      b.desktopStreamId = a.desktopStreamId;
      b.audioMuted = !1;
      b.videoMuted = !1;
      b.Connection = void 0 === g ? k.a : g;
      if (!(void 0 === b.videoSize || b.videoSize instanceof Array && 4 === b.videoSize.length)) throw Error("Invalid Video Size");
      if (void 0 === a.local || !0 === a.local) b.local = !0;

      b.getID = function () {
        return b.local && !a.streamID ? "local" : a.streamID;
      };

      b.getAttributes = function () {
        return a.attributes;
      };

      b.setAttributes = function (a) {
        b.local ? b.emit(Object(h.d)({
          type: "internal-set-attributes",
          stream: b,
          attrs: a
        })) : c.a.error("Failed to set attributes data. This Stream object has not been published.");
      };

      b.updateLocalAttributes = function (b) {
        a.attributes = b;
      };

      b.hasAudio = function () {
        return !1 !== a.audio && void 0 !== a.audio;
      };

      b.hasVideo = function () {
        return !1 !== a.video && void 0 !== a.video;
      };

      b.hasData = function () {
        return !1 !== a.data && void 0 !== a.data;
      };

      b.hasScreen = function () {
        return a.screen;
      };

      b.hasMedia = function () {
        return a.audio || a.video || a.screen;
      };

      b.isExternal = function () {
        return void 0 !== b.url || void 0 !== b.recording;
      };

      b.sendData = function (a) {
        b.local && b.hasData() ? b.emit(Object(h.d)({
          type: "internal-send-data",
          stream: b,
          msg: a
        })) : c.a.error("Failed to send data. This Stream object has not been published.");
      };

      b.init = function () {
        try {
          if ((a.audio || a.video || a.screen) && void 0 === a.url) {
            c.a.info("Requested access to local media");
            var d = a.video;
            !0 === d || !0 === a.screen ? (d = !0 === d ? {} : d, void 0 !== b.videoSize && (d.width = {
              min: b.videoSize[0],
              max: b.videoSize[2]
            }, d.height = {
              min: b.videoSize[1],
              max: b.videoSize[3]
            }), void 0 !== b.videoFrameRate && (d.frameRate = {
              min: b.videoFrameRate[0],
              max: b.videoFrameRate[1]
            })) : !0 === a.screen && void 0 === d && (d = !0);
            b.Connection.GetUserMedia({
              video: d,
              audio: a.audio,
              fake: a.fake,
              screen: a.screen,
              extensionId: b.extensionId,
              desktopStreamId: b.desktopStreamId
            }, function (a) {
              c.a.info("User has granted access to local media.");
              b.stream = a;
              b.dispatchEvent(Object(h.d)({
                type: "access-accepted"
              }));
              b.stream.getTracks().forEach(function (a) {
                c.a.info("getTracks", a);

                a.onended = function () {
                  b.stream.getTracks().forEach(function (a) {
                    a.onended = null;
                  });
                  var f = Object(h.d)({
                    type: "stream-ended",
                    stream: b,
                    msg: a.kind
                  });
                  b.dispatchEvent(f);
                };
              });
            }, function (a) {
              c.a.error("Failed to get access to local media. Error code was " + a.code + ".");
              a = Object(h.d)({
                type: "access-denied",
                msg: a
              });
              b.dispatchEvent(a);
            });
          } else {
            var g = Object(h.d)({
              type: "access-accepted"
            });
            b.dispatchEvent(g);
          }
        } catch (f) {
          c.a.error("Failed to get access to local media. Error was " + f + "."), d = Object(h.d)({
            type: "access-denied",
            msg: f
          }), b.dispatchEvent(d);
        }
      };

      b.close = function () {
        b.local && (void 0 !== b.room && b.room.unpublish(b), b.hide(), void 0 !== b.stream && b.stream.getTracks().forEach(function (a) {
          a.onended = null;
          a.stop();
        }), b.stream = void 0);
      };

      b.play = function (a, c) {
        c = c || {};
        b.elementID = a;
        b.hasVideo() || b.hasScreen() ? void 0 !== a && (a = Object(e.a)({
          id: b.getID(),
          stream: b,
          elementID: a,
          options: c
        }), b.player = a, b.showing = !0) : b.hasAudio() && (a = Object(d.a)({
          id: b.getID(),
          stream: b,
          elementID: a,
          options: c
        }), b.player = a, b.showing = !0);
      };

      b.stop = function () {
        b.showing && void 0 !== b.player && (b.player.destroy(), b.showing = !1);
      };

      b.show = b.play;
      b.hide = b.stop;

      var q = function q() {
        if (void 0 !== b.player && void 0 !== b.stream) {
          var a = b.player.video,
              c = document.defaultView.getComputedStyle(a),
              f = parseInt(c.getPropertyValue("width"), 10),
              d = parseInt(c.getPropertyValue("height"), 10),
              x = parseInt(c.getPropertyValue("left"), 10);
          c = parseInt(c.getPropertyValue("top"), 10);
          var g = "object" === _typeof(b.elementID) && "function" === typeof b.elementID.appendChild ? b.elementID : document.getElementById(b.elementID);
          var l = document.defaultView.getComputedStyle(g);
          g = parseInt(l.getPropertyValue("width"), 10);
          l = parseInt(l.getPropertyValue("height"), 10);
          var e = document.createElement("canvas");
          e.id = "testing";
          e.width = g;
          e.height = l;
          e.setAttribute("style", "display: none");
          e.getContext("2d").drawImage(a, x, c, f, d);
          return e;
        }

        return null;
      };

      b.getVideoFrameURL = function (a) {
        var b = q();
        return null !== b ? a ? b.toDataURL(a) : b.toDataURL() : null;
      };

      b.getVideoFrame = function () {
        var a = q();
        return null !== a ? a.getContext("2d").getImageData(0, 0, a.width, a.height) : null;
      };

      b.checkOptions = function (a, d) {
        if (!0 === d) {
          if (a.video || a.audio || a.screen) c.a.warning("Cannot update type of subscription"), a.video = void 0, a.audio = void 0, a.screen = void 0;
        } else !1 === b.local && (!0 === a.video && !1 === b.hasVideo() && (c.a.warning("Trying to subscribe to video when there is no video, won't subscribe to video"), a.video = !1), !0 === a.audio && !1 === b.hasAudio() && (c.a.warning("Trying to subscribe to audio when there is no audio, won't subscribe to audio"), a.audio = !1));

        !1 !== b.local || b.hasVideo() || !0 !== a.slideShowMode || (c.a.warning("Cannot enable slideShowMode if it is not a video subscription, please check your parameters"), a.slideShowMode = !1);
      };

      var m = function m(a) {
        a = void 0 === a ? function () {} : a;
        if (b.room && b.room.p2p) c.a.warning("muteAudio/muteVideo are not implemented in p2p streams"), a("error");else {
          if (b.stream) for (var d = 0; d < b.stream.getVideoTracks().length; d += 1) {
            b.stream.getVideoTracks()[d].enabled = !b.videoMuted;
          }
          d = {
            muteStream: {
              audio: b.audioMuted,
              video: b.videoMuted
            }
          };
          b.checkOptions(d, !0);
          b.pc.updateSpec(d, a);
        }
      };

      b.muteAudio = function (a, c) {
        b.audioMuted = a;
        m(void 0 === c ? function () {} : c);
      };

      b.muteVideo = function (a, c) {
        b.videoMuted = a;
        m(void 0 === c ? function () {} : c);
      };

      b._setStaticQualityLayer = function (a, d, f) {
        f = void 0 === f ? function () {} : f;
        b.room && b.room.p2p ? (c.a.warning("setStaticQualityLayer is not implemented in p2p streams"), f("error")) : (a = {
          qualityLayer: {
            spatialLayer: a,
            temporalLayer: d
          }
        }, b.checkOptions(a, !0), b.pc.updateSpec(a, f));
      };

      b._setDynamicQualityLayer = function (a) {
        if (b.room && b.room.p2p) c.a.warning("setDynamicQualityLayer is not implemented in p2p streams"), a("error");else {
          var d = {
            qualityLayer: {
              spatialLayer: -1,
              temporalLayer: -1
            }
          };
          b.checkOptions(d, !0);
          b.pc.updateSpec(d, a);
        }
      };

      var l = function l(a, c, f) {
        !0 !== c && (c = !1);
        a = "string" === typeof a ? [a] : a;
        a = a instanceof Array ? a : [];
        0 < a.length && b.room.sendControlMessage(b, "control", {
          name: "controlhandlers",
          enable: f,
          publisherSide: c,
          handlers: a
        });
      };

      b.disableHandlers = function (a, b) {
        l(a, b, !1);
      };

      b.enableHandlers = function (a, b) {
        l(a, b, !0);
      };

      b.updateConfiguration = function (a, c) {
        c = void 0 === c ? function () {} : c;
        if (void 0 !== a) if (b.pc) {
          if (b.checkOptions(a, !0), b.local) {
            if (b.room.p2p) for (var f = 0; f < b.pc.length; f += 1) {
              b.pc[f].updateSpec(a, c);
            } else b.pc.updateSpec(a, c);
          } else b.pc.updateSpec(a, c);
        } else c("This stream has no peerConnection attached, ignoring");
      };

      return b;
    };
  }, function (p, r, n) {
    var h = n(2),
        k = n(18);

    r.a = function (e) {
      var d = Object(h.a)({}),
          c;
      d.elementID = e.elementID;
      d.id = e.id;
      d.div = document.createElement("div");
      d.div.setAttribute("id", "bar_" + d.id);
      d.div.setAttribute("class", "licode_bar");
      d.bar = document.createElement("div");
      d.bar.setAttribute("style", "z-index: -1; width: 100%; height: 15%; max-height: 30px; position: absolute; bottom: 0; right: 0; background-color: rgba(255,255,255,0.62)");
      d.bar.setAttribute("id", "subbar_" + d.id);
      d.bar.setAttribute("class", "licode_subbar");
      d.link = document.createElement("a");
      d.link.setAttribute("href", "http://www.lynckia.com/");
      d.link.setAttribute("class", "licode_link");
      d.link.setAttribute("target", "_blank");
      d.logo = document.createElement("img");
      d.logo.setAttribute("style", "width: 100%; height: 100%; max-width: 30px; position: absolute; top: 0; left: 2px;");
      d.logo.setAttribute("class", "licode_logo");
      d.logo.setAttribute("alt", "Lynckia");
      d.logo.setAttribute("src", d.url + "/assets/star.svg");

      var g = function g(a) {
        var b = a;
        "block" !== a ? b = "none" : clearTimeout(c);
        d.div.setAttribute("style", "z-index: -1; width: 100%; height: 100%; position: relative; bottom: 0; right: 0; display: " + b);
      };

      d.display = function () {
        return;
        g("block");
      };

      d.hide = function () {
        c = setTimeout(g, 1 || 1E3);
      };

      document.getElementById(d.elementID).appendChild(d.div);
      d.div.appendChild(d.bar);
      d.bar.appendChild(d.link);
      d.link.appendChild(d.logo);
      e.stream.screen || void 0 !== e.options && void 0 !== e.options.speaker && !0 !== e.options.speaker || (d.speaker = Object(k.a)({
        elementID: "subbar_" + d.id,
        id: d.id,
        stream: e.stream,
        media: e.media
      }));
      d.display();
      d.hide();
      return d;
    };
  }, function (p, r) {
    r = function () {
      return this;
    }();

    try {
      r = r || Function("return this")() || (0, eval)("this");
    } catch (n) {
      "object" === (typeof window === "undefined" ? "undefined" : _typeof(window)) && (r = window);
    }

    p.exports = r;
  }, function (p, r, n) {
    Object.defineProperty(r, "__esModule", {
      value: !0
    });
    p = n(10);
    var h = n(1),
        k = n(6),
        e = n(0);
    n(22);
    n(24);
    n = {
      Room: p.a.bind(null, void 0, void 0),
      LicodeEvent: h.b,
      RoomEvent: h.c,
      StreamEvent: h.d,
      Stream: k.a.bind(null, void 0),
      Logger: e.a
    };
    r["default"] = n;
  }, function (p, r, n) {
    var h = n(3),
        k = n(1),
        e = n(15),
        d = n(6),
        c = n(20),
        g = n(21),
        a = n(0);

    r.a = function (b, q, m) {
      var l = Object(k.a)(m);
      l.remoteStreams = Object(c.a)();
      l.localStreams = Object(c.a)();
      l.recodeId = [];
      l.roomID = "";
      l.state = 0;
      l.p2p = !1;
      l.Connection = void 0 === q ? h.a : q;

      var v = Object(e.a)(b),
          t = l.remoteStreams,
          f = l.localStreams,
          u = 0,
          x = function x(a) {
        a.stream && (a.hide(), a.stop(), a.close(), delete a.stream);
        a.pc && (a.local && l.p2p ? a.pc.forEach(function (b, f) {
          b.close();
          a.pc.remove(f);
        }) : (a.pc.close(), delete a.pc));
      },
          w = function w(a, b) {
        0 !== l.state && a && !a.failed && (a.failed = !0, b = Object(k.d)({
          type: "stream-failed",
          msg: b || "Stream failed after connection",
          stream: a
        }), l.dispatchEvent(b), a.local ? l.unpublish(a) : l.unsubscribe(a));
      },
          y = function y(b, f) {
        a.a.info("Stream subscribed");
        b.stream = f.stream;
        b = Object(k.d)({
          type: "stream-subscribed",
          stream: b
        });
        l.dispatchEvent(b);
      },
          z = function z(a, b) {
        return {
          callback: function callback(f) {
            v.sendSDP("signaling_message", {
              streamId: a.getID(),
              peerSocket: b,
              msg: f
            });
          },
          audio: a.hasAudio(),
          video: a.hasVideo(),
          iceServers: l.iceServers,
          maxAudioBW: a.maxAudioBW,
          maxVideoBW: a.maxVideoBW,
          limitMaxAudioBW: m.maxAudioBW,
          limitMaxVideoBW: m.maxVideoBW
        };
      },
          B = function B(a, b) {
        a.pc = l.Connection.buildConnection(z(a, b));
        a.pc.onaddstream = y.bind(null, a);

        a.pc.oniceconnectionstatechange = function (b) {
          "failed" === b && w(a);
        };
      },
          C = function C(a, b) {
        void 0 === a.pc && (a.pc = Object(c.a)());
        var f = l.Connection.buildConnection(z(a, b));
        a.pc.add(b, f);

        f.oniceconnectionstatechange = function (f) {
          "failed" === f && (a.pc.get(b).close(), a.pc.remove(b));
        };

        f.addStream(a.stream);
        f.createOffer();
      },
          A = function A(b, f, c) {
        var d = {
          callback: function callback(f) {
            a.a.info("Sending message", f);
            v.sendSDP("signaling_message", {
              streamId: b.getID(),
              msg: f,
              browser: b.pc.browser
            }, void 0, function () {});
          },
          nop2p: !0,
          audio: f.audio && b.hasAudio(),
          video: f.video && b.hasVideo(),
          maxAudioBW: f.maxAudioBW,
          maxVideoBW: f.maxVideoBW,
          limitMaxAudioBW: m.maxAudioBW,
          limitMaxVideoBW: m.maxVideoBW,
          iceServers: l.iceServers
        };
        c || (d.simulcast = f.simulcast);
        return d;
      },
          n = function n(a, b) {
        a.pc = l.Connection.buildConnection(A(a, b, !0));
        a.pc.onaddstream = y.bind(null, a);

        a.pc.oniceconnectionstatechange = function (b) {
          "failed" === b && w(a);
        };

        a.pc.createOffer(!0);
      },
          D = function D(a, b) {
        a.pc = l.Connection.buildConnection(A(a, b));
        a.pc.addStream(a.stream);

        a.pc.oniceconnectionstatechange = function (b) {
          "failed" === b && w(a);
        };

        b.createOffer || a.pc.createOffer();
      },
          p = function p(b) {
        var f = b.stream;
        b = b.msg;
        f.local ? v.sendMessage("sendDataStream", {
          id: f.getID(),
          msg: b
        }) : a.a.error("You can not send data through a remote stream");
      },
          r = function r(b) {
        var f = b.stream;
        b = b.attrs;
        f.local ? (f.updateLocalAttributes(b), v.sendMessage("updateStreamAttributes", {
          id: f.getID(),
          attrs: b
        })) : a.a.error("You can not update attributes in a remote stream");
      };

      b = function b(a, _b) {
        _b.args ? a.apply(null, [].concat($jscomp.arrayFromIterable(_b.args))) : a();
      };

      var E = function E(a, b, f) {
        return {
          state: a,
          data: b.hasData(),
          audio: b.hasAudio(),
          video: b.hasVideo(),
          screen: b.hasScreen(),
          attributes: b.getAttributes(),
          metadata: f.metadata,
          createOffer: f.createOffer
        };
      },
          F = function F(b, c, d, u) {
        u = void 0 === u ? function () {} : u;
        null === b ? (a.a.error("Error when publishing the stream", d), u(void 0, d)) : (a.a.info("Stream published"), c.getID = function () {
          return b;
        }, c.on("internal-send-data", p), c.on("internal-set-attributes", r), f.add(b, c), c.room = l, u(b));
      },
          H = function H(b, f, c) {
        c = void 0 === c ? function () {} : c;

        if (b.url) {
          var d = "url";
          var u = b.url;
        } else d = "recording", u = b.recording;

        a.a.info("Checking publish options for", b.getID());
        b.checkOptions(f);
        v.sendSDP("publish", E(d, b, f), u, function (a, f) {
          F(a, b, f, c);
        });
      },
          J = function J(a, b, f) {
        f = void 0 === f ? function () {} : f;
        a.maxAudioBW = b.maxAudioBW;
        a.maxVideoBW = b.maxVideoBW;
        v.sendSDP("publish", E("p2p", a, b), void 0, function (b, c) {
          F(b, a, c, f);
        });
      },
          K = function K(a, b, f) {
        f = void 0 === f ? function () {} : f;
        v.sendSDP("publish", E("data", a, b), void 0, function (b, c) {
          F(b, a, c, f);
        });
      },
          M = function M(b, f, c) {
        c = void 0 === c ? function () {} : c;
        a.a.info("Publishing to Erizo Normally, is createOffer", f.createOffer);
        var d = E("erizo", b, f);
        d.minVideoBW = f.minVideoBW;
        d.scheme = f.scheme;
        v.sendSDP("publish", d, void 0, function (a, d) {
          F(a, b, d, void 0);
          D(b, f);
          c(a);
        });
      },
          N = function N(b, f, c) {
        c = void 0 === c ? function () {} : c;
        f.maxVideoBW = f.maxVideoBW || m.defaultVideoBW;
        f.maxVideoBW > m.maxVideoBW && (f.maxVideoBW = m.maxVideoBW);
        f.audio = void 0 === f.audio ? !0 : f.audio;
        f.video = void 0 === f.video ? !0 : f.video;
        f.data = void 0 === f.data ? !0 : f.data;
        b.checkOptions(f);
        var d = {
          streamId: b.getID(),
          audio: f.audio && b.hasAudio(),
          video: f.video && b.hasVideo(),
          data: f.data && b.hasData(),
          browser: l.Connection.getBrowser(),
          createOffer: f.createOffer,
          metadata: f.metadata,
          slideShowMode: f.slideShowMode
        };
        v.sendSDP("subscribe", d, void 0, function (d, u) {
          null === d ? (a.a.error("Error subscribing to stream ", u), c(void 0, u)) : (a.a.info("Subscriber added"), n(b, f), c(!0));
        });
      },
          O = function O(b, f, c) {
        c = void 0 === c ? function () {} : c;
        v.sendSDP("subscribe", {
          streamId: b.getID(),
          data: f.data,
          metadata: f.metadata
        }, void 0, function (f, d) {
          null === f ? (a.a.error("Error subscribing to stream ", d), c(void 0, d)) : (a.a.info("Stream subscribed"), f = Object(k.d)({
            type: "stream-subscribed",
            stream: b
          }), l.dispatchEvent(f), c(!0));
        });
      };

      l.connect = function () {
        var b = g.a.decodeBase64(m.token);
        0 !== l.state && a.a.warning("Room already connected");
        l.state = 1;
        v.connect(JSON.parse(b), function (b) {
          var f = [],
              c = b.streams || [],
              u = b.id;
          l.p2p = b.p2p;
          l.iceServers = b.iceServers;
          l.state = 2;
          m.defaultVideoBW = b.defaultVideoBW;
          m.maxVideoBW = b.maxVideoBW;

          for (var x = Object.keys(c), g = 0; g < x.length; g += 1) {
            var e = c[x[g]];
            b = Object(d.a)(l.Connection, {
              streamID: e.id,
              local: !1,
              audio: e.audio,
              video: e.video,
              data: e.data,
              screen: e.screen,
              attributes: e.attributes
            });
            f.push(b);
            t.add(e.id, b);
          }

          l.roomID = u;
          a.a.info("Connected to room " + l.roomID);
          f = Object(k.c)({
            type: "room-connected",
            streams: f
          });
          l.dispatchEvent(f);
        }, function (b) {
          a.a.error("Not Connected! Error: " + b);
          b = Object(k.c)({
            type: "room-error",
            message: b
          });
          l.dispatchEvent(b);
        });
      };

      l.disconnect = function () {
        a.a.debug("Disconnection requested");
        var b = Object(k.c)({
          type: "room-disconnected",
          message: "expected-disconnection"
        });
        l.dispatchEvent(b);
      };

      l.publish = function (b, c, d) {
        c = void 0 === c ? {} : c;
        d = void 0 === d ? function () {} : d;
        c.maxVideoBW = c.maxVideoBW || m.defaultVideoBW;
        c.maxVideoBW > m.maxVideoBW && (c.maxVideoBW = m.maxVideoBW);
        void 0 === c.minVideoBW && (c.minVideoBW = 0);
        c.minVideoBW > m.defaultVideoBW && (c.minVideoBW = m.defaultVideoBW);
        c.simulcast = c.simulcast || !1;
        b && b.local && !b.failed && !f.has(b.getID()) ? b.hasMedia() ? b.isExternal() ? H(b, c, d) : l.p2p ? J(b, c, d) : M(b, c, d) : b.hasData() && K(b, c, d) : (a.a.error("Trying to publish invalid stream"), d(void 0, "Invalid Stream"));
      };

      l.startRecording = function (b, f) {
        f = void 0 === f ? function () {} : f;
        void 0 === b ? (a.a.error("Trying to start recording on an invalid stream", b), f(void 0, "Invalid Stream")) : (a.a.debug("Start Recording stream: " + b.getID()), v.sendMessage("startRecorder", {
          to: b.getID()
        }, function (b, c) {
          null === b ? (a.a.error("Error on start recording", c), f(void 0, c)) : (a.a.info("Start recording", b), f(b));
        }));
      };

      l.startAllRecording = function () {
        t.forEach(function (b) {
          a.a.debug("Start Room Recording stream: " + b.getID());
          v.sendMessage("startRecorder", {
            to: b.getID()
          }, function (b, f) {
            null === b ? a.a.error("Error on start recording", f) : (l.recodeId[u] = b, a.a.info("Start Room recording", b), u += 1);
          });
        });
      };

      l.stopRecording = function (b, f) {
        f = void 0 === f ? function () {} : f;
        v.sendMessage("stopRecorder", {
          id: b
        }, function (c, d) {
          null === c ? (a.a.error("Error on stop recording", d), f(void 0, d)) : (a.a.info("Stop recording", b), f(!0));
        });
      };

      l.stopAllRecording = function () {
        for (var b = 0; b < u; b += 1) {
          a.a.debug("Stop Room Recording stream: " + l.recodeId[b]), v.sendMessage("stopRecorder", {
            id: l.recodeId[b]
          }), a.a.info("Stop All recording", l.recodeId[b]);
        }

        u = 0;
      };

      l.unpublish = function (b, c) {
        c = void 0 === c ? function () {} : c;
        b && b.local ? (v.sendMessage("unpublish", b.getID(), function (f, d) {
          null === f ? (a.a.error("Error unpublishing stream", d), c(void 0, d)) : (delete b.failed, a.a.info("Stream unpublished"), c(!0));
        }), b.room = void 0, b.hasMedia() && !b.isExternal() && x(b), f.remove(b.getID()), b.getID = function () {}, b.off("internal-send-data", p), b.off("internal-set-attributes", r)) : (a.a.error("Cannot unpublish, stream does not exist or is not local"), c(void 0, "Cannot unpublish, stream does not exist or is not local"));
      };

      l.sendControlMessage = function (a, b, f) {
        a && a.getID() && (b = {
          type: "control",
          action: f
        }, v.sendSDP("signaling_message", {
          streamId: a.getID(),
          msg: b
        }));
      };

      l.subscribe = function (b, f, c) {
        f = void 0 === f ? {} : f;
        c = void 0 === c ? function () {} : c;
        if (!b || b.local || b.failed) f = "Error on subscribe", b ? b.local ? (a.a.warning("Cannot subscribe to local stream, you should subscribe to the remote version of your local stream"), f = "Local copy of stream") : b.failed && (a.a.warning("Cannot subscribe to failed stream."), f = "Failed stream") : (a.a.warning("Cannot subscribe to invalid stream"), f = "Invalid or undefined stream"), c(void 0, f);else {
          if (b.hasMedia()) b.hasVideo() || b.hasScreen() || (f.video = !1), b.hasAudio() || (f.audio = !1), l.p2p ? (v.sendSDP("subscribe", {
            streamId: b.getID(),
            metadata: f.metadata
          }), c(!0)) : N(b, f, c);else if (b.hasData() && !1 !== f.data) O(b, f, c);else {
            a.a.warning("There's nothing to subscribe to");
            c(void 0, "Nothing to subscribe to");
            return;
          }
          a.a.info("Subscribing to: " + b.getID());
        }
      };

      l.unsubscribe = function (b, f) {
        f = void 0 === f ? function () {} : f;
        void 0 !== v && b && !b.local && v.sendMessage("unsubscribe", b.getID(), function (a, c) {
          null === a ? f(void 0, c) : (x(b), delete b.failed, f(!0));
        }, function () {
          a.a.error("Error calling unsubscribe.");
        });
      };

      l.getStreamStats = function (a, b) {
        b = void 0 === b ? function () {} : b;
        if (!v) return "Error getting stats - no socket";
        if (!a) return "Error getting stats - no stream";
        v.sendMessage("getStreamStats", a.getID(), function (a) {
          a && b(a);
        });
      };

      l.getStreamsByAttribute = function (a, b) {
        var f = [];
        t.forEach(function (c) {
          void 0 !== c.getAttributes() && c.getAttributes()[a] === b && f.push(c);
        });
        return f;
      };

      l.on("room-disconnected", function () {
        l.state = 0;
        v.state = v.DISCONNECTED;
        t.forEach(function (a, b) {
          x(a);
          t.remove(b);
          a && !a.failed && (a = Object(k.d)({
            type: "stream-removed",
            stream: a
          }), l.dispatchEvent(a));
        });
        t = Object(c.a)();
        f.forEach(function (a, b) {
          x(a);
          f.remove(b);
        });
        f = Object(c.a)();

        try {
          v.disconnect();
        } catch (P) {
          a.a.debug("Socket already disconnected");
        }

        v = void 0;
      });
      v.on("onAddStream", b.bind(null, function (a) {
        var b = Object(d.a)(l.Connection, {
          streamID: a.id,
          local: !1,
          audio: a.audio,
          video: a.video,
          data: a.data,
          screen: a.screen,
          attributes: a.attributes
        });
        b.room = l;
        t.add(a.id, b);
        a = Object(k.d)({
          type: "stream-added",
          stream: b
        });
        l.dispatchEvent(a);
      }));
      v.on("signaling_message_erizo", b.bind(null, function (a) {
        var b;
        (b = a.peerId ? t.get(a.peerId) : f.get(a.streamId)) && !b.failed && b.pc.processSignalingMessage(a.mess);
      }));
      v.on("signaling_message_peer", b.bind(null, function (a) {
        var b = f.get(a.streamId);
        b && !b.failed ? b.pc.get(a.peerSocket).processSignalingMessage(a.msg) : (b = t.get(a.streamId), b.pc || B(b, a.peerSocket), b.pc.processSignalingMessage(a.msg));
      }));
      v.on("publish_me", b.bind(null, function (a) {
        var b = f.get(a.streamId);
        C(b, a.peerSocket);
      }));
      v.on("onBandwidthAlert", b.bind(null, function (b) {
        a.a.info("Bandwidth Alert on", b.streamID, "message", b.message, "BW:", b.bandwidth);

        if (b.streamID) {
          var f = t.get(b.streamID);
          f && !f.failed && (b = Object(k.d)({
            type: "bandwidth-alert",
            stream: f,
            msg: b.message,
            bandwidth: b.bandwidth
          }), f.dispatchEvent(b));
        }
      }));
      v.on("onDataStream", b.bind(null, function (a) {
        var b = t.get(a.id);
        a = Object(k.d)({
          type: "stream-data",
          msg: a.msg,
          stream: b
        });
        b.dispatchEvent(a);
      }));
      v.on("onUpdateAttributeStream", b.bind(null, function (a) {
        var b = t.get(a.id),
            f = Object(k.d)({
          type: "stream-attributes-update",
          attrs: a.attrs,
          stream: b
        });
        b.updateLocalAttributes(a.attrs);
        b.dispatchEvent(f);
      }));
      v.on("onRemoveStream", b.bind(null, function (a) {
        var b = f.get(a.id);
        b ? w(b) : (b = t.get(a.id), t.remove(a.id), x(b), a = Object(k.d)({
          type: "stream-removed",
          stream: b
        }), l.dispatchEvent(a));
      }));
      v.on("disconnect", b.bind(null, function () {
        a.a.info("Socket disconnected, lost connection to ErizoController");

        if (0 !== l.state) {
          a.a.error("Unexpected disconnection from ErizoController");
          var b = Object(k.c)({
            type: "room-disconnected",
            message: "unexpected-disconnection"
          });
          l.dispatchEvent(b);
        }
      }));
      v.on("connection_failed", b.bind(null, function (b) {
        if (b.streamId) {
          var c = "ICE Connection Failed on " + b.type + " " + b.streamId + " " + l.state;
          a.a.error(c);
          b = "publish" === b.type ? f.get(b.streamId) : t.get(b.streamId);
          w(b, c);
        }
      }));
      v.on("error", b.bind(null, function (b) {
        a.a.error("Cannot connect to erizo Controller");
        b = Object(k.c)({
          type: "room-error",
          message: b
        });
        l.dispatchEvent(b);
      }));
      return l;
    };
  }, function (p, r) {
    p.exports = function (n) {
      if (!n.webpackPolyfill) {
        var h = Object.create(n);
        h.children || (h.children = []);
        Object.defineProperty(h, "loaded", {
          enumerable: !0,
          get: function get() {
            return h.l;
          }
        });
        Object.defineProperty(h, "id", {
          enumerable: !0,
          get: function get() {
            return h.i;
          }
        });
        Object.defineProperty(h, "exports", {
          enumerable: !0
        });
        h.webpackPolyfill = 1;
      }

      return h;
    };
  }, function (p, r, n) {
    var h = n(4),
        k = n(5),
        e = n(0);

    r.a = function (d) {
      e.a.info("Starting Chrome stable stack", d);
      var c = Object(h.a)(d);

      c.enableSimulcast = function (c) {
        var a = c;
        if (!d.video || !d.simulcast) return a;
        c = a.match(/a=ssrc-group:FID ([0-9]*) ([0-9]*)\r?\n/);
        if (!c || 0 >= c.length) return a;
        var b = d.simulcast.numSpatialLayers || 2;
        var g = parseInt(c[1], 10),
            e = parseInt(c[2], 10),
            l = a.match(new RegExp("a\x3dssrc:" + c[1] + " cname:(.*)\r?\n"))[1],
            v = a.match(new RegExp("a\x3dssrc:" + c[1] + " msid:(.*)\r?\n"))[1],
            h = a.match(new RegExp("a\x3dssrc:" + c[1] + " mslabel:(.*)\r?\n"))[1],
            f = a.match(new RegExp("a\x3dssrc:" + c[1] + " label:(.*)\r?\n"))[1];
        a.match(new RegExp("a\x3dssrc:" + c[1] + ".*\r?\n", "g")).forEach(function (b) {
          a = a.replace(b, "");
        });
        a.match(new RegExp("a\x3dssrc:" + c[2] + ".*\r?\n", "g")).forEach(function (b) {
          a = a.replace(b, "");
        });

        for (var u = [g], x = [e], w = 1; w < b; w += 1) {
          u.push(g + 1E3 * w), x.push(e + 1E3 * w);
        }

        b = k.a.addSim(u);

        for (w = 0; w < u.length; w += 1) {
          g = u[w], e = x[w], b += k.a.addGroup(g, e);
        }

        for (w = 0; w < u.length; w += 1) {
          g = u[w], e = x[w], b += k.a.addSpatialLayer(l, v, h, f, g, e);
        }

        return a.replace(c[0], b + "a\x3dx-google-flag:conference\r\n");
      };

      return c;
    };
  }, function (p, r, n) {
    var h = n(0),
        k = n(4);

    r.a = function (e) {
      h.a.info("Starting Firefox stack");
      var d = Object(k.a)(e);

      d.enableSimulcast = function (c) {
        if (!e.video || !e.simulcast) return c;
        d.peerConnection.getSenders().forEach(function (c) {
          "video" === c.track.kind && (c.getParameters(), c.setParameters({
            encodings: [{
              rid: "spam",
              active: !0,
              priority: "high",
              maxBitrate: 4E4,
              maxHeight: 640,
              maxWidth: 480
            }, {
              rid: "egg",
              active: !0,
              priority: "medium",
              maxBitrate: 1E4,
              maxHeight: 320,
              maxWidth: 240
            }]
          }));
        });
        return c;
      };

      return d;
    };
  }, function (p, r, n) {
    var h = n(0);

    r.a = function (k) {
      var e = {
        pcConfig: {},
        peerConnection: {},
        desc: {},
        signalCallback: void 0,
        close: function close() {
          h.a.info("Close FcStack");
        },
        createOffer: function createOffer() {
          h.a.debug("FCSTACK: CreateOffer");
        },
        addStream: function addStream(d) {
          h.a.debug("FCSTACK: addStream", d);
        },
        processSignalingMessage: function processSignalingMessage(d) {
          h.a.debug("FCSTACK: processSignaling", d);
          void 0 !== e.signalCallback && e.signalCallback(d);
        },
        sendSignalingMessage: function sendSignalingMessage(d) {
          h.a.debug("FCSTACK: Sending signaling Message", d);
          k.callback(d);
        },
        setSignalingCallback: function setSignalingCallback(d) {
          d = void 0 === d ? function () {} : d;
          h.a.debug("FCSTACK: Setting signalling callback");
          e.signalCallback = d;
        }
      };
      return e;
    };
  }, function (p, r, n) {
    n.d(r, "a", function () {
      return c;
    });
    p = n(16);

    var h = n.n(p),
        k = n(0),
        e = n(1),
        d = function d(c, a) {
      c = Object(e.b)({
        type: c
      });
      c.args = a.args;
      return c;
    },
        c = function c(_c2) {
      var a = Object(e.a)(),
          b = function b() {};

      $jscomp.initSymbol();
      a.CONNECTED = Symbol("connected");
      $jscomp.initSymbol();
      a.DISCONNECTED = Symbol("disconnected");
      a.state = a.DISCONNECTED;
      a.IO = void 0 === _c2 ? h.a : _c2;

      var g,
          m = function m(b, c) {
        for (var g = [], f = 1; f < arguments.length; ++f) {
          g[f - 1] = arguments[f];
        }

        a.emit(d(b, {
          args: g
        }));
      };

      a.connect = function (c, d, e) {
        d = void 0 === d ? b : d;
        e = void 0 === e ? b : e;
        g = a.IO.connect((c.secure ? "wss://" : "ws://") + c.host, {
          reconnect: !1,
          secure: c.secure,
          forceNew: !0,
          transports: ["websocket"],
          rejectUnauthorized: !1
        });
        g.on("onAddStream", m.bind(a, "onAddStream"));
        g.on("signaling_message_erizo", m.bind(a, "signaling_message_erizo"));
        g.on("signaling_message_peer", m.bind(a, "signaling_message_peer"));
        g.on("publish_me", m.bind(a, "publish_me"));
        g.on("onBandwidthAlert", m.bind(a, "onBandwidthAlert"));
        g.on("onDataStream", m.bind(a, "onDataStream"));
        g.on("onUpdateAttributeStream", m.bind(a, "onUpdateAttributeStream"));
        g.on("onRemoveStream", m.bind(a, "onRemoveStream"));
        g.on("disconnect", m.bind(a, "disconnect"));
        g.on("connection_failed", m.bind(a, "connection_failed"));
        g.on("error", m.bind(a, "error"));
        a.sendMessage("token", c, function (b) {
          for (var f = [], c = 0; c < arguments.length; ++c) {
            f[c - 0] = arguments[c];
          }

          a.state = a.CONNECTED;
          d.apply(null, [].concat($jscomp.arrayFromIterable(f)));
        }, e);
      };

      a.disconnect = function () {
        a.state = a.DISCONNECTED;
        g.disconnect();
      };

      a.sendMessage = function (c, d, e, f) {
        e = void 0 === e ? b : e;
        f = void 0 === f ? b : f;
        a.state === a.DISCONNECTED && "token" !== c ? k.a.error("Trying to send a message over a disconnected Socket") : g.emit(c, d, function (a, b) {
          "success" === a ? e(b) : "error" === a ? f(b) : e(a, b);
        });
      };

      a.sendSDP = function (c, d, e, f) {
        f = void 0 === f ? b : f;
        a.state === a.DISCONNECTED ? k.a.error("Trying to send a message over a disconnected Socket") : g.emit(c, d, e, function (a, b) {
          f(a, b);
        });
      };

      return a;
    };
  }, function (p, r, n) {
    !function (h, k) {
      p.exports = k();
    }(this, function () {
      return function (h) {
        function k(d) {
          if (e[d]) return e[d].exports;
          var c = e[d] = {
            exports: {},
            id: d,
            loaded: !1
          };
          return h[d].call(c.exports, c, c.exports, k), c.loaded = !0, c.exports;
        }

        var e = {};
        return k.m = h, k.c = e, k.p = "", k(0);
      }([function (h, k, e) {
        function d(a, d) {
          "object" === ("undefined" == typeof a ? "undefined" : c(a)) && (d = a, a = void 0);
          d = d || {};
          var e;
          a = g(a);
          var f = a.source,
              u = a.id,
              x = a.path;
          x = m[u] && x in m[u].nsps;
          return d.forceNew || d["force new connection"] || !1 === d.multiplex || x ? (q("ignoring socket cache for %s", f), e = b(f, d)) : (m[u] || (q("new io instance for %s", f), m[u] = b(f, d)), e = m[u]), a.query && !d.query && (d.query = a.query), e.socket(a.path, d);
        }

        $jscomp.initSymbol();
        $jscomp.initSymbol();
        $jscomp.initSymbolIterator();
        var c = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (a) {
          return _typeof(a);
        } : function (a) {
          $jscomp.initSymbol();
          $jscomp.initSymbol();
          $jscomp.initSymbol();
          return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : _typeof(a);
        },
            g = e(1),
            a = e(7),
            b = e(13),
            q = e(3)("socket.io-client");
        h.exports = k = d;
        var m = k.managers = {};
        k.protocol = a.protocol;
        k.connect = d;
        k.Manager = e(13);
        k.Socket = e(39);
      }, function (h, k, e) {
        (function (d) {
          var c = e(2),
              g = e(3)("socket.io-client:url");

          h.exports = function (a, b) {
            var e = a;
            b = b || d.location;
            null == a && (a = b.protocol + "//" + b.host);
            "string" == typeof a && ("/" === a.charAt(0) && (a = "/" === a.charAt(1) ? b.protocol + a : b.host + a), /^(https?|wss?):\/\//.test(a) || (g("protocol-less url %s", a), a = "undefined" != typeof b ? b.protocol + "//" + a : "https://" + a), g("parse %s", a), e = c(a));
            e.port || (/^(http|ws)$/.test(e.protocol) ? e.port = "80" : /^(http|ws)s$/.test(e.protocol) && (e.port = "443"));
            e.path = e.path || "/";
            a = -1 !== e.host.indexOf(":") ? "[" + e.host + "]" : e.host;
            return e.id = e.protocol + "://" + a + ":" + e.port, e.href = e.protocol + "://" + a + (b && b.port === e.port ? "" : ":" + e.port), e;
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k) {
        var e = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/,
            d = "source protocol authority userInfo user password host port relative path directory file query anchor".split(" ");

        h.exports = function (c) {
          var g = c,
              a = c.indexOf("["),
              b = c.indexOf("]");
          -1 != a && -1 != b && (c = c.substring(0, a) + c.substring(a, b).replace(/:/g, ";") + c.substring(b, c.length));
          c = e.exec(c || "");

          for (var q = {}, m = 14; m--;) {
            q[d[m]] = c[m] || "";
          }

          return -1 != a && -1 != b && (q.source = g, q.host = q.host.substring(1, q.host.length - 1).replace(/;/g, ":"), q.authority = q.authority.replace("[", "").replace("]", "").replace(/;/g, ":"), q.ipv6uri = !0), q;
        };
      }, function (h, k, e) {
        (function (d) {
          function c() {
            try {
              var a = k.storage.debug;
            } catch (q) {}

            return !a && "undefined" != typeof d && "env" in d && (a = d.env.DEBUG), a;
          }

          k = h.exports = e(5);

          k.log = function () {
            return "object" == (typeof console === "undefined" ? "undefined" : _typeof(console)) && console.log && Function.prototype.apply.call(console.log, console, arguments);
          };

          k.formatArgs = function (a) {
            var b = this.useColors;

            if (a[0] = (b ? "%c" : "") + this.namespace + (b ? " %c" : " ") + a[0] + (b ? "%c " : " ") + "+" + k.humanize(this.diff), b) {
              b = "color: " + this.color;
              a.splice(1, 0, b, "color: inherit");
              var c = 0,
                  d = 0;
              a[0].replace(/%[a-zA-Z%]/g, function (a) {
                "%%" !== a && (c++, "%c" === a && (d = c));
              });
              a.splice(d, 0, b);
            }
          };

          k.save = function (a) {
            try {
              null == a ? k.storage.removeItem("debug") : k.storage.debug = a;
            } catch (q) {}
          };

          k.load = c;

          k.useColors = function () {
            return !("undefined" == typeof window || !window.process || "renderer" !== window.process.type) || "undefined" != typeof document && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || "undefined" != typeof window && window.console && (window.console.firebug || window.console.exception && window.console.table) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && 31 <= parseInt(RegExp.$1, 10) || "undefined" != typeof navigator && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
          };

          var g = k;
          if ("undefined" != typeof chrome && "undefined" != typeof chrome.storage) var a = chrome.storage.local;else a: {
            try {
              a = window.localStorage;
              break a;
            } catch (b) {}

            a = void 0;
          }
          g.storage = a;
          k.colors = "lightseagreen forestgreen goldenrod dodgerblue darkorchid crimson".split(" ");

          k.formatters.j = function (a) {
            try {
              return JSON.stringify(a);
            } catch (q) {
              return "[UnexpectedJSONParseError]: " + q.message;
            }
          };

          k.enable(c());
        }).call(k, e(4));
      }, function (h, k) {
        function e() {
          throw Error("setTimeout has not been defined");
        }

        function d() {
          throw Error("clearTimeout has not been defined");
        }

        function c(a) {
          if (l === setTimeout) return setTimeout(a, 0);
          if ((l === e || !l) && setTimeout) return l = setTimeout, setTimeout(a, 0);

          try {
            return l(a, 0);
          } catch (y) {
            try {
              return l.call(null, a, 0);
            } catch (z) {
              return l.call(this, a, 0);
            }
          }
        }

        function g(a) {
          if (v === clearTimeout) return clearTimeout(a);
          if ((v === d || !v) && clearTimeout) return v = clearTimeout, clearTimeout(a);

          try {
            return v(a);
          } catch (y) {
            try {
              return v.call(null, a);
            } catch (z) {
              return v.call(this, a);
            }
          }
        }

        function a() {
          u && t && (u = !1, t.length ? f = t.concat(f) : x = -1, f.length && b());
        }

        function b() {
          if (!u) {
            var b = c(a);
            u = !0;

            for (var d = f.length; d;) {
              t = f;

              for (f = []; ++x < d;) {
                t && t[x].run();
              }

              x = -1;
              d = f.length;
            }

            t = null;
            u = !1;
            g(b);
          }
        }

        function q(a, b) {
          this.fun = a;
          this.array = b;
        }

        function m() {}

        h = h.exports = {};

        try {
          var l = "function" == typeof setTimeout ? setTimeout : e;
        } catch (w) {
          l = e;
        }

        try {
          var v = "function" == typeof clearTimeout ? clearTimeout : d;
        } catch (w) {
          v = d;
        }

        !0;
        var t,
            f = [],
            u = !1,
            x = -1;

        h.nextTick = function (a) {
          var d = Array(arguments.length - 1);
          if (1 < arguments.length) for (var e = 1; e < arguments.length; e++) {
            d[e - 1] = arguments[e];
          }
          f.push(new q(a, d));
          1 !== f.length || u || c(b);
        };

        q.prototype.run = function () {
          this.fun.apply(null, this.array);
        };

        h.title = "browser";
        h.browser = !0;
        h.env = {};
        h.argv = [];
        h.version = "";
        h.versions = {};
        h.on = m;
        h.addListener = m;
        h.once = m;
        h.off = m;
        h.removeListener = m;
        h.removeAllListeners = m;
        h.emit = m;
        h.prependListener = m;
        h.prependOnceListener = m;

        h.listeners = function (a) {
          return [];
        };

        h.binding = function (a) {
          throw Error("process.binding is not supported");
        };

        h.cwd = function () {
          return "/";
        };

        h.chdir = function (a) {
          throw Error("process.chdir is not supported");
        };

        h.umask = function () {
          return 0;
        };
      }, function (h, k, e) {
        function d(a) {
          var b,
              c = 0;

          for (b in a) {
            c = (c << 5) - c + a.charCodeAt(b), c |= 0;
          }

          return k.colors[Math.abs(c) % k.colors.length];
        }

        function c(a) {
          function b() {
            if (b.enabled) {
              var a = +new Date();
              b.diff = a - (g || a);
              b.prev = g;
              g = b.curr = a;
              var c = Array(arguments.length);

              for (a = 0; a < c.length; a++) {
                c[a] = arguments[a];
              }

              c[0] = k.coerce(c[0]);
              "string" != typeof c[0] && c.unshift("%O");
              var d = 0;
              c[0] = c[0].replace(/%([a-zA-Z%])/g, function (a, e) {
                if ("%%" === a) return a;
                d++;
                e = k.formatters[e];
                "function" == typeof e && (a = e.call(b, c[d]), c.splice(d, 1), d--);
                return a;
              });
              k.formatArgs.call(b, c);
              (b.log || k.log || console.log.bind(console)).apply(b, c);
            }
          }

          return b.namespace = a, b.enabled = k.enabled(a), b.useColors = k.useColors(), b.color = d(a), "function" == typeof k.init && k.init(b), b;
        }

        k = h.exports = c.debug = c["default"] = c;

        k.coerce = function (a) {
          return a instanceof Error ? a.stack || a.message : a;
        };

        k.disable = function () {
          k.enable("");
        };

        k.enable = function (a) {
          k.save(a);
          k.names = [];
          k.skips = [];

          for (var b = ("string" == typeof a ? a : "").split(/[\s,]+/), c = b.length, d = 0; d < c; d++) {
            b[d] && (a = b[d].replace(/\*/g, ".*?"), "-" === a[0] ? k.skips.push(new RegExp("^" + a.substr(1) + "$")) : k.names.push(new RegExp("^" + a + "$")));
          }
        };

        k.enabled = function (a) {
          var b;
          var c = 0;

          for (b = k.skips.length; c < b; c++) {
            if (k.skips[c].test(a)) return !1;
          }

          c = 0;

          for (b = k.names.length; c < b; c++) {
            if (k.names[c].test(a)) return !0;
          }

          return !1;
        };

        k.humanize = e(6);
        k.names = [];
        k.skips = [];
        k.formatters = {};
        var g;
      }, function (h, k) {
        function e(d) {
          if (d = String(d), !(100 < d.length)) if (d = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(d)) {
            var e = parseFloat(d[1]);

            switch ((d[2] || "ms").toLowerCase()) {
              case "years":
              case "year":
              case "yrs":
              case "yr":
              case "y":
                return e * q;

              case "days":
              case "day":
              case "d":
                return e * b;

              case "hours":
              case "hour":
              case "hrs":
              case "hr":
              case "h":
                return e * a;

              case "minutes":
              case "minute":
              case "mins":
              case "min":
              case "m":
                return e * g;

              case "seconds":
              case "second":
              case "secs":
              case "sec":
              case "s":
                return e * c;

              case "milliseconds":
              case "millisecond":
              case "msecs":
              case "msec":
              case "ms":
                return e;
            }
          }
        }

        function d(a, b, c) {
          if (!(a < b)) return a < 1.5 * b ? Math.floor(a / b) + " " + c : Math.ceil(a / b) + " " + c + "s";
        }

        var c = 1E3,
            g = 60 * c,
            a = 60 * g,
            b = 24 * a,
            q = 365.25 * b;

        h.exports = function (m, l) {
          l = l || {};

          var q = _typeof(m);

          if ("string" === q && 0 < m.length) return e(m);
          if ("number" === q && !1 === isNaN(m)) return l["long"] ? d(m, b, "day") || d(m, a, "hour") || d(m, g, "minute") || d(m, c, "second") || m + " ms" : m >= b ? Math.round(m / b) + "d" : m >= a ? Math.round(m / a) + "h" : m >= g ? Math.round(m / g) + "m" : m >= c ? Math.round(m / c) + "s" : m + "ms";
          throw Error("val is not a non-empty string or a valid number. val\x3d" + JSON.stringify(m));
        };
      }, function (h, k, e) {
        function d() {}

        function c(a) {
          var b = "" + a.type;
          return k.BINARY_EVENT !== a.type && k.BINARY_ACK !== a.type || (b += a.attachments + "-"), a.nsp && "/" !== a.nsp && (b += a.nsp + ","), null != a.id && (b += a.id), null != a.data && (b += JSON.stringify(a.data)), m("encoded %j as %s", a, b), b;
        }

        function g(a, b) {
          v.removeBlobs(a, function (a) {
            var f = v.deconstructPacket(a);
            a = c(f.packet);
            f = f.buffers;
            f.unshift(a);
            b(f);
          });
        }

        function a() {
          this.reconstructor = null;
        }

        function b(a) {
          this.reconPack = a;
          this.buffers = [];
        }

        function q() {
          return {
            type: k.ERROR,
            data: "parser error"
          };
        }

        var m = e(3)("socket.io-parser");
        h = e(8);
        var l = e(9),
            v = e(11),
            t = e(12);
        k.protocol = 4;
        k.types = "CONNECT DISCONNECT EVENT ACK ERROR BINARY_EVENT BINARY_ACK".split(" ");
        k.CONNECT = 0;
        k.DISCONNECT = 1;
        k.EVENT = 2;
        k.ACK = 3;
        k.ERROR = 4;
        k.BINARY_EVENT = 5;
        k.BINARY_ACK = 6;
        k.Encoder = d;
        k.Decoder = a;

        d.prototype.encode = function (a, b) {
          (a.type !== k.EVENT && a.type !== k.ACK || !l(a.data) || (a.type = a.type === k.EVENT ? k.BINARY_EVENT : k.BINARY_ACK), m("encoding packet %j", a), k.BINARY_EVENT === a.type || k.BINARY_ACK === a.type) ? g(a, b) : (a = c(a), b([a]));
        };

        h(a.prototype);

        a.prototype.add = function (a) {
          if ("string" == typeof a) {
            var c,
                f = 0,
                d = {
              type: Number(a.charAt(0))
            };
            if (null == k.types[d.type]) a = q();else {
              if (k.BINARY_EVENT === d.type || k.BINARY_ACK === d.type) {
                for (c = ""; "-" !== a.charAt(++f) && (c += a.charAt(f), f != a.length);) {
                  ;
                }

                if (c != Number(c) || "-" !== a.charAt(f)) throw Error("Illegal attachments");
                d.attachments = Number(c);
              }

              if ("/" === a.charAt(f + 1)) for (d.nsp = ""; ++f;) {
                c = a.charAt(f);
                if ("," === c) break;
                if (d.nsp += c, f === a.length) break;
              } else d.nsp = "/";
              c = a.charAt(f + 1);

              if ("" !== c && Number(c) == c) {
                for (d.id = ""; ++f;) {
                  c = a.charAt(f);

                  if (null == c || Number(c) != c) {
                    --f;
                    break;
                  }

                  if (d.id += a.charAt(f), f === a.length) break;
                }

                d.id = Number(d.id);
              }

              if (a.charAt(++f)) {
                b: {
                  f = a.substr(f);

                  try {
                    d.data = JSON.parse(f);
                  } catch (y) {
                    f = q();
                    break b;
                  }

                  f = d;
                }

                d = f;
              }

              a = (m("decoded %s as %j", a, d), d);
            }
            k.BINARY_EVENT === a.type || k.BINARY_ACK === a.type ? (this.reconstructor = new b(a), 0 === this.reconstructor.reconPack.attachments && this.emit("decoded", a)) : this.emit("decoded", a);
          } else {
            if (!t(a) && !a.base64) throw Error("Unknown type: " + a);
            if (!this.reconstructor) throw Error("got binary data when not reconstructing a packet");
            (a = this.reconstructor.takeBinaryData(a)) && (this.reconstructor = null, this.emit("decoded", a));
          }
        };

        a.prototype.destroy = function () {
          this.reconstructor && this.reconstructor.finishedReconstruction();
        };

        b.prototype.takeBinaryData = function (a) {
          return (this.buffers.push(a), this.buffers.length === this.reconPack.attachments) ? (a = v.reconstructPacket(this.reconPack, this.buffers), this.finishedReconstruction(), a) : null;
        };

        b.prototype.finishedReconstruction = function () {
          this.reconPack = null;
          this.buffers = [];
        };
      }, function (h, k, e) {
        function d(c) {
          if (c) {
            for (var e in d.prototype) {
              c[e] = d.prototype[e];
            }

            return c;
          }
        }

        h.exports = d;

        d.prototype.on = d.prototype.addEventListener = function (c, d) {
          return this._callbacks = this._callbacks || {}, (this._callbacks["$" + c] = this._callbacks["$" + c] || []).push(d), this;
        };

        d.prototype.once = function (c, d) {
          function a() {
            this.off(c, a);
            d.apply(this, arguments);
          }

          return a.fn = d, this.on(c, a), this;
        };

        d.prototype.off = d.prototype.removeListener = d.prototype.removeAllListeners = d.prototype.removeEventListener = function (c, d) {
          if (this._callbacks = this._callbacks || {}, 0 == arguments.length) return this._callbacks = {}, this;
          var a = this._callbacks["$" + c];
          if (!a) return this;
          if (1 == arguments.length) return delete this._callbacks["$" + c], this;

          for (var b, e = 0; e < a.length; e++) {
            if (b = a[e], b === d || b.fn === d) {
              a.splice(e, 1);
              break;
            }
          }

          return this;
        };

        d.prototype.emit = function (c) {
          this._callbacks = this._callbacks || {};
          var d = [].slice.call(arguments, 1),
              a = this._callbacks["$" + c];

          if (a) {
            a = a.slice(0);

            for (var b = 0, e = a.length; b < e; ++b) {
              a[b].apply(this, d);
            }
          }

          return this;
        };

        d.prototype.listeners = function (c) {
          return this._callbacks = this._callbacks || {}, this._callbacks["$" + c] || [];
        };

        d.prototype.hasListeners = function (c) {
          return !!this.listeners(c).length;
        };
      }, function (h, k, e) {
        (function (d) {
          function c(a) {
            if (!a || "object" != _typeof(a)) return !1;

            if (g(a)) {
              for (var e = 0, m = a.length; e < m; e++) {
                if (c(a[e])) return !0;
              }

              return !1;
            }

            if ("function" == typeof d.Buffer && d.Buffer.isBuffer && d.Buffer.isBuffer(a) || "function" == typeof d.ArrayBuffer && a instanceof ArrayBuffer || b && a instanceof Blob || q && a instanceof File) return !0;
            if (a.toJSON && "function" == typeof a.toJSON && 1 === arguments.length) return c(a.toJSON(), !0);

            for (e in a) {
              if (Object.prototype.hasOwnProperty.call(a, e) && c(a[e])) return !0;
            }

            return !1;
          }

          var g = e(10),
              a = Object.prototype.toString,
              b = "function" == typeof d.Blob || "[object BlobConstructor]" === a.call(d.Blob),
              q = "function" == typeof d.File || "[object FileConstructor]" === a.call(d.File);
          h.exports = c;
        }).call(k, function () {
          return this;
        }());
      }, function (h, k) {
        var e = {}.toString;

        h.exports = Array.isArray || function (d) {
          return "[object Array]" == e.call(d);
        };
      }, function (h, k, e) {
        (function (d) {
          function c(d, e) {
            if (!d) return d;

            if (b(d)) {
              var f = {
                _placeholder: !0,
                num: e.length
              };
              return e.push(d), f;
            }

            if (a(d)) {
              f = Array(d.length);

              for (var u = 0; u < d.length; u++) {
                f[u] = c(d[u], e);
              }

              return f;
            }

            if ("object" == _typeof(d) && !(d instanceof Date)) {
              f = {};

              for (u in d) {
                f[u] = c(d[u], e);
              }

              return f;
            }

            return d;
          }

          function g(b, c) {
            if (!b) return b;
            if (b && b._placeholder) return c[b.num];
            if (a(b)) for (var f = 0; f < b.length; f++) {
              b[f] = g(b[f], c);
            } else if ("object" == _typeof(b)) for (f in b) {
              b[f] = g(b[f], c);
            }
            return b;
          }

          var a = e(10),
              b = e(12),
              q = Object.prototype.toString,
              m = "function" == typeof d.Blob || "[object BlobConstructor]" === q.call(d.Blob),
              l = "function" == typeof d.File || "[object FileConstructor]" === q.call(d.File);

          k.deconstructPacket = function (a) {
            var b = [];
            return a.data = c(a.data, b), a.attachments = b.length, {
              packet: a,
              buffers: b
            };
          };

          k.reconstructPacket = function (a, b) {
            return a.data = g(a.data, b), a.attachments = void 0, a;
          };

          k.removeBlobs = function (c, d) {
            function f(c, g, x) {
              if (!c) return c;

              if (m && c instanceof Blob || l && c instanceof File) {
                u++;
                var q = new FileReader();

                q.onload = function () {
                  x ? x[g] = this.result : e = this.result;
                  --u || d(e);
                };

                q.readAsArrayBuffer(c);
              } else if (a(c)) for (q = 0; q < c.length; q++) {
                f(c[q], q, c);
              } else if ("object" == _typeof(c) && !b(c)) for (q in c) {
                f(c[q], q, c);
              }
            }

            var u = 0,
                e = c;
            f(e);
            u || d(e);
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k) {
        (function (e) {
          h.exports = function (d) {
            return e.Buffer && e.Buffer.isBuffer(d) || e.ArrayBuffer && d instanceof ArrayBuffer;
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k, e) {
        function d(a, f) {
          if (!(this instanceof d)) return new d(a, f);
          a && "object" === ("undefined" == typeof a ? "undefined" : c(a)) && (f = a, a = void 0);
          f = f || {};
          f.path = f.path || "/socket.io";
          this.nsps = {};
          this.subs = [];
          this.opts = f;
          this.reconnection(!1 !== f.reconnection);
          this.reconnectionAttempts(f.reconnectionAttempts || 1 / 0);
          this.reconnectionDelay(f.reconnectionDelay || 1E3);
          this.reconnectionDelayMax(f.reconnectionDelayMax || 5E3);
          this.randomizationFactor(f.randomizationFactor || .5);
          this.backoff = new t({
            min: this.reconnectionDelay(),
            max: this.reconnectionDelayMax(),
            jitter: this.randomizationFactor()
          });
          this.timeout(null == f.timeout ? 2E4 : f.timeout);
          this.readyState = "closed";
          this.uri = a;
          this.connecting = [];
          this.lastPing = null;
          this.encoding = !1;
          this.packetBuffer = [];
          a = f.parser || b;
          this.encoder = new a.Encoder();
          this.decoder = new a.Decoder();
          (this.autoConnect = !1 !== f.autoConnect) && this.open();
        }

        $jscomp.initSymbol();
        $jscomp.initSymbol();
        $jscomp.initSymbolIterator();
        var c = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (a) {
          return _typeof(a);
        } : function (a) {
          $jscomp.initSymbol();
          $jscomp.initSymbol();
          $jscomp.initSymbol();
          return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : _typeof(a);
        },
            g = e(14),
            a = e(39);
        k = e(8);
        var b = e(7),
            q = e(41),
            m = e(42),
            l = e(3)("socket.io-client:manager"),
            v = e(37),
            t = e(43),
            f = Object.prototype.hasOwnProperty;
        h.exports = d;

        d.prototype.emitAll = function () {
          this.emit.apply(this, arguments);

          for (var a in this.nsps) {
            f.call(this.nsps, a) && this.nsps[a].emit.apply(this.nsps[a], arguments);
          }
        };

        d.prototype.updateSocketIds = function () {
          for (var a in this.nsps) {
            f.call(this.nsps, a) && (this.nsps[a].id = this.generateId(a));
          }
        };

        d.prototype.generateId = function (a) {
          return ("/" === a ? "" : a + "#") + this.engine.id;
        };

        k(d.prototype);

        d.prototype.reconnection = function (a) {
          return arguments.length ? (this._reconnection = !!a, this) : this._reconnection;
        };

        d.prototype.reconnectionAttempts = function (a) {
          return arguments.length ? (this._reconnectionAttempts = a, this) : this._reconnectionAttempts;
        };

        d.prototype.reconnectionDelay = function (a) {
          return arguments.length ? (this._reconnectionDelay = a, this.backoff && this.backoff.setMin(a), this) : this._reconnectionDelay;
        };

        d.prototype.randomizationFactor = function (a) {
          return arguments.length ? (this._randomizationFactor = a, this.backoff && this.backoff.setJitter(a), this) : this._randomizationFactor;
        };

        d.prototype.reconnectionDelayMax = function (a) {
          return arguments.length ? (this._reconnectionDelayMax = a, this.backoff && this.backoff.setMax(a), this) : this._reconnectionDelayMax;
        };

        d.prototype.timeout = function (a) {
          return arguments.length ? (this._timeout = a, this) : this._timeout;
        };

        d.prototype.maybeReconnectOnOpen = function () {
          !this.reconnecting && this._reconnection && 0 === this.backoff.attempts && this.reconnect();
        };

        d.prototype.open = d.prototype.connect = function (a, b) {
          if (l("readyState %s", this.readyState), ~this.readyState.indexOf("open")) return this;
          l("opening %s", this.uri);
          var c = this.engine = g(this.uri, this.opts),
              f = this;
          this.readyState = "opening";
          this.skipReconnect = !1;
          var d = q(c, "open", function () {
            f.onopen();
            a && a();
          });
          b = q(c, "error", function (b) {
            if (l("connect_error"), f.cleanup(), f.readyState = "closed", f.emitAll("connect_error", b), a) {
              var c = Error("Connection error");
              c.data = b;
              a(c);
            } else f.maybeReconnectOnOpen();
          });

          if (!1 !== this._timeout) {
            var e = this._timeout;
            l("connect attempt will timeout after %d", e);
            var u = setTimeout(function () {
              l("connect attempt timed out after %d", e);
              d.destroy();
              c.close();
              c.emit("error", "timeout");
              f.emitAll("connect_timeout", e);
            }, e);
            this.subs.push({
              destroy: function destroy() {
                clearTimeout(u);
              }
            });
          }

          return this.subs.push(d), this.subs.push(b), this;
        };

        d.prototype.onopen = function () {
          l("open");
          this.cleanup();
          this.readyState = "open";
          this.emit("open");
          var a = this.engine;
          this.subs.push(q(a, "data", m(this, "ondata")));
          this.subs.push(q(a, "ping", m(this, "onping")));
          this.subs.push(q(a, "pong", m(this, "onpong")));
          this.subs.push(q(a, "error", m(this, "onerror")));
          this.subs.push(q(a, "close", m(this, "onclose")));
          this.subs.push(q(this.decoder, "decoded", m(this, "ondecoded")));
        };

        d.prototype.onping = function () {
          this.lastPing = new Date();
          this.emitAll("ping");
        };

        d.prototype.onpong = function () {
          this.emitAll("pong", new Date() - this.lastPing);
        };

        d.prototype.ondata = function (a) {
          this.decoder.add(a);
        };

        d.prototype.ondecoded = function (a) {
          this.emit("packet", a);
        };

        d.prototype.onerror = function (a) {
          l("error", a);
          this.emitAll("error", a);
        };

        d.prototype.socket = function (b, c) {
          function f() {
            ~v(e.connecting, d) || e.connecting.push(d);
          }

          var d = this.nsps[b];

          if (!d) {
            d = new a(this, b, c);
            this.nsps[b] = d;
            var e = this;
            d.on("connecting", f);
            d.on("connect", function () {
              d.id = e.generateId(b);
            });
            this.autoConnect && f();
          }

          return d;
        };

        d.prototype.destroy = function (a) {
          a = v(this.connecting, a);
          ~a && this.connecting.splice(a, 1);
          this.connecting.length || this.close();
        };

        d.prototype.packet = function (a) {
          l("writing packet %j", a);
          var b = this;
          a.query && 0 === a.type && (a.nsp += "?" + a.query);
          b.encoding ? b.packetBuffer.push(a) : (b.encoding = !0, this.encoder.encode(a, function (c) {
            for (var f = 0; f < c.length; f++) {
              b.engine.write(c[f], a.options);
            }

            b.encoding = !1;
            b.processPacketQueue();
          }));
        };

        d.prototype.processPacketQueue = function () {
          if (0 < this.packetBuffer.length && !this.encoding) {
            var a = this.packetBuffer.shift();
            this.packet(a);
          }
        };

        d.prototype.cleanup = function () {
          l("cleanup");

          for (var a = this.subs.length, b = 0; b < a; b++) {
            this.subs.shift().destroy();
          }

          this.packetBuffer = [];
          this.encoding = !1;
          this.lastPing = null;
          this.decoder.destroy();
        };

        d.prototype.close = d.prototype.disconnect = function () {
          l("disconnect");
          this.skipReconnect = !0;
          this.reconnecting = !1;
          "opening" === this.readyState && this.cleanup();
          this.backoff.reset();
          this.readyState = "closed";
          this.engine && this.engine.close();
        };

        d.prototype.onclose = function (a) {
          l("onclose");
          this.cleanup();
          this.backoff.reset();
          this.readyState = "closed";
          this.emit("close", a);
          this._reconnection && !this.skipReconnect && this.reconnect();
        };

        d.prototype.reconnect = function () {
          if (this.reconnecting || this.skipReconnect) return this;
          var a = this;
          if (this.backoff.attempts >= this._reconnectionAttempts) l("reconnect failed"), this.backoff.reset(), this.emitAll("reconnect_failed"), this.reconnecting = !1;else {
            var b = this.backoff.duration();
            l("will wait %dms before reconnect attempt", b);
            this.reconnecting = !0;
            var c = setTimeout(function () {
              a.skipReconnect || (l("attempting reconnect"), a.emitAll("reconnect_attempt", a.backoff.attempts), a.emitAll("reconnecting", a.backoff.attempts), a.skipReconnect || a.open(function (b) {
                b ? (l("reconnect attempt error"), a.reconnecting = !1, a.reconnect(), a.emitAll("reconnect_error", b.data)) : (l("reconnect success"), a.onreconnect());
              }));
            }, b);
            this.subs.push({
              destroy: function destroy() {
                clearTimeout(c);
              }
            });
          }
        };

        d.prototype.onreconnect = function () {
          var a = this.backoff.attempts;
          this.reconnecting = !1;
          this.backoff.reset();
          this.updateSocketIds();
          this.emitAll("reconnect", a);
        };
      }, function (h, k, e) {
        h.exports = e(15);
      }, function (h, k, e) {
        h.exports = e(16);
        h.exports.parser = e(23);
      }, function (h, k, e) {
        (function (d) {
          function c(a, b) {
            if (!(this instanceof c)) return new c(a, b);
            b = b || {};
            a && "object" == _typeof(a) && (b = a, a = null);
            a ? (a = l(a), b.hostname = a.host, b.secure = "https" === a.protocol || "wss" === a.protocol, b.port = a.port, a.query && (b.query = a.query)) : b.host && (b.hostname = l(b.host).host);
            this.secure = null != b.secure ? b.secure : d.location && "https:" === location.protocol;
            b.hostname && !b.port && (b.port = this.secure ? "443" : "80");
            this.agent = b.agent || !1;
            this.hostname = b.hostname || (d.location ? location.hostname : "localhost");
            this.port = b.port || (d.location && location.port ? location.port : this.secure ? 443 : 80);
            this.query = b.query || {};
            "string" == typeof this.query && (this.query = t.decode(this.query));
            this.upgrade = !1 !== b.upgrade;
            this.path = (b.path || "/engine.io").replace(/\/$/, "") + "/";
            this.forceJSONP = !!b.forceJSONP;
            this.jsonp = !1 !== b.jsonp;
            this.forceBase64 = !!b.forceBase64;
            this.enablesXDR = !!b.enablesXDR;
            this.timestampParam = b.timestampParam || "t";
            this.timestampRequests = b.timestampRequests;
            this.transports = b.transports || ["polling", "websocket"];
            this.transportOptions = b.transportOptions || {};
            this.readyState = "";
            this.writeBuffer = [];
            this.prevBufferLen = 0;
            this.policyPort = b.policyPort || 843;
            this.rememberUpgrade = b.rememberUpgrade || !1;
            this.binaryType = null;
            this.onlyBinaryUpgrades = b.onlyBinaryUpgrades;
            this.perMessageDeflate = !1 !== b.perMessageDeflate && (b.perMessageDeflate || {});
            !0 === this.perMessageDeflate && (this.perMessageDeflate = {});
            this.perMessageDeflate && null == this.perMessageDeflate.threshold && (this.perMessageDeflate.threshold = 1024);
            this.pfx = b.pfx || null;
            this.key = b.key || null;
            this.passphrase = b.passphrase || null;
            this.cert = b.cert || null;
            this.ca = b.ca || null;
            this.ciphers = b.ciphers || null;
            this.rejectUnauthorized = void 0 === b.rejectUnauthorized || b.rejectUnauthorized;
            this.forceNode = !!b.forceNode;
            a = "object" == _typeof(d) && d;
            a.global === a && (b.extraHeaders && 0 < Object.keys(b.extraHeaders).length && (this.extraHeaders = b.extraHeaders), b.localAddress && (this.localAddress = b.localAddress));
            this.pingTimeoutTimer = this.pingIntervalTimer = this.pingTimeout = this.pingInterval = this.upgrades = this.id = null;
            this.open();
          }

          var g = e(17),
              a = e(8),
              b = e(3)("engine.io-client:socket"),
              q = e(37),
              m = e(23),
              l = e(2),
              k = e(38),
              t = e(31);
          h.exports = c;
          c.priorWebsocketSuccess = !1;
          a(c.prototype);
          c.protocol = m.protocol;
          c.Socket = c;
          c.Transport = e(22);
          c.transports = e(17);
          c.parser = e(23);

          c.prototype.createTransport = function (a) {
            b('creating transport "%s"', a);
            var c = this.query,
                f = {},
                d;

            for (d in c) {
              c.hasOwnProperty(d) && (f[d] = c[d]);
            }

            f.EIO = m.protocol;
            f.transport = a;
            c = this.transportOptions[a] || {};
            this.id && (f.sid = this.id);
            return new g[a]({
              query: f,
              socket: this,
              agent: c.agent || this.agent,
              hostname: c.hostname || this.hostname,
              port: c.port || this.port,
              secure: c.secure || this.secure,
              path: c.path || this.path,
              forceJSONP: c.forceJSONP || this.forceJSONP,
              jsonp: c.jsonp || this.jsonp,
              forceBase64: c.forceBase64 || this.forceBase64,
              enablesXDR: c.enablesXDR || this.enablesXDR,
              timestampRequests: c.timestampRequests || this.timestampRequests,
              timestampParam: c.timestampParam || this.timestampParam,
              policyPort: c.policyPort || this.policyPort,
              pfx: c.pfx || this.pfx,
              key: c.key || this.key,
              passphrase: c.passphrase || this.passphrase,
              cert: c.cert || this.cert,
              ca: c.ca || this.ca,
              ciphers: c.ciphers || this.ciphers,
              rejectUnauthorized: c.rejectUnauthorized || this.rejectUnauthorized,
              perMessageDeflate: c.perMessageDeflate || this.perMessageDeflate,
              extraHeaders: c.extraHeaders || this.extraHeaders,
              forceNode: c.forceNode || this.forceNode,
              localAddress: c.localAddress || this.localAddress,
              requestTimeout: c.requestTimeout || this.requestTimeout,
              protocols: c.protocols || void 0
            });
          };

          c.prototype.open = function () {
            if (this.rememberUpgrade && c.priorWebsocketSuccess && -1 !== this.transports.indexOf("websocket")) var a = "websocket";else {
              if (0 === this.transports.length) {
                var b = this;
                return void setTimeout(function () {
                  b.emit("error", "No transports available");
                }, 0);
              }

              a = this.transports[0];
            }
            this.readyState = "opening";

            try {
              a = this.createTransport(a);
            } catch (x) {
              return this.transports.shift(), void this.open();
            }

            a.open();
            this.setTransport(a);
          };

          c.prototype.setTransport = function (a) {
            b("setting transport %s", a.name);
            var c = this;
            this.transport && (b("clearing existing transport %s", this.transport.name), this.transport.removeAllListeners());
            this.transport = a;
            a.on("drain", function () {
              c.onDrain();
            }).on("packet", function (a) {
              c.onPacket(a);
            }).on("error", function (a) {
              c.onError(a);
            }).on("close", function () {
              c.onClose("transport close");
            });
          };

          c.prototype.probe = function (a) {
            function f() {
              if (t.onlyBinaryUpgrades) {
                var f = !this.supportsBinary && t.transport.supportsBinary;
                h = h || f;
              }

              h || (b('probe transport "%s" opened', a), k.send([{
                type: "ping",
                data: "probe"
              }]), k.once("packet", function (f) {
                if (!h) if ("pong" === f.type && "probe" === f.data) {
                  if (b('probe transport "%s" pong', a), t.upgrading = !0, t.emit("upgrading", k), k) c.priorWebsocketSuccess = "websocket" === k.name, b('pausing current transport "%s"', t.transport.name), t.transport.pause(function () {
                    h || "closed" !== t.readyState && (b("changing transport and sending upgrade packet"), q(), t.setTransport(k), k.send([{
                      type: "upgrade"
                    }]), t.emit("upgrade", k), k = null, t.upgrading = !1, t.flush());
                  });
                } else b('probe transport "%s" failed', a), f = Error("probe error"), f.transport = k.name, t.emit("upgradeError", f);
              }));
            }

            function d() {
              h || (h = !0, q(), k.close(), k = null);
            }

            function e(c) {
              var f = Error("probe error: " + c);
              f.transport = k.name;
              d();
              b('probe transport "%s" failed because of error: %s', a, c);
              t.emit("upgradeError", f);
            }

            function g() {
              e("transport closed");
            }

            function l() {
              e("socket closed");
            }

            function m(a) {
              k && a.name !== k.name && (b('"%s" works - aborting "%s"', a.name, k.name), d());
            }

            function q() {
              k.removeListener("open", f);
              k.removeListener("error", e);
              k.removeListener("close", g);
              t.removeListener("close", l);
              t.removeListener("upgrading", m);
            }

            b('probing transport "%s"', a);
            var k = this.createTransport(a, {
              probe: 1
            }),
                h = !1,
                t = this;
            c.priorWebsocketSuccess = !1;
            k.once("open", f);
            k.once("error", e);
            k.once("close", g);
            this.once("close", l);
            this.once("upgrading", m);
            k.open();
          };

          c.prototype.onOpen = function () {
            if (b("socket open"), this.readyState = "open", c.priorWebsocketSuccess = "websocket" === this.transport.name, this.emit("open"), this.flush(), "open" === this.readyState && this.upgrade && this.transport.pause) {
              b("starting upgrade probes");

              for (var a = 0, d = this.upgrades.length; a < d; a++) {
                this.probe(this.upgrades[a]);
              }
            }
          };

          c.prototype.onPacket = function (a) {
            if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) switch (b('socket receive: type "%s", data "%s"', a.type, a.data), this.emit("packet", a), this.emit("heartbeat"), a.type) {
              case "open":
                this.onHandshake(k(a.data));
                break;

              case "pong":
                this.setPing();
                this.emit("pong");
                break;

              case "error":
                var c = Error("server error");
                c.code = a.data;
                this.onError(c);
                break;

              case "message":
                this.emit("data", a.data), this.emit("message", a.data);
            } else b('packet received with socket readyState "%s"', this.readyState);
          };

          c.prototype.onHandshake = function (a) {
            this.emit("handshake", a);
            this.id = a.sid;
            this.transport.query.sid = a.sid;
            this.upgrades = this.filterUpgrades(a.upgrades);
            this.pingInterval = a.pingInterval;
            this.pingTimeout = a.pingTimeout;
            this.onOpen();
            "closed" !== this.readyState && (this.setPing(), this.removeListener("heartbeat", this.onHeartbeat), this.on("heartbeat", this.onHeartbeat));
          };

          c.prototype.onHeartbeat = function (a) {
            clearTimeout(this.pingTimeoutTimer);
            var b = this;
            b.pingTimeoutTimer = setTimeout(function () {
              "closed" !== b.readyState && b.onClose("ping timeout");
            }, a || b.pingInterval + b.pingTimeout);
          };

          c.prototype.setPing = function () {
            var a = this;
            clearTimeout(a.pingIntervalTimer);
            a.pingIntervalTimer = setTimeout(function () {
              b("writing ping packet - expecting pong within %sms", a.pingTimeout);
              a.ping();
              a.onHeartbeat(a.pingTimeout);
            }, a.pingInterval);
          };

          c.prototype.ping = function () {
            var a = this;
            this.sendPacket("ping", function () {
              a.emit("ping");
            });
          };

          c.prototype.onDrain = function () {
            this.writeBuffer.splice(0, this.prevBufferLen);
            this.prevBufferLen = 0;
            0 === this.writeBuffer.length ? this.emit("drain") : this.flush();
          };

          c.prototype.flush = function () {
            "closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length && (b("flushing %d packets in socket", this.writeBuffer.length), this.transport.send(this.writeBuffer), this.prevBufferLen = this.writeBuffer.length, this.emit("flush"));
          };

          c.prototype.write = c.prototype.send = function (a, b, c) {
            return this.sendPacket("message", a, b, c), this;
          };

          c.prototype.sendPacket = function (a, b, c, d) {
            if ("function" == typeof b && (d = b, b = void 0), "function" == typeof c && (d = c, c = null), "closing" !== this.readyState && "closed" !== this.readyState) c = c || {}, c.compress = !1 !== c.compress, a = {
              type: a,
              data: b,
              options: c
            }, this.emit("packetCreate", a), this.writeBuffer.push(a), d && this.once("flush", d), this.flush();
          };

          c.prototype.close = function () {
            function a() {
              e.onClose("forced close");
              b("socket closing - telling transport to close");
              e.transport.close();
            }

            function c() {
              e.removeListener("upgrade", c);
              e.removeListener("upgradeError", c);
              a();
            }

            function d() {
              e.once("upgrade", c);
              e.once("upgradeError", c);
            }

            if ("opening" === this.readyState || "open" === this.readyState) {
              this.readyState = "closing";
              var e = this;
              this.writeBuffer.length ? this.once("drain", function () {
                this.upgrading ? d() : a();
              }) : this.upgrading ? d() : a();
            }

            return this;
          };

          c.prototype.onError = function (a) {
            b("socket error %j", a);
            c.priorWebsocketSuccess = !1;
            this.emit("error", a);
            this.onClose("transport error", a);
          };

          c.prototype.onClose = function (a, c) {
            if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) b('socket close with reason: "%s"', a), clearTimeout(this.pingIntervalTimer), clearTimeout(this.pingTimeoutTimer), this.transport.removeAllListeners("close"), this.transport.close(), this.transport.removeAllListeners(), this.readyState = "closed", this.id = null, this.emit("close", a, c), this.writeBuffer = [], this.prevBufferLen = 0;
          };

          c.prototype.filterUpgrades = function (a) {
            for (var b = [], c = 0, d = a.length; c < d; c++) {
              ~q(this.transports, a[c]) && b.push(a[c]);
            }

            return b;
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k, e) {
        (function (d) {
          var c = e(18),
              g = e(20),
              a = e(34),
              b = e(35);

          k.polling = function (b) {
            var e,
                l = !1,
                k = !1,
                q = !1 !== b.jsonp;
            d.location && (k = "https:" === location.protocol, (l = location.port) || (l = k ? 443 : 80), l = b.hostname !== location.hostname || l !== b.port, k = b.secure !== k);
            if (b.xdomain = l, b.xscheme = k, e = new c(b), "open" in e && !b.forceJSONP) return new g(b);
            if (!q) throw Error("JSONP disabled");
            return new a(b);
          };

          k.websocket = b;
        }).call(k, function () {
          return this;
        }());
      }, function (h, k, e) {
        (function (d) {
          var c = e(19);

          h.exports = function (e) {
            var a = e.xdomain,
                b = e.xscheme;
            e = e.enablesXDR;

            try {
              if ("undefined" != typeof XMLHttpRequest && (!a || c)) return new XMLHttpRequest();
            } catch (q) {}

            try {
              if ("undefined" != typeof XDomainRequest && !b && e) return new XDomainRequest();
            } catch (q) {}

            if (!a) try {
              return new d[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
            } catch (q) {}
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k) {
        try {
          h.exports = "undefined" != typeof XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
        } catch (e) {
          h.exports = !1;
        }
      }, function (h, k, e) {
        (function (d) {
          function c() {}

          function g(a) {
            if (m.call(this, a), this.requestTimeout = a.requestTimeout, this.extraHeaders = a.extraHeaders, d.location) {
              var b = "https:" === location.protocol,
                  c = location.port;
              c || (c = b ? 443 : 80);
              this.xd = a.hostname !== d.location.hostname || c !== a.port;
              this.xs = a.secure !== b;
            }
          }

          function a(a) {
            this.method = a.method || "GET";
            this.uri = a.uri;
            this.xd = !!a.xd;
            this.xs = !!a.xs;
            this.async = !1 !== a.async;
            this.data = void 0 !== a.data ? a.data : null;
            this.agent = a.agent;
            this.isBinary = a.isBinary;
            this.supportsBinary = a.supportsBinary;
            this.enablesXDR = a.enablesXDR;
            this.requestTimeout = a.requestTimeout;
            this.pfx = a.pfx;
            this.key = a.key;
            this.passphrase = a.passphrase;
            this.cert = a.cert;
            this.ca = a.ca;
            this.ciphers = a.ciphers;
            this.rejectUnauthorized = a.rejectUnauthorized;
            this.extraHeaders = a.extraHeaders;
            this.create();
          }

          function b() {
            for (var b in a.requests) {
              a.requests.hasOwnProperty(b) && a.requests[b].abort();
            }
          }

          var k = e(18),
              m = e(21),
              l = e(8),
              v = e(32),
              t = e(3)("engine.io-client:polling-xhr");
          h.exports = g;
          h.exports.Request = a;
          v(g, m);
          g.prototype.supportsBinary = !0;

          g.prototype.request = function (b) {
            return b = b || {}, b.uri = this.uri(), b.xd = this.xd, b.xs = this.xs, b.agent = this.agent || !1, b.supportsBinary = this.supportsBinary, b.enablesXDR = this.enablesXDR, b.pfx = this.pfx, b.key = this.key, b.passphrase = this.passphrase, b.cert = this.cert, b.ca = this.ca, b.ciphers = this.ciphers, b.rejectUnauthorized = this.rejectUnauthorized, b.requestTimeout = this.requestTimeout, b.extraHeaders = this.extraHeaders, new a(b);
          };

          g.prototype.doWrite = function (a, b) {
            a = this.request({
              method: "POST",
              data: a,
              isBinary: "string" != typeof a && void 0 !== a
            });
            var c = this;
            a.on("success", b);
            a.on("error", function (a) {
              c.onError("xhr post error", a);
            });
            this.sendXhr = a;
          };

          g.prototype.doPoll = function () {
            t("xhr poll");
            var a = this.request(),
                b = this;
            a.on("data", function (a) {
              b.onData(a);
            });
            a.on("error", function (a) {
              b.onError("xhr poll error", a);
            });
            this.pollXhr = a;
          };

          l(a.prototype);

          a.prototype.create = function () {
            var b = {
              agent: this.agent,
              xdomain: this.xd,
              xscheme: this.xs,
              enablesXDR: this.enablesXDR
            };
            b.pfx = this.pfx;
            b.key = this.key;
            b.passphrase = this.passphrase;
            b.cert = this.cert;
            b.ca = this.ca;
            b.ciphers = this.ciphers;
            b.rejectUnauthorized = this.rejectUnauthorized;
            var c = this.xhr = new k(b),
                e = this;

            try {
              t("xhr open %s: %s", this.method, this.uri);
              c.open(this.method, this.uri, this.async);

              try {
                if (this.extraHeaders) {
                  c.setDisableHeaderCheck && c.setDisableHeaderCheck(!0);

                  for (var g in this.extraHeaders) {
                    this.extraHeaders.hasOwnProperty(g) && c.setRequestHeader(g, this.extraHeaders[g]);
                  }
                }
              } catch (y) {}

              if ("POST" === this.method) try {
                this.isBinary ? c.setRequestHeader("Content-type", "application/octet-stream") : c.setRequestHeader("Content-type", "text/plain;charset\x3dUTF-8");
              } catch (y) {}

              try {
                c.setRequestHeader("Accept", "*/*");
              } catch (y) {}

              "withCredentials" in c && (c.withCredentials = !0);
              this.requestTimeout && (c.timeout = this.requestTimeout);
              this.hasXDR() ? (c.onload = function () {
                e.onLoad();
              }, c.onerror = function () {
                e.onError(c.responseText);
              }) : c.onreadystatechange = function () {
                if (2 === c.readyState) {
                  try {
                    var a = c.getResponseHeader("Content-Type");
                  } catch (z) {}

                  "application/octet-stream" === a && (c.responseType = "arraybuffer");
                }

                4 === c.readyState && (200 === c.status || 1223 === c.status ? e.onLoad() : setTimeout(function () {
                  e.onError(c.status);
                }, 0));
              };
              t("xhr data %s", this.data);
              c.send(this.data);
            } catch (y) {
              return void setTimeout(function () {
                e.onError(y);
              }, 0);
            }

            d.document && (this.index = a.requestsCount++, a.requests[this.index] = this);
          };

          a.prototype.onSuccess = function () {
            this.emit("success");
            this.cleanup();
          };

          a.prototype.onData = function (a) {
            this.emit("data", a);
            this.onSuccess();
          };

          a.prototype.onError = function (a) {
            this.emit("error", a);
            this.cleanup(!0);
          };

          a.prototype.cleanup = function (b) {
            if ("undefined" != typeof this.xhr && null !== this.xhr) {
              if (this.hasXDR() ? this.xhr.onload = this.xhr.onerror = c : this.xhr.onreadystatechange = c, b) try {
                this.xhr.abort();
              } catch (u) {}
              d.document && delete a.requests[this.index];
              this.xhr = null;
            }
          };

          a.prototype.onLoad = function () {
            try {
              try {
                var a = this.xhr.getResponseHeader("Content-Type");
              } catch (x) {}

              var b = "application/octet-stream" === a ? this.xhr.response || this.xhr.responseText : this.xhr.responseText;
            } catch (x) {
              this.onError(x);
            }

            null != b && this.onData(b);
          };

          a.prototype.hasXDR = function () {
            return "undefined" != typeof d.XDomainRequest && !this.xs && this.enablesXDR;
          };

          a.prototype.abort = function () {
            this.cleanup();
          };

          a.requestsCount = 0;
          a.requests = {};
          d.document && (d.attachEvent ? d.attachEvent("onunload", b) : d.addEventListener && d.addEventListener("beforeunload", b, !1));
        }).call(k, function () {
          return this;
        }());
      }, function (h, k, e) {
        function d(a) {
          var b = a && a.forceBase64;
          m && !b || (this.supportsBinary = !1);
          c.call(this, a);
        }

        var c = e(22),
            g = e(31),
            a = e(23);
        k = e(32);
        var b = e(33),
            q = e(3)("engine.io-client:polling");
        h.exports = d;
        var m = null != new (e(18))({
          xdomain: !1
        }).responseType;
        k(d, c);
        d.prototype.name = "polling";

        d.prototype.doOpen = function () {
          this.poll();
        };

        d.prototype.pause = function (a) {
          function b() {
            q("paused");
            c.readyState = "paused";
            a();
          }

          var c = this;

          if (this.readyState = "pausing", this.polling || !this.writable) {
            var d = 0;
            this.polling && (q("we are currently polling - waiting to pause"), d++, this.once("pollComplete", function () {
              q("pre-pause polling complete");
              --d || b();
            }));
            this.writable || (q("we are currently writing - waiting to pause"), d++, this.once("drain", function () {
              q("pre-pause writing complete");
              --d || b();
            }));
          } else b();
        };

        d.prototype.poll = function () {
          q("polling");
          this.polling = !0;
          this.doPoll();
          this.emit("poll");
        };

        d.prototype.onData = function (b) {
          var c = this;
          q("polling got data %s", b);
          a.decodePayload(b, this.socket.binaryType, function (a, b, d) {
            return "opening" === c.readyState && c.onOpen(), "close" === a.type ? (c.onClose(), !1) : void c.onPacket(a);
          });
          "closed" !== this.readyState && (this.polling = !1, this.emit("pollComplete"), "open" === this.readyState ? this.poll() : q('ignoring poll - transport state "%s"', this.readyState));
        };

        d.prototype.doClose = function () {
          function a() {
            q("writing close packet");
            b.write([{
              type: "close"
            }]);
          }

          var b = this;
          "open" === this.readyState ? (q("transport open - closing"), a()) : (q("transport not open - deferring close"), this.once("open", a));
        };

        d.prototype.write = function (b) {
          var c = this;
          this.writable = !1;

          var d = function d() {
            c.writable = !0;
            c.emit("drain");
          };

          a.encodePayload(b, this.supportsBinary, function (a) {
            c.doWrite(a, d);
          });
        };

        d.prototype.uri = function () {
          var a = this.query || {},
              c = this.secure ? "https" : "http",
              d = "";
          !1 !== this.timestampRequests && (a[this.timestampParam] = b());
          this.supportsBinary || a.sid || (a.b64 = 1);
          a = g.encode(a);
          this.port && ("https" === c && 443 !== Number(this.port) || "http" === c && 80 !== Number(this.port)) && (d = ":" + this.port);
          a.length && (a = "?" + a);
          var f = -1 !== this.hostname.indexOf(":");
          return c + "://" + (f ? "[" + this.hostname + "]" : this.hostname) + d + this.path + a;
        };
      }, function (h, k, e) {
        function d(c) {
          this.path = c.path;
          this.hostname = c.hostname;
          this.port = c.port;
          this.secure = c.secure;
          this.query = c.query;
          this.timestampParam = c.timestampParam;
          this.timestampRequests = c.timestampRequests;
          this.readyState = "";
          this.agent = c.agent || !1;
          this.socket = c.socket;
          this.enablesXDR = c.enablesXDR;
          this.pfx = c.pfx;
          this.key = c.key;
          this.passphrase = c.passphrase;
          this.cert = c.cert;
          this.ca = c.ca;
          this.ciphers = c.ciphers;
          this.rejectUnauthorized = c.rejectUnauthorized;
          this.forceNode = c.forceNode;
          this.extraHeaders = c.extraHeaders;
          this.localAddress = c.localAddress;
        }

        var c = e(23);
        k = e(8);
        h.exports = d;
        k(d.prototype);

        d.prototype.onError = function (c, a) {
          c = Error(c);
          return c.type = "TransportError", c.description = a, this.emit("error", c), this;
        };

        d.prototype.open = function () {
          return "closed" !== this.readyState && "" !== this.readyState || (this.readyState = "opening", this.doOpen()), this;
        };

        d.prototype.close = function () {
          return "opening" !== this.readyState && "open" !== this.readyState || (this.doClose(), this.onClose()), this;
        };

        d.prototype.send = function (c) {
          if ("open" !== this.readyState) throw Error("Transport not open");
          this.write(c);
        };

        d.prototype.onOpen = function () {
          this.readyState = "open";
          this.writable = !0;
          this.emit("open");
        };

        d.prototype.onData = function (d) {
          d = c.decodePacket(d, this.socket.binaryType);
          this.onPacket(d);
        };

        d.prototype.onPacket = function (c) {
          this.emit("packet", c);
        };

        d.prototype.onClose = function () {
          this.readyState = "closed";
          this.emit("close");
        };
      }, function (h, k, e) {
        (function (d) {
          function c(a, b, c) {
            if (!b) return k.encodeBase64Packet(a, c);
            var d = new FileReader();
            return d.onload = function () {
              a.data = d.result;
              k.encodePacket(a, b, !0, c);
            }, d.readAsArrayBuffer(a.data);
          }

          function g(a, b, c) {
            var d = Array(a.length);
            c = l(a.length, c);

            for (var f = function f(a, c, _f) {
              b(c, function (b, c) {
                d[a] = c;

                _f(b, d);
              });
            }, e = 0; e < a.length; e++) {
              f(e, a[e], c);
            }
          }

          var a,
              b = e(24),
              q = e(9),
              m = e(25),
              l = e(26),
              h = e(27);
          d && d.ArrayBuffer && (a = e(29));
          var t = "undefined" != typeof navigator && /Android/i.test(navigator.userAgent),
              f = "undefined" != typeof navigator && /PhantomJS/i.test(navigator.userAgent),
              u = t || f;
          k.protocol = 3;
          var x = k.packets = {
            open: 0,
            close: 1,
            ping: 2,
            pong: 3,
            message: 4,
            upgrade: 5,
            noop: 6
          },
              w = b(x),
              y = {
            type: "error",
            data: "parser error"
          },
              n = e(30);

          k.encodePacket = function (a, b, f, e) {
            "function" == typeof b && (e = b, b = !1);
            "function" == typeof f && (e = f, f = null);
            var g = void 0 === a.data ? void 0 : a.data.buffer || a.data;

            if (d.ArrayBuffer && g instanceof ArrayBuffer) {
              if (b) {
                f = a.data;
                b = new Uint8Array(f);
                f = new Uint8Array(1 + f.byteLength);
                f[0] = x[a.type];

                for (a = 0; a < b.length; a++) {
                  f[a + 1] = b[a];
                }

                a = e(f.buffer);
              } else a = k.encodeBase64Packet(a, e);

              return a;
            }

            if (n && g instanceof d.Blob) return b ? u ? a = c(a, b, e) : (b = new Uint8Array(1), b[0] = x[a.type], a = new n([b.buffer, a.data]), a = e(a)) : a = k.encodeBase64Packet(a, e), a;
            if (g && g.base64) return e("b" + k.packets[a.type] + a.data.data);
            b = x[a.type];
            return void 0 !== a.data && (b += f ? h.encode(String(a.data), {
              strict: !1
            }) : String(a.data)), e("" + b);
          };

          k.encodeBase64Packet = function (a, b) {
            var c = "b" + k.packets[a.type];

            if (n && a.data instanceof d.Blob) {
              var f = new FileReader();
              return f.onload = function () {
                var a = f.result.split(",")[1];
                b(c + a);
              }, f.readAsDataURL(a.data);
            }

            try {
              var e = String.fromCharCode.apply(null, new Uint8Array(a.data));
            } catch (Q) {
              a = new Uint8Array(a.data);
              e = Array(a.length);

              for (var g = 0; g < a.length; g++) {
                e[g] = a[g];
              }

              e = String.fromCharCode.apply(null, e);
            }

            return c += d.btoa(e), b(c);
          };

          k.decodePacket = function (a, b, c) {
            if (void 0 === a) return y;

            if ("string" == typeof a) {
              if ("b" === a.charAt(0)) return k.decodeBase64Packet(a.substr(1), b);

              if (b = c) {
                b = a;

                try {
                  b = h.decode(b, {
                    strict: !1
                  });
                } catch (G) {
                  b = !1;
                }

                b = (a = b, !1 === a);
              }

              if (b) return y;
              c = a.charAt(0);
              return Number(c) == c && w[c] ? 1 < a.length ? {
                type: w[c],
                data: a.substring(1)
              } : {
                type: w[c]
              } : y;
            }

            c = new Uint8Array(a)[0];
            a = m(a, 1);
            return n && "blob" === b && (a = new n([a])), {
              type: w[c],
              data: a
            };
          };

          k.decodeBase64Packet = function (b, c) {
            var d = w[b.charAt(0)];
            if (!a) return {
              type: d,
              data: {
                base64: !0,
                data: b.substr(1)
              }
            };
            b = a.decode(b.substr(1));
            return "blob" === c && n && (b = new n([b])), {
              type: d,
              data: b
            };
          };

          k.encodePayload = function (a, b, c) {
            function d(a, c) {
              k.encodePacket(a, !!f && b, !1, function (a) {
                c(null, a.length + ":" + a);
              });
            }

            "function" == typeof b && (c = b, b = null);
            var f = q(a);
            return b && f ? n && !u ? k.encodePayloadAsBlob(a, c) : k.encodePayloadAsArrayBuffer(a, c) : a.length ? void g(a, d, function (a, b) {
              return c(b.join(""));
            }) : c("0:");
          };

          k.decodePayload = function (a, b, c) {
            if ("string" != typeof a) return k.decodePayloadAsBinary(a, b, c);
            "function" == typeof b && (c = b, b = null);
            var d;
            if ("" === a) return c(y, 0, 1);

            for (var f, e, g = "", l = 0, m = a.length; l < m; l++) {
              var q = a.charAt(l);

              if (":" === q) {
                if ("" === g || g != (f = Number(g)) || (e = a.substr(l + 1, f), g != e.length)) return c(y, 0, 1);

                if (e.length) {
                  if (d = k.decodePacket(e, b, !1), y.type === d.type && y.data === d.data) return c(y, 0, 1);
                  if (!1 === c(d, l + f, m)) return;
                }

                l += f;
                g = "";
              } else g += q;
            }

            return "" !== g ? c(y, 0, 1) : void 0;
          };

          k.encodePayloadAsArrayBuffer = function (a, b) {
            function c(a, b) {
              k.encodePacket(a, !0, !0, function (a) {
                return b(null, a);
              });
            }

            return a.length ? void g(a, c, function (a, c) {
              a = c.reduce(function (a, b) {
                var c;
                return c = "string" == typeof b ? b.length : b.byteLength, a + c.toString().length + c + 2;
              }, 0);
              var d = new Uint8Array(a),
                  f = 0;
              return c.forEach(function (a) {
                var b = "string" == typeof a,
                    c = a;

                if (b) {
                  c = new Uint8Array(a.length);

                  for (var e = 0; e < a.length; e++) {
                    c[e] = a.charCodeAt(e);
                  }

                  c = c.buffer;
                }

                b ? d[f++] = 0 : d[f++] = 1;
                a = c.byteLength.toString();

                for (e = 0; e < a.length; e++) {
                  d[f++] = parseInt(a[e]);
                }

                d[f++] = 255;
                c = new Uint8Array(c);

                for (e = 0; e < c.length; e++) {
                  d[f++] = c[e];
                }
              }), b(d.buffer);
            }) : b(new ArrayBuffer(0));
          };

          k.encodePayloadAsBlob = function (a, b) {
            g(a, function (a, b) {
              k.encodePacket(a, !0, !0, function (a) {
                var c = new Uint8Array(1);

                if (c[0] = 1, "string" == typeof a) {
                  for (var d = new Uint8Array(a.length), f = 0; f < a.length; f++) {
                    d[f] = a.charCodeAt(f);
                  }

                  a = d.buffer;
                  c[0] = 0;
                }

                d = (a instanceof ArrayBuffer ? a.byteLength : a.size).toString();
                var e = new Uint8Array(d.length + 1);

                for (f = 0; f < d.length; f++) {
                  e[f] = parseInt(d[f]);
                }

                if (e[d.length] = 255, n) a = new n([c.buffer, e.buffer, a]), b(null, a);
              });
            }, function (a, c) {
              return b(new n(c));
            });
          };

          k.decodePayloadAsBinary = function (a, b, c) {
            "function" == typeof b && (c = b, b = null);

            for (var d = []; 0 < a.byteLength;) {
              for (var f = new Uint8Array(a), e = 0 === f[0], g = "", l = 1; 255 !== f[l]; l++) {
                if (310 < g.length) return c(y, 0, 1);
                g += f[l];
              }

              a = m(a, 2 + g.length);
              g = parseInt(g);
              f = m(a, 0, g);
              if (e) try {
                f = String.fromCharCode.apply(null, new Uint8Array(f));
              } catch (H) {
                for (e = new Uint8Array(f), f = "", l = 0; l < e.length; l++) {
                  f += String.fromCharCode(e[l]);
                }
              }
              d.push(f);
              a = m(a, g);
            }

            var q = d.length;
            d.forEach(function (a, d) {
              c(k.decodePacket(a, b, !0), d, q);
            });
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k) {
        h.exports = Object.keys || function (e) {
          var d = [],
              c = Object.prototype.hasOwnProperty,
              g;

          for (g in e) {
            c.call(e, g) && d.push(g);
          }

          return d;
        };
      }, function (h, k) {
        h.exports = function (e, d, c) {
          var g = e.byteLength;
          if (d = d || 0, c = c || g, e.slice) return e.slice(d, c);
          if (0 > d && (d += g), 0 > c && (c += g), c > g && (c = g), d >= g || d >= c || 0 === g) return new ArrayBuffer(0);
          e = new Uint8Array(e);
          g = new Uint8Array(c - d);

          for (var a = 0; d < c; d++, a++) {
            g[a] = e[d];
          }

          return g.buffer;
        };
      }, function (h, k) {
        function e() {}

        h.exports = function (d, c, g) {
          function a(d, e) {
            if (0 >= a.count) throw Error("after called too many times");
            --a.count;
            d ? (b = !0, c(d), c = g) : 0 !== a.count || b || c(null, e);
          }

          var b = !1;
          return g = g || e, a.count = d, 0 === d ? c() : a;
        };
      }, function (h, k, e) {
        var d;
        (function (c, e) {
          !function (a) {
            function b(a) {
              for (var b, c, d = [], f = 0, e = a.length; f < e;) {
                b = a.charCodeAt(f++), 55296 <= b && 56319 >= b && f < e ? (c = a.charCodeAt(f++), 56320 == (64512 & c) ? d.push(((1023 & b) << 10) + (1023 & c) + 65536) : (d.push(b), f--)) : d.push(b);
              }

              return d;
            }

            function e(a, b) {
              if (55296 <= a && 57343 >= a) {
                if (b) throw Error("Lone surrogate U+" + a.toString(16).toUpperCase() + " is not a scalar value");
                return !1;
              }

              return !0;
            }

            function g() {
              if (f >= t) throw Error("Invalid byte index");
              var a = 255 & h[f];
              if (f++, 128 == (192 & a)) return 63 & a;
              throw Error("Invalid continuation byte");
            }

            function l(a) {
              var b, c, d, l, k;
              if (f > t) throw Error("Invalid byte index");
              if (f == t) return !1;
              if (b = 255 & h[f], f++, 0 == (128 & b)) return b;

              if (192 == (224 & b)) {
                if (c = g(), k = (31 & b) << 6 | c, 128 <= k) return k;
                throw Error("Invalid continuation byte");
              }

              if (224 == (240 & b)) {
                if (c = g(), d = g(), k = (15 & b) << 12 | c << 6 | d, 2048 <= k) return e(k, a) ? k : 65533;
                throw Error("Invalid continuation byte");
              }

              if (240 == (248 & b) && (c = g(), d = g(), l = g(), k = (7 & b) << 18 | c << 12 | d << 6 | l, 65536 <= k && 1114111 >= k)) return k;
              throw Error("Invalid UTF-8 detected");
            }

            a = "object" == _typeof(k) && k;
            "object" == _typeof(c) && c && c.exports == a && c;
            var h,
                t,
                f,
                u = String.fromCharCode;
            d = {
              version: "2.1.2",
              encode: function encode(a, c) {
                c = c || {};
                c = !1 !== c.strict;
                a = b(a);

                for (var d = a.length, f = -1, g = ""; ++f < d;) {
                  var l = a[f];
                  var k = c;
                  if (0 == (4294967168 & l)) k = u(l);else {
                    var m = "";
                    k = (0 == (4294965248 & l) ? m = u(l >> 6 & 31 | 192) : 0 == (4294901760 & l) ? (e(l, k) || (l = 65533), m = u(l >> 12 & 15 | 224), m += u(l >> 6 & 63 | 128)) : 0 == (4292870144 & l) && (m = u(l >> 18 & 7 | 240), m += u(l >> 12 & 63 | 128), m += u(l >> 6 & 63 | 128)), m + u(63 & l | 128));
                  }
                  g += k;
                }

                return g;
              },
              decode: function decode(a, c) {
                c = c || {};
                c = !1 !== c.strict;
                h = b(a);
                t = h.length;
                f = 0;
                var d;

                for (a = []; !1 !== (d = l(c));) {
                  a.push(d);
                }

                d = a.length;

                for (var e = -1, g = ""; ++e < d;) {
                  c = a[e], 65535 < c && (c -= 65536, g += u(c >>> 10 & 1023 | 55296), c = 56320 | 1023 & c), g += u(c);
                }

                return g;
              }
            };
            !(void 0 !== d && (c.exports = d));
          }(this);
        }).call(k, e(28)(h), function () {
          return this;
        }());
      }, function (h, k) {
        h.exports = function (e) {
          return e.webpackPolyfill || (e.deprecate = function () {}, e.paths = [], e.children = [], e.webpackPolyfill = 1), e;
        };
      }, function (h, k) {
        !function () {
          for (var e = new Uint8Array(256), d = 0; 64 > d; d++) {
            e["ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".charCodeAt(d)] = d;
          }

          k.encode = function (c) {
            var d = new Uint8Array(c),
                a = d.length,
                b = "";

            for (c = 0; c < a; c += 3) {
              b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[d[c] >> 2], b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(3 & d[c]) << 4 | d[c + 1] >> 4], b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(15 & d[c + 1]) << 2 | d[c + 2] >> 6], b += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[63 & d[c + 2]];
            }

            return 2 === a % 3 ? b = b.substring(0, b.length - 1) + "\x3d" : 1 === a % 3 && (b = b.substring(0, b.length - 2) + "\x3d\x3d"), b;
          };

          k.decode = function (c) {
            var d = .75 * c.length;
            var a = c.length,
                b = 0;
            "\x3d" === c[c.length - 1] && (d--, "\x3d" === c[c.length - 2] && d--);
            var k = new ArrayBuffer(d),
                m = new Uint8Array(k);

            for (d = 0; d < a; d += 4) {
              var l = e[c.charCodeAt(d)];
              var h = e[c.charCodeAt(d + 1)];
              var t = e[c.charCodeAt(d + 2)];
              var f = e[c.charCodeAt(d + 3)];
              m[b++] = l << 2 | h >> 4;
              m[b++] = (15 & h) << 4 | t >> 2;
              m[b++] = (3 & t) << 6 | 63 & f;
            }

            return k;
          };
        }();
      }, function (h, k) {
        (function (e) {
          function d(a) {
            for (var b = 0; b < a.length; b++) {
              var c = a[b];

              if (c.buffer instanceof ArrayBuffer) {
                var d = c.buffer;

                if (c.byteLength !== d.byteLength) {
                  var e = new Uint8Array(c.byteLength);
                  e.set(new Uint8Array(d, c.byteOffset, c.byteLength));
                  d = e.buffer;
                }

                a[b] = d;
              }
            }
          }

          function c(b, c) {
            c = c || {};
            var e = new a();
            d(b);

            for (var f = 0; f < b.length; f++) {
              e.append(b[f]);
            }

            return c.type ? e.getBlob(c.type) : e.getBlob();
          }

          function g(a, b) {
            return d(a), new Blob(a, b || {});
          }

          var a = e.BlobBuilder || e.WebKitBlobBuilder || e.MSBlobBuilder || e.MozBlobBuilder;

          try {
            var b = 2 === new Blob(["hi"]).size;
          } catch (l) {
            b = !1;
          }

          var k;
          if (k = b) try {
            k = 2 === new Blob([new Uint8Array([1, 2])]).size;
          } catch (l) {
            k = !1;
          }
          var m = a && a.prototype.append && a.prototype.getBlob;
          h.exports = b ? k ? e.Blob : g : m ? c : void 0;
        }).call(k, function () {
          return this;
        }());
      }, function (h, k) {
        k.encode = function (e) {
          var d = "",
              c;

          for (c in e) {
            e.hasOwnProperty(c) && (d.length && (d += "\x26"), d += encodeURIComponent(c) + "\x3d" + encodeURIComponent(e[c]));
          }

          return d;
        };

        k.decode = function (e) {
          var d = {};
          e = e.split("\x26");

          for (var c = 0, g = e.length; c < g; c++) {
            var a = e[c].split("\x3d");
            d[decodeURIComponent(a[0])] = decodeURIComponent(a[1]);
          }

          return d;
        };
      }, function (h, k) {
        h.exports = function (e, d) {
          var c = function c() {};

          c.prototype = d.prototype;
          e.prototype = new c();
          e.prototype.constructor = e;
        };
      }, function (h, k) {
        function e(b) {
          var c = "";

          do {
            c = g[b % a] + c, b = Math.floor(b / a);
          } while (0 < b);

          return c;
        }

        function d() {
          var a = e(+new Date());
          return a !== c ? (q = 0, c = a) : a + "." + e(q++);
        }

        for (var c, g = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split(""), a = 64, b = {}, q = 0, m = 0; m < a; m++) {
          b[g[m]] = m;
        }

        d.encode = e;

        d.decode = function (c) {
          var d = 0;

          for (m = 0; m < c.length; m++) {
            d = d * a + b[c.charAt(m)];
          }

          return d;
        };

        h.exports = d;
      }, function (h, k, e) {
        (function (d) {
          function c() {}

          function g(b) {
            a.call(this, b);
            this.query = this.query || {};
            k || (d.___eio || (d.___eio = []), k = d.___eio);
            this.index = k.length;
            var e = this;
            k.push(function (a) {
              e.onData(a);
            });
            this.query.j = this.index;
            d.document && d.addEventListener && d.addEventListener("beforeunload", function () {
              e.script && (e.script.onerror = c);
            }, !1);
          }

          var a = e(21),
              b = e(32);
          h.exports = g;
          var k,
              m = /\n/g,
              l = /\\n/g;
          b(g, a);
          g.prototype.supportsBinary = !1;

          g.prototype.doClose = function () {
            this.script && (this.script.parentNode.removeChild(this.script), this.script = null);
            this.form && (this.form.parentNode.removeChild(this.form), this.form = null, this.iframe = null);
            a.prototype.doClose.call(this);
          };

          g.prototype.doPoll = function () {
            var a = this,
                b = document.createElement("script");
            this.script && (this.script.parentNode.removeChild(this.script), this.script = null);
            b.async = !0;
            b.src = this.uri();

            b.onerror = function (b) {
              a.onError("jsonp poll error", b);
            };

            var c = document.getElementsByTagName("script")[0];
            c ? c.parentNode.insertBefore(b, c) : (document.head || document.body).appendChild(b);
            this.script = b;
            "undefined" != typeof navigator && /gecko/i.test(navigator.userAgent) && setTimeout(function () {
              var a = document.createElement("iframe");
              document.body.appendChild(a);
              document.body.removeChild(a);
            }, 100);
          };

          g.prototype.doWrite = function (a, b) {
            function c() {
              d();
              b();
            }

            function d() {
              if (g.iframe) try {
                g.form.removeChild(g.iframe);
              } catch (C) {
                g.onError("jsonp polling iframe removal error", C);
              }

              try {
                e = document.createElement('\x3ciframe src\x3d"javascript:0" name\x3d"' + g.iframeId + '"\x3e');
              } catch (C) {
                e = document.createElement("iframe"), e.name = g.iframeId, e.src = "javascript:0";
              }

              e.id = g.iframeId;
              g.form.appendChild(e);
              g.iframe = e;
            }

            var e,
                g = this;

            if (!this.form) {
              var k = document.createElement("form"),
                  q = document.createElement("textarea"),
                  h = this.iframeId = "eio_iframe_" + this.index;
              k.className = "socketio";
              k.style.position = "absolute";
              k.style.top = "-1000px";
              k.style.left = "-1000px";
              k.target = h;
              k.method = "POST";
              k.setAttribute("accept-charset", "utf-8");
              q.name = "d";
              k.appendChild(q);
              document.body.appendChild(k);
              this.form = k;
              this.area = q;
            }

            this.form.action = this.uri();
            d();
            a = a.replace(l, "\\\n");
            this.area.value = a.replace(m, "\\n");

            try {
              this.form.submit();
            } catch (C) {}

            this.iframe.attachEvent ? this.iframe.onreadystatechange = function () {
              "complete" === g.iframe.readyState && c();
            } : this.iframe.onload = c;
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k, e) {
        (function (d) {
          function c(a) {
            a && a.forceBase64 && (this.supportsBinary = !1);
            this.perMessageDeflate = a.perMessageDeflate;
            this.usingBrowserWebSocket = v && !a.forceNode;
            this.protocols = a.protocols;
            this.usingBrowserWebSocket || (f = t);
            g.call(this, a);
          }

          var g = e(22),
              a = e(23),
              b = e(31),
              k = e(32),
              m = e(33),
              l = e(3)("engine.io-client:websocket"),
              v = d.WebSocket || d.MozWebSocket;
          if ("undefined" == typeof window) try {
            var t = e(36);
          } catch (u) {}
          var f = v;
          f || "undefined" != typeof window || (f = t);
          h.exports = c;
          k(c, g);
          c.prototype.name = "websocket";
          c.prototype.supportsBinary = !0;

          c.prototype.doOpen = function () {
            if (this.check()) {
              var a = this.uri(),
                  b = this.protocols,
                  c = {
                agent: this.agent,
                perMessageDeflate: this.perMessageDeflate
              };
              c.pfx = this.pfx;
              c.key = this.key;
              c.passphrase = this.passphrase;
              c.cert = this.cert;
              c.ca = this.ca;
              c.ciphers = this.ciphers;
              c.rejectUnauthorized = this.rejectUnauthorized;
              this.extraHeaders && (c.headers = this.extraHeaders);
              this.localAddress && (c.localAddress = this.localAddress);

              try {
                this.ws = this.usingBrowserWebSocket ? b ? new f(a, b) : new f(a) : new f(a, b, c);
              } catch (y) {
                return this.emit("error", y);
              }

              void 0 === this.ws.binaryType && (this.supportsBinary = !1);
              this.ws.supports && this.ws.supports.binary ? (this.supportsBinary = !0, this.ws.binaryType = "nodebuffer") : this.ws.binaryType = "arraybuffer";
              this.addEventListeners();
            }
          };

          c.prototype.addEventListeners = function () {
            var a = this;

            this.ws.onopen = function () {
              a.onOpen();
            };

            this.ws.onclose = function () {
              a.onClose();
            };

            this.ws.onmessage = function (b) {
              a.onData(b.data);
            };

            this.ws.onerror = function (b) {
              a.onError("websocket error", b);
            };
          };

          c.prototype.write = function (b) {
            function c() {
              f.emit("flush");
              setTimeout(function () {
                f.writable = !0;
                f.emit("drain");
              }, 0);
            }

            var f = this;
            this.writable = !1;

            for (var e = b.length, g = 0, k = e; g < k; g++) {
              !function (b) {
                a.encodePacket(b, f.supportsBinary, function (a) {
                  if (!f.usingBrowserWebSocket) {
                    var g = {};
                    (b.options && (g.compress = b.options.compress), f.perMessageDeflate) && ("string" == typeof a ? d.Buffer.byteLength(a) : a.length) < f.perMessageDeflate.threshold && (g.compress = !1);
                  }

                  try {
                    f.usingBrowserWebSocket ? f.ws.send(a) : f.ws.send(a, g);
                  } catch (D) {
                    l("websocket closed before onclose event");
                  }

                  --e || c();
                });
              }(b[g]);
            }
          };

          c.prototype.onClose = function () {
            g.prototype.onClose.call(this);
          };

          c.prototype.doClose = function () {
            "undefined" != typeof this.ws && this.ws.close();
          };

          c.prototype.uri = function () {
            var a = this.query || {},
                c = this.secure ? "wss" : "ws",
                d = "";
            this.port && ("wss" === c && 443 !== Number(this.port) || "ws" === c && 80 !== Number(this.port)) && (d = ":" + this.port);
            this.timestampRequests && (a[this.timestampParam] = m());
            this.supportsBinary || (a.b64 = 1);
            a = b.encode(a);
            a.length && (a = "?" + a);
            var f = -1 !== this.hostname.indexOf(":");
            return c + "://" + (f ? "[" + this.hostname + "]" : this.hostname) + d + this.path + a;
          };

          c.prototype.check = function () {
            return !(!f || "__initialize" in f && this.name === c.prototype.name);
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k) {}, function (h, k) {
        var e = [].indexOf;

        h.exports = function (d, c) {
          if (e) return d.indexOf(c);

          for (var g = 0; g < d.length; ++g) {
            if (d[g] === c) return g;
          }

          return -1;
        };
      }, function (h, k) {
        (function (e) {
          var d = /^[\],:{}\s]*$/,
              c = /\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,
              g = /"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,
              a = /(?:^|:|,)(?:\s*\[)+/g,
              b = /^\s+/,
              k = /\s+$/;

          h.exports = function (m) {
            return "string" == typeof m && m ? (m = m.replace(b, "").replace(k, ""), e.JSON && JSON.parse ? JSON.parse(m) : d.test(m.replace(c, "@").replace(g, "]").replace(a, "")) ? new Function("return " + m)() : void 0) : null;
          };
        }).call(k, function () {
          return this;
        }());
      }, function (h, k, e) {
        function d(a, b, c) {
          this.io = a;
          this.nsp = b;
          this.json = this;
          this.ids = 0;
          this.acks = {};
          this.receiveBuffer = [];
          this.sendBuffer = [];
          this.connected = !1;
          this.disconnected = !0;
          c && c.query && (this.query = c.query);
          this.io.autoConnect && this.open();
        }

        $jscomp.initSymbol();
        $jscomp.initSymbol();
        $jscomp.initSymbolIterator();
        var c = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (a) {
          return _typeof(a);
        } : function (a) {
          $jscomp.initSymbol();
          $jscomp.initSymbol();
          $jscomp.initSymbol();
          return a && "function" == typeof Symbol && a.constructor === Symbol && a !== Symbol.prototype ? "symbol" : _typeof(a);
        },
            g = e(7);
        k = e(8);
        var a = e(40),
            b = e(41),
            q = e(42),
            m = e(3)("socket.io-client:socket"),
            l = e(31);
        h.exports = d;
        var v = {
          connect: 1,
          connect_error: 1,
          connect_timeout: 1,
          connecting: 1,
          disconnect: 1,
          error: 1,
          reconnect: 1,
          reconnect_attempt: 1,
          reconnect_failed: 1,
          reconnect_error: 1,
          reconnecting: 1,
          ping: 1,
          pong: 1
        },
            t = k.prototype.emit;
        k(d.prototype);

        d.prototype.subEvents = function () {
          if (!this.subs) {
            var a = this.io;
            this.subs = [b(a, "open", q(this, "onopen")), b(a, "packet", q(this, "onpacket")), b(a, "close", q(this, "onclose"))];
          }
        };

        d.prototype.open = d.prototype.connect = function () {
          return this.connected ? this : (this.subEvents(), this.io.open(), "open" === this.io.readyState && this.onopen(), this.emit("connecting"), this);
        };

        d.prototype.send = function () {
          var b = a(arguments);
          return b.unshift("message"), this.emit.apply(this, b), this;
        };

        d.prototype.emit = function (b) {
          if (v.hasOwnProperty(b)) return t.apply(this, arguments), this;
          var c = a(arguments),
              d = {
            type: g.EVENT,
            data: c
          };
          return d.options = {}, d.options.compress = !this.flags || !1 !== this.flags.compress, "function" == typeof c[c.length - 1] && (m("emitting packet with ack id %d", this.ids), this.acks[this.ids] = c.pop(), d.id = this.ids++), this.connected ? this.packet(d) : this.sendBuffer.push(d), delete this.flags, this;
        };

        d.prototype.packet = function (a) {
          a.nsp = this.nsp;
          this.io.packet(a);
        };

        d.prototype.onopen = function () {
          if (m("transport is open - connecting"), "/" !== this.nsp) if (this.query) {
            var a = "object" === c(this.query) ? l.encode(this.query) : this.query;
            m("sending connect packet with query %s", a);
            this.packet({
              type: g.CONNECT,
              query: a
            });
          } else this.packet({
            type: g.CONNECT
          });
        };

        d.prototype.onclose = function (a) {
          m("close (%s)", a);
          this.connected = !1;
          this.disconnected = !0;
          delete this.id;
          this.emit("disconnect", a);
        };

        d.prototype.onpacket = function (a) {
          if (a.nsp === this.nsp) switch (a.type) {
            case g.CONNECT:
              this.onconnect();
              break;

            case g.EVENT:
              this.onevent(a);
              break;

            case g.BINARY_EVENT:
              this.onevent(a);
              break;

            case g.ACK:
              this.onack(a);
              break;

            case g.BINARY_ACK:
              this.onack(a);
              break;

            case g.DISCONNECT:
              this.ondisconnect();
              break;

            case g.ERROR:
              this.emit("error", a.data);
          }
        };

        d.prototype.onevent = function (a) {
          var b = a.data || [];
          m("emitting event %j", b);
          null != a.id && (m("attaching ack callback to event"), b.push(this.ack(a.id)));
          this.connected ? t.apply(this, b) : this.receiveBuffer.push(b);
        };

        d.prototype.ack = function (b) {
          var c = this,
              d = !1;
          return function () {
            if (!d) {
              d = !0;
              var f = a(arguments);
              m("sending ack %j", f);
              c.packet({
                type: g.ACK,
                id: b,
                data: f
              });
            }
          };
        };

        d.prototype.onack = function (a) {
          var b = this.acks[a.id];
          "function" == typeof b ? (m("calling ack %s with %j", a.id, a.data), b.apply(this, a.data), delete this.acks[a.id]) : m("bad ack %s", a.id);
        };

        d.prototype.onconnect = function () {
          this.connected = !0;
          this.disconnected = !1;
          this.emit("connect");
          this.emitBuffered();
        };

        d.prototype.emitBuffered = function () {
          var a;

          for (a = 0; a < this.receiveBuffer.length; a++) {
            t.apply(this, this.receiveBuffer[a]);
          }

          this.receiveBuffer = [];

          for (a = 0; a < this.sendBuffer.length; a++) {
            this.packet(this.sendBuffer[a]);
          }

          this.sendBuffer = [];
        };

        d.prototype.ondisconnect = function () {
          m("server disconnect (%s)", this.nsp);
          this.destroy();
          this.onclose("io server disconnect");
        };

        d.prototype.destroy = function () {
          if (this.subs) {
            for (var a = 0; a < this.subs.length; a++) {
              this.subs[a].destroy();
            }

            this.subs = null;
          }

          this.io.destroy(this);
        };

        d.prototype.close = d.prototype.disconnect = function () {
          return this.connected && (m("performing disconnect (%s)", this.nsp), this.packet({
            type: g.DISCONNECT
          })), this.destroy(), this.connected && this.onclose("io client disconnect"), this;
        };

        d.prototype.compress = function (a) {
          return this.flags = this.flags || {}, this.flags.compress = a, this;
        };
      }, function (h, k) {
        h.exports = function (e, d) {
          for (var c = [], g = (d = d || 0) || 0; g < e.length; g++) {
            c[g - d] = e[g];
          }

          return c;
        };
      }, function (h, k) {
        h.exports = function (e, d, c) {
          return e.on(d, c), {
            destroy: function destroy() {
              e.removeListener(d, c);
            }
          };
        };
      }, function (h, k) {
        var e = [].slice;

        h.exports = function (d, c) {
          if ("string" == typeof c && (c = d[c]), "function" != typeof c) throw Error("bind() requires a function");
          var g = e.call(arguments, 2);
          return function () {
            return c.apply(d, g.concat(e.call(arguments)));
          };
        };
      }, function (h, k) {
        function e(d) {
          d = d || {};
          this.ms = d.min || 100;
          this.max = d.max || 1E4;
          this.factor = d.factor || 2;
          this.jitter = 0 < d.jitter && 1 >= d.jitter ? d.jitter : 0;
          this.attempts = 0;
        }

        h.exports = e;

        e.prototype.duration = function () {
          var d = this.ms * Math.pow(this.factor, this.attempts++);

          if (this.jitter) {
            var c = Math.random(),
                e = Math.floor(c * this.jitter * d);
            d = 0 == (1 & Math.floor(10 * c)) ? d - e : d + e;
          }

          return 0 | Math.min(d, this.max);
        };

        e.prototype.reset = function () {
          this.attempts = 0;
        };

        e.prototype.setMin = function (d) {
          this.ms = d;
        };

        e.prototype.setMax = function (d) {
          this.max = d;
        };

        e.prototype.setJitter = function (d) {
          this.jitter = d;
        };
      }]);
    });
  }, function (p, r, n) {
    var h = n(2),
        k = n(7),
        e = n(0);

    r.a = function (d) {
      var c = Object(h.a)({});
      c.id = d.id;
      c.stream = d.stream.stream;
      c.elementID = d.elementID;

      var g = function g() {
        c.bar.display();
      },
          a = function a() {
        c.bar.hide();
      },
          b = function b(a, _b2, d, e) {
        (e ? 1 / a * _b2 > d : 1 / a * _b2 < d) ? (c.video.style.width = _b2 + "px", c.video.style.height = 1 / a * _b2 + "px", c.video.style.top = -(1 / a * _b2 / 2 - d / 2) + "px", c.video.style.left = "0px") : (c.video.style.height = d + "px", c.video.style.width = a * d + "px", c.video.style.left = -(a * d / 2 - _b2 / 2) + "px", c.video.style.top = "0px");
      };

      c.destroy = function () {
        c.video.pause();
        delete c.resizer;
        c.parentNode.removeChild(c.div);
      };

      c.resize = function () {
        var a = c.container.offsetWidth,
            e = c.container.offsetHeight;
        d.stream.screen || !1 === d.options.crop ? b(16 / 9, a, e, !1) : (a !== c.containerWidth || e !== c.containerHeight) && b(4 / 3, a, e, !0);
        c.containerWidth = a;
        c.containerHeight = e;
      };

      e.a.debug("Creating URL from stream " + c.stream);
      c.streamUrl = (window.URL || webkitURL).createObjectURL(c.stream);
      c.div = document.createElement("div");
      c.div.setAttribute("id", "player_" + c.id);
      c.div.setAttribute("class", "licode_player");
      c.div.setAttribute("style", "width: 100%; height: 100%; position: relative; background-color: black; overflow: hidden;");
      !1 !== d.options.loader && (c.loader = document.createElement("img"), c.loader.setAttribute("style", "width: 16px; height: 16px; position: absolute; top: 50%; left: 50%; margin-top: -8px; margin-left: -8px"), c.loader.setAttribute("id", "back_" + c.id), c.loader.setAttribute("class", "licode_loader"), c.loader.setAttribute("src", c.url + "/assets/loader.gif"));
      c.video = document.createElement("video");
      c.video.setAttribute("id", "stream" + c.id);
      c.video.setAttribute("class", "licode_stream");
      c.video.setAttribute("style", "width: 100%; height: 100%; position: absolute");
      c.video.setAttribute("autoplay", "autoplay");
      d.stream.local && (c.video.volume = 0);
      c.container = void 0 !== c.elementID ? "object" === _typeof(c.elementID) && "function" === typeof c.elementID.appendChild ? c.elementID : document.getElementById(c.elementID) : document.body;
      c.container.appendChild(c.div);
      c.parentNode = c.div.parentNode;
      c.loader && c.div.appendChild(c.loader);
      c.div.appendChild(c.video);
      c.containerWidth = 0;
      c.containerHeight = 0;
      !1 !== d.options.resizer && (c.resizer = L.ResizeSensor(c.container, c.resize), c.resize());
      !1 !== d.options.bar ? (c.bar = Object(k.a)({
        elementID: "player_" + c.id,
        id: c.id,
        stream: d.stream,
        media: c.video,
        options: d.options
      }), c.div.onmouseover = g, c.div.onmouseout = a) : c.media = c.video;
      c.video.src = c.streamUrl;
      return c;
    };
  }, function (p, r, n) {
    var h = n(2);

    r.a = function (k) {
      var e = Object(h.a)({}),
          d = 50;
      e.elementID = k.elementID;
      e.media = k.media;
      e.id = k.id;
      e.stream = k.stream;
      e.div = document.createElement("div");
      e.div.setAttribute("style", "width: 40%; height: 100%; max-width: 32px; position: absolute; right: 0;z-index:0;");
      e.icon = document.createElement("img");
      e.icon.setAttribute("id", "volume_" + e.id);
      e.icon.setAttribute("src", e.url + "/assets/sound48.png");
      e.icon.setAttribute("style", "width: 80%; height: 100%; position: absolute;");
      e.div.appendChild(e.icon);

      e.icon.onclick = function () {
        e.media.muted ? (e.media.muted = !1, e.icon.setAttribute("src", e.url + "/assets/sound48.png"), e.stream.local ? e.stream.stream.getAudioTracks()[0].enabled = !0 : (e.picker.value = d, e.media.volume = e.picker.value / 100)) : (e.media.muted = !0, e.icon.setAttribute("src", e.url + "/assets/mute48.png"), e.stream.local ? e.stream.stream.getAudioTracks()[0].enabled = !1 : (d = e.picker.value, e.picker.value = 0, e.media.volume = 0));
      };

      if (!e.stream.local) {
        e.picker = document.createElement("input");
        e.picker.setAttribute("id", "picker_" + e.id);
        e.picker.type = "range";
        e.picker.min = 0;
        e.picker.max = 100;
        e.picker.step = 10;
        e.picker.value = d;
        e.picker.setAttribute("orient", "vertical");
        e.div.appendChild(e.picker);
        e.media.volume = e.picker.value / 100;
        e.media.muted = !1;

        e.picker.oninput = function () {
          0 < e.picker.value ? (e.media.muted = !1, e.icon.setAttribute("src", e.url + "/assets/sound48.png")) : (e.media.muted = !0, e.icon.setAttribute("src", e.url + "/assets/mute48.png"));
          e.media.volume = e.picker.value / 100;
        };

        var c = function c(_c3) {
          e.picker.setAttribute("style", "background: transparent; width: 32px;\n                                         height: 100px; position: absolute; bottom: 90%;\n                                         z-index: 1; right: 0px; -webkit-appearance: slider-vertical;\n                                         bottom: " + e.div.offsetHeight + "px; display: " + _c3);
        };

        e.div.onmouseover = function () {
          c("block");
        };

        e.div.onmouseout = function () {
          c("none");
        };

        c("none");
      }

      document.getElementById(e.elementID).appendChild(e.div);
      return e;
    };
  }, function (p, r, n) {
    var h = n(2),
        k = n(7),
        e = n(0);

    r.a = function (d) {
      var c = Object(h.a)({});
      c.id = d.id;
      c.stream = d.stream.stream;
      c.elementID = d.elementID;
      e.a.debug("Creating URL from stream " + c.stream);
      c.streamUrl = (window.URL || webkitURL).createObjectURL(c.stream);
      c.audio = document.createElement("audio");
      c.audio.setAttribute("id", "stream" + c.id);
      c.audio.setAttribute("class", "licode_stream");
      c.audio.setAttribute("style", "width: 100%; height: 100%; position: absolute");
      c.audio.setAttribute("autoplay", "autoplay");
      d.stream.local && (c.audio.volume = 0);

      if (void 0 !== c.elementID) {
        c.destroy = function () {
          c.audio.pause();
          c.parentNode.removeChild(c.div);
        };

        var g = function g() {
          c.bar.display();
        };

        var a = function a() {
          c.bar.hide();
        };

        c.div = document.createElement("div");
        c.div.setAttribute("id", "player_" + c.id);
        c.div.setAttribute("class", "licode_player");
        c.div.setAttribute("style", "width: 100%; height: 100%; position: relative; overflow: hidden;");
        c.container = "object" === _typeof(c.elementID) && "function" === typeof c.elementID.appendChild ? c.elementID : document.getElementById(c.elementID);
        c.container.appendChild(c.div);
        c.parentNode = c.div.parentNode;
        c.div.appendChild(c.audio);
        !1 !== d.options.bar ? (c.bar = Object(k.a)({
          elementID: "player_" + c.id,
          id: c.id,
          stream: d.stream,
          media: c.audio,
          options: d.options
        }), c.div.onmouseover = g, c.div.onmouseout = a) : c.media = c.audio;
      } else c.destroy = function () {
        c.audio.pause();
        c.parentNode.removeChild(c.audio);
      }, document.body.appendChild(c.audio), c.parentNode = document.body;

      c.audio.src = c.streamUrl;
      return c;
    };
  }, function (p, r, n) {
    r.a = function () {
      var h = {},
          k = {};

      h.add = function (e, d) {
        k[e] = d;
      };

      h.get = function (e) {
        return k[e];
      };

      h.has = function (e) {
        return void 0 !== k[e];
      };

      h.forEach = function (e) {
        for (var d = Object.keys(k), c = 0; c < d.length; c += 1) {
          var g = d[c];
          e(k[g], g);
        }
      };

      h.keys = function () {
        return Object.keys(k);
      };

      h.remove = function (e) {
        delete k[e];
      };

      return h;
    };
  }, function (p, r, n) {
    p = function () {
      for (var h, k, e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split(""), d = [], c = 0; c < e.length; c += 1) {
        d[e[c]] = c;
      }

      var g = function g() {
        if (!h || k >= h.length) return -1;
        var a = h.charCodeAt(k) & 255;
        k += 1;
        return a;
      },
          a = function a() {
        if (!h) return -1;

        for (;;) {
          if (k >= h.length) return -1;
          var a = h.charAt(k);
          k += 1;
          if (d[a]) return d[a];
          if ("A" === a) return 0;
        }
      },
          b = function b(a) {
        a = a.toString(16);
        1 === a.length && (a = "0" + a);
        return unescape("%" + a);
      };

      return {
        encodeBase64: function encodeBase64(a) {
          var b;
          h = a;
          k = 0;
          a = "";
          var c = Array(3);
          var d = 0;

          for (b = !1; !b && -1 !== (c[0] = g());) {
            c[1] = g(), c[2] = g(), a += e[c[0] >> 2], -1 !== c[1] ? (a += e[c[0] << 4 & 48 | c[1] >> 4], -1 !== c[2] ? (a += e[c[1] << 2 & 60 | c[2] >> 6], a += e[c[2] & 63]) : (a += e[c[1] << 2 & 60], a += "\x3d", b = !0)) : (a += e[c[0] << 4 & 48], a += "\x3d", a += "\x3d", b = !0), d += 4, 76 <= d && (a += "\n", d = 0);
          }

          return a;
        },
        decodeBase64: function decodeBase64(c) {
          var d;
          h = c;
          k = 0;
          c = "";
          var e = Array(4);

          for (d = !1; !d && -1 !== (e[0] = a()) && -1 !== (e[1] = a());) {
            e[2] = a(), e[3] = a(), c += b(e[0] << 2 & 255 | e[1] >> 4), -1 !== e[2] ? (c += b(e[1] << 4 & 255 | e[2] >> 2), -1 !== e[3] ? c += b(e[2] << 6 & 255 | e[3]) : d = !0) : d = !0;
          }

          return c;
        }
      };
    }();

    r.a = p;
  }, function (p, r, n) {
    r = n(8);
    p.exports = r.adapter = n(23);
  }, function (p, r, n) {
    (function (h) {
      p.exports = function () {
        return function e(d, c, g) {
          function a(m, l) {
            if (!c[m]) {
              if (!d[m]) {
                if (b) return b(m, !0);
                l = Error("Cannot find module '" + m + "'");
                throw l.code = "MODULE_NOT_FOUND", l;
              }

              l = c[m] = {
                exports: {}
              };
              d[m][0].call(l.exports, function (b) {
                var c = d[m][1][b];
                return a(c ? c : b);
              }, l, l.exports, e, d, c, g);
            }

            return c[m].exports;
          }

          for (var b = !1, h = 0; h < g.length; h++) {
            a(g[h]);
          }

          return a;
        }({
          1: [function (e, d, c) {
            var g = {
              generateIdentifier: function generateIdentifier() {
                return Math.random().toString(36).substr(2, 10);
              }
            };
            g.localCName = g.generateIdentifier();

            g.splitLines = function (a) {
              return a.trim().split("\n").map(function (a) {
                return a.trim();
              });
            };

            g.splitSections = function (a) {
              return a.split("\nm\x3d").map(function (a, c) {
                return (0 < c ? "m\x3d" + a : a).trim() + "\r\n";
              });
            };

            g.matchPrefix = function (a, b) {
              return g.splitLines(a).filter(function (a) {
                return 0 === a.indexOf(b);
              });
            };

            g.parseCandidate = function (a) {
              a = 0 === a.indexOf("a\x3dcandidate:") ? a.substring(12).split(" ") : a.substring(10).split(" ");

              for (var b = {
                foundation: a[0],
                component: parseInt(a[1], 10),
                protocol: a[2].toLowerCase(),
                priority: parseInt(a[3], 10),
                ip: a[4],
                port: parseInt(a[5], 10),
                type: a[7]
              }, c = 8; c < a.length; c += 2) {
                switch (a[c]) {
                  case "raddr":
                    b.relatedAddress = a[c + 1];
                    break;

                  case "rport":
                    b.relatedPort = parseInt(a[c + 1], 10);
                    break;

                  case "tcptype":
                    b.tcpType = a[c + 1];
                    break;

                  default:
                    b[a[c]] = a[c + 1];
                }
              }

              return b;
            };

            g.writeCandidate = function (a) {
              var b = [];
              b.push(a.foundation);
              b.push(a.component);
              b.push(a.protocol.toUpperCase());
              b.push(a.priority);
              b.push(a.ip);
              b.push(a.port);
              var c = a.type;
              b.push("typ");
              b.push(c);
              "host" !== c && a.relatedAddress && a.relatedPort && (b.push("raddr"), b.push(a.relatedAddress), b.push("rport"), b.push(a.relatedPort));
              a.tcpType && "tcp" === a.protocol.toLowerCase() && (b.push("tcptype"), b.push(a.tcpType));
              a.ufrag && (b.push("ufrag"), b.push(a.ufrag));
              return "candidate:" + b.join(" ");
            };

            g.parseIceOptions = function (a) {
              return a.substr(14).split(" ");
            };

            g.parseRtpMap = function (a) {
              a = a.substr(9).split(" ");
              var b = {
                payloadType: parseInt(a.shift(), 10)
              };
              a = a[0].split("/");
              b.name = a[0];
              b.clockRate = parseInt(a[1], 10);
              b.numChannels = 3 === a.length ? parseInt(a[2], 10) : 1;
              return b;
            };

            g.writeRtpMap = function (a) {
              var b = a.payloadType;
              void 0 !== a.preferredPayloadType && (b = a.preferredPayloadType);
              return "a\x3drtpmap:" + b + " " + a.name + "/" + a.clockRate + (1 !== a.numChannels ? "/" + a.numChannels : "") + "\r\n";
            };

            g.parseExtmap = function (a) {
              a = a.substr(9).split(" ");
              return {
                id: parseInt(a[0], 10),
                direction: 0 < a[0].indexOf("/") ? a[0].split("/")[1] : "sendrecv",
                uri: a[1]
              };
            };

            g.writeExtmap = function (a) {
              return "a\x3dextmap:" + (a.id || a.preferredId) + (a.direction && "sendrecv" !== a.direction ? "/" + a.direction : "") + " " + a.uri + "\r\n";
            };

            g.parseFmtp = function (a) {
              for (var b = {}, c = a.substr(a.indexOf(" ") + 1).split(";"), d = 0; d < c.length; d++) {
                a = c[d].trim().split("\x3d"), b[a[0].trim()] = a[1];
              }

              return b;
            };

            g.writeFmtp = function (a) {
              var b = "",
                  c = a.payloadType;
              void 0 !== a.preferredPayloadType && (c = a.preferredPayloadType);

              if (a.parameters && Object.keys(a.parameters).length) {
                var d = [];
                Object.keys(a.parameters).forEach(function (b) {
                  d.push(b + "\x3d" + a.parameters[b]);
                });
                b += "a\x3dfmtp:" + c + " " + d.join(";") + "\r\n";
              }

              return b;
            };

            g.parseRtcpFb = function (a) {
              a = a.substr(a.indexOf(" ") + 1).split(" ");
              return {
                type: a.shift(),
                parameter: a.join(" ")
              };
            };

            g.writeRtcpFb = function (a) {
              var b = "",
                  c = a.payloadType;
              void 0 !== a.preferredPayloadType && (c = a.preferredPayloadType);
              a.rtcpFeedback && a.rtcpFeedback.length && a.rtcpFeedback.forEach(function (a) {
                b += "a\x3drtcp-fb:" + c + " " + a.type + (a.parameter && a.parameter.length ? " " + a.parameter : "") + "\r\n";
              });
              return b;
            };

            g.parseSsrcMedia = function (a) {
              var b = a.indexOf(" "),
                  c = {
                ssrc: parseInt(a.substr(7, b - 7), 10)
              },
                  d = a.indexOf(":", b);
              -1 < d ? (c.attribute = a.substr(b + 1, d - b - 1), c.value = a.substr(d + 1)) : c.attribute = a.substr(b + 1);
              return c;
            };

            g.getMid = function (a) {
              if (a = g.matchPrefix(a, "a\x3dmid:")[0]) return a.substr(6);
            };

            g.parseFingerprint = function (a) {
              a = a.substr(14).split(" ");
              return {
                algorithm: a[0].toLowerCase(),
                value: a[1]
              };
            };

            g.getDtlsParameters = function (a, b) {
              return {
                role: "auto",
                fingerprints: g.matchPrefix(a + b, "a\x3dfingerprint:").map(g.parseFingerprint)
              };
            };

            g.writeDtlsParameters = function (a, b) {
              var c = "a\x3dsetup:" + b + "\r\n";
              a.fingerprints.forEach(function (a) {
                c += "a\x3dfingerprint:" + a.algorithm + " " + a.value + "\r\n";
              });
              return c;
            };

            g.getIceParameters = function (a, b) {
              a = g.splitLines(a);
              a = a.concat(g.splitLines(b));
              return {
                usernameFragment: a.filter(function (a) {
                  return 0 === a.indexOf("a\x3dice-ufrag:");
                })[0].substr(12),
                password: a.filter(function (a) {
                  return 0 === a.indexOf("a\x3dice-pwd:");
                })[0].substr(10)
              };
            };

            g.writeIceParameters = function (a) {
              return "a\x3dice-ufrag:" + a.usernameFragment + "\r\na\x3dice-pwd:" + a.password + "\r\n";
            };

            g.parseRtpParameters = function (a) {
              for (var b = {
                codecs: [],
                headerExtensions: [],
                fecMechanisms: [],
                rtcp: []
              }, c = g.splitLines(a)[0].split(" "), d = 3; d < c.length; d++) {
                var e = c[d],
                    h = g.matchPrefix(a, "a\x3drtpmap:" + e + " ")[0];

                if (h) {
                  h = g.parseRtpMap(h);
                  var t = g.matchPrefix(a, "a\x3dfmtp:" + e + " ");
                  h.parameters = t.length ? g.parseFmtp(t[0]) : {};
                  h.rtcpFeedback = g.matchPrefix(a, "a\x3drtcp-fb:" + e + " ").map(g.parseRtcpFb);
                  b.codecs.push(h);

                  switch (h.name.toUpperCase()) {
                    case "RED":
                    case "ULPFEC":
                      b.fecMechanisms.push(h.name.toUpperCase());
                  }
                }
              }

              g.matchPrefix(a, "a\x3dextmap:").forEach(function (a) {
                b.headerExtensions.push(g.parseExtmap(a));
              });
              return b;
            };

            g.writeRtpDescription = function (a, b) {
              var c = "";
              c += "m\x3d" + a + " ";
              c += 0 < b.codecs.length ? "9" : "0";
              c += " UDP/TLS/RTP/SAVPF ";
              c += b.codecs.map(function (a) {
                return void 0 !== a.preferredPayloadType ? a.preferredPayloadType : a.payloadType;
              }).join(" ") + "\r\n";
              c += "c\x3dIN IP4 0.0.0.0\r\n";
              c += "a\x3drtcp:9 IN IP4 0.0.0.0\r\n";
              b.codecs.forEach(function (a) {
                c += g.writeRtpMap(a);
                c += g.writeFmtp(a);
                c += g.writeRtcpFb(a);
              });
              var d = 0;
              b.codecs.forEach(function (a) {
                a.maxptime > d && (d = a.maxptime);
              });
              0 < d && (c += "a\x3dmaxptime:" + d + "\r\n");
              c += "a\x3drtcp-mux\r\n";
              b.headerExtensions.forEach(function (a) {
                c += g.writeExtmap(a);
              });
              return c;
            };

            g.parseRtpEncodingParameters = function (a) {
              var b = [],
                  c = g.parseRtpParameters(a),
                  d = -1 !== c.fecMechanisms.indexOf("RED"),
                  e = -1 !== c.fecMechanisms.indexOf("ULPFEC"),
                  h = g.matchPrefix(a, "a\x3dssrc:").map(function (a) {
                return g.parseSsrcMedia(a);
              }).filter(function (a) {
                return "cname" === a.attribute;
              }),
                  t = 0 < h.length && h[0].ssrc,
                  f;
              h = g.matchPrefix(a, "a\x3dssrc-group:FID").map(function (a) {
                a = a.split(" ");
                a.shift();
                return a.map(function (a) {
                  return parseInt(a, 10);
                });
              });
              0 < h.length && 1 < h[0].length && h[0][0] === t && (f = h[0][1]);
              c.codecs.forEach(function (a) {
                "RTX" === a.name.toUpperCase() && a.parameters.apt && (a = {
                  ssrc: t,
                  codecPayloadType: parseInt(a.parameters.apt, 10),
                  rtx: {
                    ssrc: f
                  }
                }, b.push(a), d && (a = JSON.parse(JSON.stringify(a)), a.fec = {
                  ssrc: f,
                  mechanism: e ? "red+ulpfec" : "red"
                }, b.push(a)));
              });
              0 === b.length && t && b.push({
                ssrc: t
              });
              var u = g.matchPrefix(a, "b\x3d");
              u.length && (u = 0 === u[0].indexOf("b\x3dTIAS:") ? parseInt(u[0].substr(7), 10) : 0 === u[0].indexOf("b\x3dAS:") ? 950 * parseInt(u[0].substr(5), 10) - 16E3 : void 0, b.forEach(function (a) {
                a.maxBitrate = u;
              }));
              return b;
            };

            g.parseRtcpParameters = function (a) {
              var b = {},
                  c = g.matchPrefix(a, "a\x3dssrc:").map(function (a) {
                return g.parseSsrcMedia(a);
              }).filter(function (a) {
                return "cname" === a.attribute;
              })[0];
              c && (b.cname = c.value, b.ssrc = c.ssrc);
              c = g.matchPrefix(a, "a\x3drtcp-rsize");
              b.reducedSize = 0 < c.length;
              b.compound = 0 === c.length;
              a = g.matchPrefix(a, "a\x3drtcp-mux");
              b.mux = 0 < a.length;
              return b;
            };

            g.parseMsid = function (a) {
              var b = g.matchPrefix(a, "a\x3dmsid:");
              if (1 === b.length) return a = b[0].substr(7).split(" "), {
                stream: a[0],
                track: a[1]
              };
              a = g.matchPrefix(a, "a\x3dssrc:").map(function (a) {
                return g.parseSsrcMedia(a);
              }).filter(function (a) {
                return "msid" === a.attribute;
              });
              if (0 < a.length) return a = a[0].value.split(" "), {
                stream: a[0],
                track: a[1]
              };
            };

            g.generateSessionId = function () {
              return Math.random().toString().substr(2, 21);
            };

            g.writeSessionBoilerplate = function (a) {
              return "v\x3d0\r\no\x3dthisisadapterortc " + (a ? a : g.generateSessionId()) + " 2 IN IP4 127.0.0.1\r\ns\x3d-\r\nt\x3d0 0\r\n";
            };

            g.writeMediaSection = function (a, b, c, d) {
              b = g.writeRtpDescription(a.kind, b);
              b += g.writeIceParameters(a.iceGatherer.getLocalParameters());
              b += g.writeDtlsParameters(a.dtlsTransport.getLocalParameters(), "offer" === c ? "actpass" : "active");
              b += "a\x3dmid:" + a.mid + "\r\n";
              b = a.direction ? b + ("a\x3d" + a.direction + "\r\n") : a.rtpSender && a.rtpReceiver ? b + "a\x3dsendrecv\r\n" : a.rtpSender ? b + "a\x3dsendonly\r\n" : a.rtpReceiver ? b + "a\x3drecvonly\r\n" : b + "a\x3dinactive\r\n";
              a.rtpSender && (c = "msid:" + d.id + " " + a.rtpSender.track.id + "\r\n", b = b + ("a\x3d" + c) + ("a\x3dssrc:" + a.sendEncodingParameters[0].ssrc + " " + c), a.sendEncodingParameters[0].rtx && (b += "a\x3dssrc:" + a.sendEncodingParameters[0].rtx.ssrc + " " + c, b += "a\x3dssrc-group:FID " + a.sendEncodingParameters[0].ssrc + " " + a.sendEncodingParameters[0].rtx.ssrc + "\r\n"));
              b += "a\x3dssrc:" + a.sendEncodingParameters[0].ssrc + " cname:" + g.localCName + "\r\n";
              a.rtpSender && a.sendEncodingParameters[0].rtx && (b += "a\x3dssrc:" + a.sendEncodingParameters[0].rtx.ssrc + " cname:" + g.localCName + "\r\n");
              return b;
            };

            g.getDirection = function (a, b) {
              a = g.splitLines(a);

              for (var c = 0; c < a.length; c++) {
                switch (a[c]) {
                  case "a\x3dsendrecv":
                  case "a\x3dsendonly":
                  case "a\x3drecvonly":
                  case "a\x3dinactive":
                    return a[c].substr(2);
                }
              }

              return b ? g.getDirection(b) : "sendrecv";
            };

            g.getKind = function (a) {
              return g.splitLines(a)[0].split(" ")[0].substr(2);
            };

            g.isRejected = function (a) {
              return "0" === a.split(" ", 2)[1];
            };

            d.exports = g;
          }, {}],
          2: [function (e, d, c) {
            c = "undefined" !== typeof h ? h : "undefined" !== typeof self ? self : "undefined" !== typeof window ? window : {};
            e = e("./adapter_factory.js");
            d.exports = e({
              window: c.window
            });
          }, {
            "./adapter_factory.js": 3
          }],
          3: [function (e, d, c) {
            d.exports = function (c) {
              c = c && c.window;
              var a = e("./utils"),
                  b = a.log,
                  d = a.detectBrowser(c),
                  g = {
                browserDetails: d,
                extractVersion: a.extractVersion,
                disableLog: a.disableLog,
                disableWarnings: a.disableWarnings
              },
                  l = e("./chrome/chrome_shim") || null,
                  h = e("./edge/edge_shim") || null,
                  t = e("./firefox/firefox_shim") || null,
                  f = e("./safari/safari_shim") || null;

              switch (d.browser) {
                case "chrome":
                  if (!l || !l.shimPeerConnection) {
                    b("Chrome shim is not included in this adapter release.");
                    break;
                  }

                  b("adapter.js shimming chrome.");
                  g.browserShim = l;
                  l.shimGetUserMedia(c);
                  l.shimMediaStream(c);
                  a.shimCreateObjectURL(c);
                  l.shimSourceObject(c);
                  l.shimPeerConnection(c);
                  l.shimOnTrack(c);
                  l.shimGetSendersWithDtmf(c);
                  break;

                case "firefox":
                  if (!t || !t.shimPeerConnection) {
                    b("Firefox shim is not included in this adapter release.");
                    break;
                  }

                  b("adapter.js shimming firefox.");
                  g.browserShim = t;
                  t.shimGetUserMedia(c);
                  a.shimCreateObjectURL(c);
                  t.shimSourceObject(c);
                  t.shimPeerConnection(c);
                  t.shimOnTrack(c);
                  break;

                case "edge":
                  if (!h || !h.shimPeerConnection) {
                    b("MS edge shim is not included in this adapter release.");
                    break;
                  }

                  b("adapter.js shimming edge.");
                  g.browserShim = h;
                  h.shimGetUserMedia(c);
                  a.shimCreateObjectURL(c);
                  h.shimPeerConnection(c);
                  h.shimReplaceTrack(c);
                  break;

                case "safari":
                  if (!f) {
                    b("Safari shim is not included in this adapter release.");
                    break;
                  }

                  b("adapter.js shimming safari.");
                  g.browserShim = f;
                  a.shimCreateObjectURL(c);
                  f.shimRTCIceServerUrls(c);
                  f.shimCallbacksAPI(c);
                  f.shimLocalStreamsAPI(c);
                  f.shimRemoteStreamsAPI(c);
                  f.shimGetUserMedia(c);
                  break;

                default:
                  b("Unsupported browser!");
              }

              return g;
            };
          }, {
            "./chrome/chrome_shim": 4,
            "./edge/edge_shim": 6,
            "./firefox/firefox_shim": 9,
            "./safari/safari_shim": 11,
            "./utils": 12
          }],
          4: [function (e, d, c) {
            var g = e("../utils.js"),
                a = g.log;
            d.exports = {
              shimMediaStream: function shimMediaStream(a) {
                a.MediaStream = a.MediaStream || a.webkitMediaStream;
              },
              shimOnTrack: function shimOnTrack(a) {
                "object" !== _typeof(a) || !a.RTCPeerConnection || "ontrack" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, "ontrack", {
                  get: function get() {
                    return this._ontrack;
                  },
                  set: function set(b) {
                    var c = this;
                    this._ontrack && (this.removeEventListener("track", this._ontrack), this.removeEventListener("addstream", this._ontrackpoly));
                    this.addEventListener("track", this._ontrack = b);
                    this.addEventListener("addstream", this._ontrackpoly = function (b) {
                      b.stream.addEventListener("addtrack", function (d) {
                        var e = a.RTCPeerConnection.prototype.getReceivers ? c.getReceivers().find(function (a) {
                          return a.track.id === d.track.id;
                        }) : {
                          track: d.track
                        };
                        var f = new Event("track");
                        f.track = d.track;
                        f.receiver = e;
                        f.streams = [b.stream];
                        c.dispatchEvent(f);
                      });
                      b.stream.getTracks().forEach(function (d) {
                        var e = a.RTCPeerConnection.prototype.getReceivers ? c.getReceivers().find(function (a) {
                          return a.track.id === d.id;
                        }) : {
                          track: d
                        };
                        var f = new Event("track");
                        f.track = d;
                        f.receiver = e;
                        f.streams = [b.stream];
                        this.dispatchEvent(f);
                      }.bind(this));
                    }.bind(this));
                  }
                });
              },
              shimGetSendersWithDtmf: function shimGetSendersWithDtmf(a) {
                if ("object" === _typeof(a) && a.RTCPeerConnection && !("getSenders" in a.RTCPeerConnection.prototype) && "createDTMFSender" in a.RTCPeerConnection.prototype) {
                  a.RTCPeerConnection.prototype.getSenders = function () {
                    return this._senders || [];
                  };

                  var b = a.RTCPeerConnection.prototype.addStream,
                      c = a.RTCPeerConnection.prototype.removeStream;
                  a.RTCPeerConnection.prototype.addTrack || (a.RTCPeerConnection.prototype.addTrack = function (b, c) {
                    var d = this;
                    if ("closed" === d.signalingState) throw new DOMException("The RTCPeerConnection's signalingState is 'closed'.", "InvalidStateError");
                    var e = [].slice.call(arguments, 1);
                    if (1 !== e.length || !e[0].getTracks().find(function (a) {
                      return a === b;
                    })) throw new DOMException("The adapter.js addTrack polyfill only supports a single  stream which is associated with the specified track.", "NotSupportedError");
                    d._senders = d._senders || [];
                    if (d._senders.find(function (a) {
                      return a.track === b;
                    })) throw new DOMException("Track already exists.", "InvalidAccessError");
                    d._streams = d._streams || {};
                    (e = d._streams[c.id]) ? (e.addTrack(b), d.removeStream(e)) : (e = new a.MediaStream([b]), d._streams[c.id] = e);
                    d.addStream(e);
                    e = {
                      track: b,

                      get dtmf() {
                        void 0 === this._dtmf && (this._dtmf = "audio" === b.kind ? d.createDTMFSender(b) : null);
                        return this._dtmf;
                      }

                    };

                    d._senders.push(e);

                    return e;
                  });

                  a.RTCPeerConnection.prototype.addStream = function (a) {
                    var c = this;
                    c._senders = c._senders || [];
                    b.apply(c, [a]);
                    a.getTracks().forEach(function (a) {
                      c._senders.push({
                        track: a,

                        get dtmf() {
                          void 0 === this._dtmf && (this._dtmf = "audio" === a.kind ? c.createDTMFSender(a) : null);
                          return this._dtmf;
                        }

                      });
                    });
                  };

                  a.RTCPeerConnection.prototype.removeStream = function (a) {
                    var b = this;
                    b._senders = b._senders || [];
                    c.apply(b, [a]);
                    a.getTracks().forEach(function (a) {
                      var c = b._senders.find(function (b) {
                        return b.track === a;
                      });

                      c && b._senders.splice(b._senders.indexOf(c), 1);
                    });
                  };
                } else if ("object" === _typeof(a) && a.RTCPeerConnection && "getSenders" in a.RTCPeerConnection.prototype && "createDTMFSender" in a.RTCPeerConnection.prototype && a.RTCRtpSender && !("dtmf" in a.RTCRtpSender.prototype)) {
                  var d = a.RTCPeerConnection.prototype.getSenders;

                  a.RTCPeerConnection.prototype.getSenders = function () {
                    var a = this,
                        b = d.apply(a, []);
                    b.forEach(function (b) {
                      b._pc = a;
                    });
                    return b;
                  };

                  Object.defineProperty(a.RTCRtpSender.prototype, "dtmf", {
                    get: function get() {
                      void 0 === this._dtmf && (this._dtmf = "audio" === this.track.kind ? this._pc.createDTMFSender(this.track) : null);
                      return this._dtmf;
                    }
                  });
                }
              },
              shimSourceObject: function shimSourceObject(a) {
                var b = a && a.URL;
                "object" === _typeof(a) && (!a.HTMLMediaElement || "srcObject" in a.HTMLMediaElement.prototype || Object.defineProperty(a.HTMLMediaElement.prototype, "srcObject", {
                  get: function get() {
                    return this._srcObject;
                  },
                  set: function set(a) {
                    var c = this;
                    this._srcObject = a;
                    this.src && b.revokeObjectURL(this.src);
                    a ? (this.src = b.createObjectURL(a), a.addEventListener("addtrack", function () {
                      c.src && b.revokeObjectURL(c.src);
                      c.src = b.createObjectURL(a);
                    }), a.addEventListener("removetrack", function () {
                      c.src && b.revokeObjectURL(c.src);
                      c.src = b.createObjectURL(a);
                    })) : this.src = "";
                  }
                }));
              },
              shimPeerConnection: function shimPeerConnection(b) {
                var c = g.detectBrowser(b);

                if (b.RTCPeerConnection) {
                  var d = b.RTCPeerConnection;

                  b.RTCPeerConnection = function (a, b) {
                    if (a && a.iceServers) {
                      for (var c = [], e = 0; e < a.iceServers.length; e++) {
                        var f = a.iceServers[e];
                        !f.hasOwnProperty("urls") && f.hasOwnProperty("url") ? (console.warn("RTCIceServer.url is deprecated! Use urls instead."), f = JSON.parse(JSON.stringify(f)), f.urls = f.url, c.push(f)) : c.push(a.iceServers[e]);
                      }

                      a.iceServers = c;
                    }

                    return new d(a, b);
                  };

                  b.RTCPeerConnection.prototype = d.prototype;
                  Object.defineProperty(b.RTCPeerConnection, "generateCertificate", {
                    get: function get() {
                      return d.generateCertificate;
                    }
                  });
                } else b.RTCPeerConnection = function (c, d) {
                  a("PeerConnection");
                  c && c.iceTransportPolicy && (c.iceTransports = c.iceTransportPolicy);
                  return new b.webkitRTCPeerConnection(c, d);
                }, b.RTCPeerConnection.prototype = b.webkitRTCPeerConnection.prototype, b.webkitRTCPeerConnection.generateCertificate && Object.defineProperty(b.RTCPeerConnection, "generateCertificate", {
                  get: function get() {
                    return b.webkitRTCPeerConnection.generateCertificate;
                  }
                });

                var e = b.RTCPeerConnection.prototype.getStats;

                b.RTCPeerConnection.prototype.getStats = function (a, b, c) {
                  var d = this,
                      f = arguments;
                  if (0 < arguments.length && "function" === typeof a) return e.apply(this, arguments);
                  if (0 === e.length && (0 === arguments.length || "function" !== typeof arguments[0])) return e.apply(this, []);

                  var g = function g(a) {
                    var b = {};
                    a.result().forEach(function (a) {
                      var c = {
                        id: a.id,
                        timestamp: a.timestamp,
                        type: {
                          localcandidate: "local-candidate",
                          remotecandidate: "remote-candidate"
                        }[a.type] || a.type
                      };
                      a.names().forEach(function (b) {
                        c[b] = a.stat(b);
                      });
                      b[c.id] = c;
                    });
                    return b;
                  },
                      h = function h(a) {
                    return new Map(Object.keys(a).map(function (b) {
                      return [b, a[b]];
                    }));
                  };

                  return 2 <= arguments.length ? e.apply(this, [function (a) {
                    f[1](h(g(a)));
                  }, arguments[0]]) : new Promise(function (a, b) {
                    e.apply(d, [function (b) {
                      a(h(g(b)));
                    }, b]);
                  }).then(b, c);
                };

                51 > c.version && ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (a) {
                  var c = b.RTCPeerConnection.prototype[a];

                  b.RTCPeerConnection.prototype[a] = function () {
                    var a = arguments,
                        b = this,
                        d = new Promise(function (d, e) {
                      c.apply(b, [a[0], d, e]);
                    });
                    return 2 > a.length ? d : d.then(function () {
                      a[1].apply(null, []);
                    }, function (b) {
                      3 <= a.length && a[2].apply(null, [b]);
                    });
                  };
                });
                52 > c.version && ["createOffer", "createAnswer"].forEach(function (a) {
                  var c = b.RTCPeerConnection.prototype[a];

                  b.RTCPeerConnection.prototype[a] = function () {
                    var a = this;

                    if (1 > arguments.length || 1 === arguments.length && "object" === _typeof(arguments[0])) {
                      var b = 1 === arguments.length ? arguments[0] : void 0;
                      return new Promise(function (d, e) {
                        c.apply(a, [d, e, b]);
                      });
                    }

                    return c.apply(this, arguments);
                  };
                });
                ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (a) {
                  var c = b.RTCPeerConnection.prototype[a];

                  b.RTCPeerConnection.prototype[a] = function () {
                    arguments[0] = new ("addIceCandidate" === a ? b.RTCIceCandidate : b.RTCSessionDescription)(arguments[0]);
                    return c.apply(this, arguments);
                  };
                });
                var h = b.RTCPeerConnection.prototype.addIceCandidate;

                b.RTCPeerConnection.prototype.addIceCandidate = function () {
                  return arguments[0] ? h.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
                };
              },
              shimGetUserMedia: e("./getusermedia")
            };
          }, {
            "../utils.js": 12,
            "./getusermedia": 5
          }],
          5: [function (e, d, c) {
            var g = e("../utils.js"),
                a = g.log;

            d.exports = function (b) {
              var c = g.detectBrowser(b),
                  d = b && b.navigator,
                  e = function e(a) {
                if ("object" !== _typeof(a) || a.mandatory || a.optional) return a;
                var b = {};
                Object.keys(a).forEach(function (c) {
                  if ("require" !== c && "advanced" !== c && "mediaSource" !== c) {
                    var d = "object" === _typeof(a[c]) ? a[c] : {
                      ideal: a[c]
                    };
                    void 0 !== d.exact && "number" === typeof d.exact && (d.min = d.max = d.exact);

                    var e = function e(a, b) {
                      return a ? a + b.charAt(0).toUpperCase() + b.slice(1) : "deviceId" === b ? "sourceId" : b;
                    };

                    if (void 0 !== d.ideal) {
                      b.optional = b.optional || [];
                      var f = {};
                      "number" === typeof d.ideal ? (f[e("min", c)] = d.ideal, b.optional.push(f), f = {}, f[e("max", c)] = d.ideal) : f[e("", c)] = d.ideal;
                      b.optional.push(f);
                    }

                    void 0 !== d.exact && "number" !== typeof d.exact ? (b.mandatory = b.mandatory || {}, b.mandatory[e("", c)] = d.exact) : ["min", "max"].forEach(function (a) {
                      void 0 !== d[a] && (b.mandatory = b.mandatory || {}, b.mandatory[e(a, c)] = d[a]);
                    });
                  }
                });
                a.advanced && (b.optional = (b.optional || []).concat(a.advanced));
                return b;
              },
                  h = function h(b, f) {
                if ((b = JSON.parse(JSON.stringify(b))) && "object" === _typeof(b.audio)) {
                  var g = function g(a, b, c) {
                    b in a && !(c in a) && (a[c] = a[b], delete a[b]);
                  };

                  b = JSON.parse(JSON.stringify(b));
                  g(b.audio, "autoGainControl", "googAutoGainControl");
                  g(b.audio, "noiseSuppression", "googNoiseSuppression");
                  b.audio = e(b.audio);
                }

                if (b && "object" === _typeof(b.video)) {
                  var h = b.video.facingMode;
                  h = h && ("object" === _typeof(h) ? h : {
                    ideal: h
                  });
                  g = 61 > c.version;

                  if (!(!h || "user" !== h.exact && "environment" !== h.exact && "user" !== h.ideal && "environment" !== h.ideal || d.mediaDevices.getSupportedConstraints && d.mediaDevices.getSupportedConstraints().facingMode && !g)) {
                    delete b.video.facingMode;
                    if ("environment" === h.exact || "environment" === h.ideal) var l = ["back", "rear"];else if ("user" === h.exact || "user" === h.ideal) l = ["front"];
                    if (l) return d.mediaDevices.enumerateDevices().then(function (c) {
                      c = c.filter(function (a) {
                        return "videoinput" === a.kind;
                      });
                      var d = c.find(function (a) {
                        return l.some(function (b) {
                          return -1 !== a.label.toLowerCase().indexOf(b);
                        });
                      });
                      !d && c.length && -1 !== l.indexOf("back") && (d = c[c.length - 1]);
                      d && (b.video.deviceId = h.exact ? {
                        exact: d.deviceId
                      } : {
                        ideal: d.deviceId
                      });
                      b.video = e(b.video);
                      a("chrome: " + JSON.stringify(b));
                      return f(b);
                    });
                  }

                  b.video = e(b.video);
                }

                a("chrome: " + JSON.stringify(b));
                return f(b);
              },
                  t = function t(a) {
                return {
                  name: {
                    PermissionDeniedError: "NotAllowedError",
                    InvalidStateError: "NotReadableError",
                    DevicesNotFoundError: "NotFoundError",
                    ConstraintNotSatisfiedError: "OverconstrainedError",
                    TrackStartError: "NotReadableError",
                    MediaDeviceFailedDueToShutdown: "NotReadableError",
                    MediaDeviceKillSwitchOn: "NotReadableError"
                  }[a.name] || a.name,
                  message: a.message,
                  constraint: a.constraintName,
                  toString: function toString() {
                    return this.name + (this.message && ": ") + this.message;
                  }
                };
              };

              d.getUserMedia = function (a, b, c) {
                h(a, function (a) {
                  d.webkitGetUserMedia(a, b, function (a) {
                    c(t(a));
                  });
                });
              };

              var f = function f(a) {
                return new Promise(function (b, c) {
                  d.getUserMedia(a, b, c);
                });
              };

              d.mediaDevices || (d.mediaDevices = {
                getUserMedia: f,
                enumerateDevices: function enumerateDevices() {
                  return new Promise(function (a) {
                    var c = {
                      audio: "audioinput",
                      video: "videoinput"
                    };
                    return b.MediaStreamTrack.getSources(function (b) {
                      a(b.map(function (a) {
                        return {
                          label: a.label,
                          kind: c[a.kind],
                          deviceId: a.id,
                          groupId: ""
                        };
                      }));
                    });
                  });
                },
                getSupportedConstraints: function getSupportedConstraints() {
                  return {
                    deviceId: !0,
                    echoCancellation: !0,
                    facingMode: !0,
                    frameRate: !0,
                    height: !0,
                    width: !0
                  };
                }
              });

              if (d.mediaDevices.getUserMedia) {
                var u = d.mediaDevices.getUserMedia.bind(d.mediaDevices);

                d.mediaDevices.getUserMedia = function (a) {
                  return h(a, function (a) {
                    return u(a).then(function (b) {
                      if (a.audio && !b.getAudioTracks().length || a.video && !b.getVideoTracks().length) throw b.getTracks().forEach(function (a) {
                        a.stop();
                      }), new DOMException("", "NotFoundError");
                      return b;
                    }, function (a) {
                      return Promise.reject(t(a));
                    });
                  });
                };
              } else d.mediaDevices.getUserMedia = function (a) {
                return f(a);
              };

              "undefined" === typeof d.mediaDevices.addEventListener && (d.mediaDevices.addEventListener = function () {
                a("Dummy mediaDevices.addEventListener called.");
              });
              "undefined" === typeof d.mediaDevices.removeEventListener && (d.mediaDevices.removeEventListener = function () {
                a("Dummy mediaDevices.removeEventListener called.");
              });
            };
          }, {
            "../utils.js": 12
          }],
          6: [function (e, d, c) {
            var g = e("../utils"),
                a = e("./rtcpeerconnection_shim");
            d.exports = {
              shimGetUserMedia: e("./getusermedia"),
              shimPeerConnection: function shimPeerConnection(b) {
                var c = g.detectBrowser(b);

                if (b.RTCIceGatherer && (b.RTCIceCandidate || (b.RTCIceCandidate = function (a) {
                  return a;
                }), b.RTCSessionDescription || (b.RTCSessionDescription = function (a) {
                  return a;
                }), 15025 > c.version)) {
                  var d = Object.getOwnPropertyDescriptor(b.MediaStreamTrack.prototype, "enabled");
                  Object.defineProperty(b.MediaStreamTrack.prototype, "enabled", {
                    set: function set(a) {
                      d.set.call(this, a);
                      var b = new Event("enabled");
                      b.enabled = a;
                      this.dispatchEvent(b);
                    }
                  });
                }

                b.RTCPeerConnection = a(b, c.version);
              },
              shimReplaceTrack: function shimReplaceTrack(a) {
                !a.RTCRtpSender || "replaceTrack" in a.RTCRtpSender.prototype || (a.RTCRtpSender.prototype.replaceTrack = a.RTCRtpSender.prototype.setTrack);
              }
            };
          }, {
            "../utils": 12,
            "./getusermedia": 7,
            "./rtcpeerconnection_shim": 8
          }],
          7: [function (e, d, c) {
            d.exports = function (c) {
              c = c && c.navigator;

              var a = function a(_a2) {
                return {
                  name: {
                    PermissionDeniedError: "NotAllowedError"
                  }[_a2.name] || _a2.name,
                  message: _a2.message,
                  constraint: _a2.constraint,
                  toString: function toString() {
                    return this.name;
                  }
                };
              },
                  b = c.mediaDevices.getUserMedia.bind(c.mediaDevices);

              c.mediaDevices.getUserMedia = function (c) {
                return b(c).catch(function (b) {
                  return Promise.reject(a(b));
                });
              };
            };
          }, {}],
          8: [function (e, d, c) {
            function g(a) {
              var b = a.filter(function (a) {
                return "audio" === a.kind;
              }),
                  c = a.filter(function (a) {
                return "video" === a.kind;
              });

              for (a = []; b.length || c.length;) {
                b.length && a.push(b.shift()), c.length && a.push(c.shift());
              }

              return a;
            }

            function a(a, b) {
              var c = !1;
              a = JSON.parse(JSON.stringify(a));
              return a.filter(function (a) {
                if (a && (a.urls || a.url)) {
                  var d = a.urls || a.url;
                  a.url && !a.urls && console.warn("RTCIceServer.url is deprecated! Use urls instead.");
                  var e = "string" === typeof d;
                  e && (d = [d]);
                  d = d.filter(function (a) {
                    return 0 !== a.indexOf("turn:") || -1 === a.indexOf("transport\x3dudp") || -1 !== a.indexOf("turn:[") || c ? 0 === a.indexOf("stun:") && 14393 <= b : c = !0;
                  });
                  delete a.url;
                  a.urls = e ? d[0] : d;
                  return !!d.length;
                }

                return !1;
              });
            }

            function b(a, b) {
              var c = {
                codecs: [],
                headerExtensions: [],
                fecMechanisms: []
              },
                  d = function d(a, b) {
                a = parseInt(a, 10);

                for (var c = 0; c < b.length; c++) {
                  if (b[c].payloadType === a || b[c].preferredPayloadType === a) return b[c];
                }
              },
                  e = function e(a, b, c, _e) {
                a = d(a.parameters.apt, c);
                b = d(b.parameters.apt, _e);
                return a && b && a.name.toLowerCase() === b.name.toLowerCase();
              };

              a.codecs.forEach(function (d) {
                for (var f = 0; f < b.codecs.length; f++) {
                  var g = b.codecs[f];

                  if (d.name.toLowerCase() === g.name.toLowerCase() && d.clockRate === g.clockRate && ("rtx" !== d.name.toLowerCase() || !d.parameters || !g.parameters.apt || e(d, g, a.codecs, b.codecs))) {
                    g = JSON.parse(JSON.stringify(g));
                    g.numChannels = Math.min(d.numChannels, g.numChannels);
                    c.codecs.push(g);
                    g.rtcpFeedback = g.rtcpFeedback.filter(function (a) {
                      for (var b = 0; b < d.rtcpFeedback.length; b++) {
                        if (d.rtcpFeedback[b].type === a.type && d.rtcpFeedback[b].parameter === a.parameter) return !0;
                      }

                      return !1;
                    });
                    break;
                  }
                }
              });
              a.headerExtensions.forEach(function (a) {
                for (var d = 0; d < b.headerExtensions.length; d++) {
                  var e = b.headerExtensions[d];

                  if (a.uri === e.uri) {
                    c.headerExtensions.push(e);
                    break;
                  }
                }
              });
              return c;
            }

            function h(a, b, c) {
              return -1 !== {
                offer: {
                  setLocalDescription: ["stable", "have-local-offer"],
                  setRemoteDescription: ["stable", "have-remote-offer"]
                },
                answer: {
                  setLocalDescription: ["have-remote-offer", "have-local-pranswer"],
                  setRemoteDescription: ["have-local-offer", "have-remote-pranswer"]
                }
              }[b][a].indexOf(c);
            }

            var m = e("sdp");

            d.exports = function (c, d) {
              var e = function e(b) {
                var e = this,
                    f = document.createDocumentFragment();
                ["addEventListener", "removeEventListener", "dispatchEvent"].forEach(function (a) {
                  e[a] = f[a].bind(f);
                });
                this.needNegotiation = !1;
                this.canTrickleIceCandidates = this.ondatachannel = this.onnegotiationneeded = this.onicegatheringstatechange = this.oniceconnectionstatechange = this.onsignalingstatechange = this.onremovestream = this.ontrack = this.onaddstream = this.onicecandidate = null;
                this.localStreams = [];
                this.remoteStreams = [];

                this.getLocalStreams = function () {
                  return e.localStreams;
                };

                this.getRemoteStreams = function () {
                  return e.remoteStreams;
                };

                this.localDescription = new c.RTCSessionDescription({
                  type: "",
                  sdp: ""
                });
                this.remoteDescription = new c.RTCSessionDescription({
                  type: "",
                  sdp: ""
                });
                this.signalingState = "stable";
                this.iceGatheringState = this.iceConnectionState = "new";
                this.iceOptions = {
                  gatherPolicy: "all",
                  iceServers: []
                };
                if (b && b.iceTransportPolicy) switch (b.iceTransportPolicy) {
                  case "all":
                  case "relay":
                    this.iceOptions.gatherPolicy = b.iceTransportPolicy;
                }
                this.usingBundle = b && "max-bundle" === b.bundlePolicy;
                b && b.iceServers && (this.iceOptions.iceServers = a(b.iceServers, d));
                this._config = b || {};
                this.transceivers = [];
                this._localIceCandidatesBuffer = [];
                this._sdpSessionId = m.generateSessionId();
              };

              e.prototype._emitGatheringStateChange = function () {
                var a = new Event("icegatheringstatechange");
                this.dispatchEvent(a);
                if (null !== this.onicegatheringstatechange) this.onicegatheringstatechange(a);
              };

              e.prototype._emitBufferedCandidates = function () {
                var a = this,
                    b = m.splitSections(a.localDescription.sdp);

                this._localIceCandidatesBuffer.forEach(function (c) {
                  if (c.candidate && 0 !== Object.keys(c.candidate).length) b[c.candidate.sdpMLineIndex + 1] += "a\x3d" + c.candidate.candidate + "\r\n";else for (var d = 1; d < b.length; d++) {
                    -1 === b[d].indexOf("\r\na\x3dend-of-candidates\r\n") && (b[d] += "a\x3dend-of-candidates\r\n");
                  }
                  a.localDescription.sdp = b.join("");
                  a.dispatchEvent(c);
                  if (null !== a.onicecandidate) a.onicecandidate(c);
                  !c.candidate && "complete" !== a.iceGatheringState && a.transceivers.every(function (a) {
                    return a.iceGatherer && "completed" === a.iceGatherer.state;
                  }) && "complete" !== a.iceGatheringStateChange && (a.iceGatheringState = "complete", a._emitGatheringStateChange());
                });

                this._localIceCandidatesBuffer = [];
              };

              e.prototype.getConfiguration = function () {
                return this._config;
              };

              e.prototype._createTransceiver = function (a) {
                var b = 0 < this.transceivers.length;
                a = {
                  track: null,
                  iceGatherer: null,
                  iceTransport: null,
                  dtlsTransport: null,
                  localCapabilities: null,
                  remoteCapabilities: null,
                  rtpSender: null,
                  rtpReceiver: null,
                  kind: a,
                  mid: null,
                  sendEncodingParameters: null,
                  recvEncodingParameters: null,
                  stream: null,
                  wantReceive: !0
                };
                this.usingBundle && b ? (a.iceTransport = this.transceivers[0].iceTransport, a.dtlsTransport = this.transceivers[0].dtlsTransport) : (b = this._createIceAndDtlsTransports(), a.iceTransport = b.iceTransport, a.dtlsTransport = b.dtlsTransport);
                this.transceivers.push(a);
                return a;
              };

              e.prototype.addTrack = function (a, b) {
                for (var d, e = 0; e < this.transceivers.length; e++) {
                  this.transceivers[e].track || this.transceivers[e].kind !== a.kind || (d = this.transceivers[e]);
                }

                d || (d = this._createTransceiver(a.kind));
                d.track = a;
                d.stream = b;
                d.rtpSender = new c.RTCRtpSender(a, d.dtlsTransport);

                this._maybeFireNegotiationNeeded();

                return d.rtpSender;
              };

              e.prototype.addStream = function (a) {
                var b = this;
                if (15025 <= d) this.localStreams.push(a), a.getTracks().forEach(function (c) {
                  b.addTrack(c, a);
                });else {
                  var c = a.clone();
                  a.getTracks().forEach(function (a, b) {
                    var d = c.getTracks()[b];
                    a.addEventListener("enabled", function (a) {
                      d.enabled = a.enabled;
                    });
                  });
                  c.getTracks().forEach(function (a) {
                    b.addTrack(a, c);
                  });
                  this.localStreams.push(c);
                }

                this._maybeFireNegotiationNeeded();
              };

              e.prototype.removeStream = function (a) {
                a = this.localStreams.indexOf(a);
                -1 < a && (this.localStreams.splice(a, 1), this._maybeFireNegotiationNeeded());
              };

              e.prototype.getSenders = function () {
                return this.transceivers.filter(function (a) {
                  return !!a.rtpSender;
                }).map(function (a) {
                  return a.rtpSender;
                });
              };

              e.prototype.getReceivers = function () {
                return this.transceivers.filter(function (a) {
                  return !!a.rtpReceiver;
                }).map(function (a) {
                  return a.rtpReceiver;
                });
              };

              e.prototype._createIceGatherer = function (a, b) {
                var d = this,
                    e = new c.RTCIceGatherer(d.iceOptions);

                e.onlocalcandidate = function (c) {
                  var f = new Event("icecandidate");
                  f.candidate = {
                    sdpMid: a,
                    sdpMLineIndex: b
                  };
                  var g = c.candidate;
                  (c = !g || 0 === Object.keys(g).length) ? void 0 === e.state && (e.state = "completed") : (g.component = 1, f.candidate.candidate = m.writeCandidate(g));
                  g = m.splitSections(d.localDescription.sdp);
                  g[f.candidate.sdpMLineIndex + 1] = c ? g[f.candidate.sdpMLineIndex + 1] + "a\x3dend-of-candidates\r\n" : g[f.candidate.sdpMLineIndex + 1] + ("a\x3d" + f.candidate.candidate + "\r\n");
                  d.localDescription.sdp = g.join("");
                  g = (d._pendingOffer ? d._pendingOffer : d.transceivers).every(function (a) {
                    return a.iceGatherer && "completed" === a.iceGatherer.state;
                  });

                  switch (d.iceGatheringState) {
                    case "new":
                      c || d._localIceCandidatesBuffer.push(f);
                      c && g && d._localIceCandidatesBuffer.push(new Event("icecandidate"));
                      break;

                    case "gathering":
                      d._emitBufferedCandidates();

                      if (!c && (d.dispatchEvent(f), null !== d.onicecandidate)) d.onicecandidate(f);

                      if (g) {
                        d.dispatchEvent(new Event("icecandidate"));
                        if (null !== d.onicecandidate) d.onicecandidate(new Event("icecandidate"));
                        d.iceGatheringState = "complete";

                        d._emitGatheringStateChange();
                      }

                  }
                };

                return e;
              };

              e.prototype._createIceAndDtlsTransports = function () {
                var a = this,
                    b = new c.RTCIceTransport(null);

                b.onicestatechange = function () {
                  a._updateConnectionState();
                };

                var d = new c.RTCDtlsTransport(b);

                d.ondtlsstatechange = function () {
                  a._updateConnectionState();
                };

                d.onerror = function () {
                  Object.defineProperty(d, "state", {
                    value: "failed",
                    writable: !0
                  });

                  a._updateConnectionState();
                };

                return {
                  iceTransport: b,
                  dtlsTransport: d
                };
              };

              e.prototype._disposeIceAndDtlsTransports = function (a) {
                var b = this.transceivers[a].iceGatherer;
                b && (delete b.onlocalcandidate, delete this.transceivers[a].iceGatherer);
                if (b = this.transceivers[a].iceTransport) delete b.onicestatechange, delete this.transceivers[a].iceTransport;
                if (b = this.transceivers[a].dtlsTransport) delete b.ondtlssttatechange, delete b.onerror, delete this.transceivers[a].dtlsTransport;
              };

              e.prototype._transceive = function (a, c, e) {
                var f = b(a.localCapabilities, a.remoteCapabilities);
                c && a.rtpSender && (f.encodings = a.sendEncodingParameters, f.rtcp = {
                  cname: m.localCName,
                  compound: a.rtcpParameters.compound
                }, a.recvEncodingParameters.length && (f.rtcp.ssrc = a.recvEncodingParameters[0].ssrc), a.rtpSender.send(f));
                e && a.rtpReceiver && ("video" === a.kind && a.recvEncodingParameters && 15019 > d && a.recvEncodingParameters.forEach(function (a) {
                  delete a.rtx;
                }), f.encodings = a.recvEncodingParameters, f.rtcp = {
                  cname: a.rtcpParameters.cname,
                  compound: a.rtcpParameters.compound
                }, a.sendEncodingParameters.length && (f.rtcp.ssrc = a.sendEncodingParameters[0].ssrc), a.rtpReceiver.receive(f));
              };

              e.prototype.setLocalDescription = function (a) {
                var d = this;

                if (!h("setLocalDescription", a.type, this.signalingState)) {
                  var e = Error("Can not set local " + a.type + " in state " + this.signalingState);
                  e.name = "InvalidStateError";
                  2 < arguments.length && "function" === typeof arguments[2] && c.setTimeout(arguments[2], 0, e);
                  return Promise.reject(e);
                }

                if ("offer" === a.type) {
                  if (this._pendingOffer) {
                    e = m.splitSections(a.sdp);
                    var f = e.shift();
                    e.forEach(function (a, b) {
                      a = m.parseRtpParameters(a);
                      d._pendingOffer[b].localCapabilities = a;
                    });
                    this.transceivers = this._pendingOffer;
                    delete this._pendingOffer;
                  }
                } else if ("answer" === a.type) {
                  e = m.splitSections(d.remoteDescription.sdp);
                  f = e.shift();
                  var g = 0 < m.matchPrefix(f, "a\x3dice-lite").length;
                  e.forEach(function (a, c) {
                    var e = d.transceivers[c],
                        h = e.iceGatherer,
                        l = e.iceTransport,
                        q = e.dtlsTransport,
                        u = e.localCapabilities,
                        n = e.remoteCapabilities;

                    if (!m.isRejected(a) && !e.isDatachannel) {
                      var p = m.getIceParameters(a, f);
                      a = m.getDtlsParameters(a, f);
                      g && (a.role = "server");
                      d.usingBundle && 0 !== c || (l.start(h, p, g ? "controlling" : "controlled"), q.start(a));
                      c = b(u, n);

                      d._transceive(e, 0 < c.codecs.length, !1);
                    }
                  });
                }

                this.localDescription = {
                  type: a.type,
                  sdp: a.sdp
                };

                switch (a.type) {
                  case "offer":
                    this._updateSignalingState("have-local-offer");

                    break;

                  case "answer":
                    this._updateSignalingState("stable");

                    break;

                  default:
                    throw new TypeError('unsupported type "' + a.type + '"');
                }

                var l = 1 < arguments.length && "function" === typeof arguments[1];

                if (l) {
                  var q = arguments[1];
                  c.setTimeout(function () {
                    q();
                    "new" === d.iceGatheringState && (d.iceGatheringState = "gathering", d._emitGatheringStateChange());

                    d._emitBufferedCandidates();
                  }, 0);
                }

                e = Promise.resolve();
                e.then(function () {
                  l || ("new" === d.iceGatheringState && (d.iceGatheringState = "gathering", d._emitGatheringStateChange()), c.setTimeout(d._emitBufferedCandidates.bind(d), 500));
                });
                return e;
              };

              e.prototype.setRemoteDescription = function (a) {
                var b = this;

                if (!h("setRemoteDescription", a.type, this.signalingState)) {
                  var e = Error("Can not set remote " + a.type + " in state " + this.signalingState);
                  e.name = "InvalidStateError";
                  2 < arguments.length && "function" === typeof arguments[2] && c.setTimeout(arguments[2], 0, e);
                  return Promise.reject(e);
                }

                var f = {},
                    g = [];
                e = m.splitSections(a.sdp);
                var l = e.shift(),
                    q = 0 < m.matchPrefix(l, "a\x3dice-lite").length,
                    n = 0 < m.matchPrefix(l, "a\x3dgroup:BUNDLE ").length;
                this.usingBundle = n;
                var p = m.matchPrefix(l, "a\x3dice-options:")[0];
                this.canTrickleIceCandidates = p ? 0 <= p.substr(14).split(" ").indexOf("trickle") : !1;
                e.forEach(function (e, h) {
                  var u = m.splitLines(e),
                      p = m.getKind(e),
                      t = m.isRejected(e),
                      x = u[0].substr(2).split(" ")[2];
                  u = m.getDirection(e, l);
                  var r = m.parseMsid(e),
                      B = m.getMid(e) || m.generateIdentifier();
                  if ("application" === p && "DTLS/SCTP" === x) b.transceivers[h] = {
                    mid: B,
                    isDatachannel: !0
                  };else {
                    var v = m.parseRtpParameters(e);

                    if (!t) {
                      var w = m.getIceParameters(e, l);
                      var y = m.getDtlsParameters(e, l);
                      y.role = "client";
                    }

                    x = m.parseRtpEncodingParameters(e);
                    var D = m.parseRtcpParameters(e),
                        C = 0 < m.matchPrefix(e, "a\x3dend-of-candidates", l).length;
                    e = m.matchPrefix(e, "a\x3dcandidate:").map(function (a) {
                      return m.parseCandidate(a);
                    }).filter(function (a) {
                      return "1" === a.component || 1 === a.component;
                    });
                    ("offer" === a.type || "answer" === a.type) && !t && n && 0 < h && b.transceivers[h] && (b._disposeIceAndDtlsTransports(h), b.transceivers[h].iceGatherer = b.transceivers[0].iceGatherer, b.transceivers[h].iceTransport = b.transceivers[0].iceTransport, b.transceivers[h].dtlsTransport = b.transceivers[0].dtlsTransport, b.transceivers[h].rtpSender && b.transceivers[h].rtpSender.setTransport(b.transceivers[0].dtlsTransport), b.transceivers[h].rtpReceiver && b.transceivers[h].rtpReceiver.setTransport(b.transceivers[0].dtlsTransport));

                    if ("offer" === a.type && !t) {
                      t = b.transceivers[h] || b._createTransceiver(p);
                      t.mid = B;
                      t.iceGatherer || (t.iceGatherer = n && 0 < h ? b.transceivers[0].iceGatherer : b._createIceGatherer(B, h));
                      !C || n && 0 !== h || t.iceTransport.setRemoteCandidates(e);
                      var z = c.RTCRtpReceiver.getCapabilities(p);
                      15019 > d && (z.codecs = z.codecs.filter(function (a) {
                        return "rtx" !== a.name;
                      }));
                      B = [{
                        ssrc: 1001 * (2 * h + 2)
                      }];

                      if ("sendrecv" === u || "sendonly" === u) {
                        var A = new c.RTCRtpReceiver(t.dtlsTransport, p);
                        w = A.track;
                        r ? (f[r.stream] || (f[r.stream] = new c.MediaStream(), Object.defineProperty(f[r.stream], "id", {
                          get: function get() {
                            return r.stream;
                          }
                        })), Object.defineProperty(w, "id", {
                          get: function get() {
                            return r.track;
                          }
                        }), f[r.stream].addTrack(w), g.push([w, A, f[r.stream]])) : (f.default || (f.default = new c.MediaStream()), f.default.addTrack(w), g.push([w, A, f.default]));
                      }

                      t.localCapabilities = z;
                      t.remoteCapabilities = v;
                      t.rtpReceiver = A;
                      t.rtcpParameters = D;
                      t.sendEncodingParameters = B;
                      t.recvEncodingParameters = x;

                      b._transceive(b.transceivers[h], !1, "sendrecv" === u || "sendonly" === u);
                    } else if ("answer" === a.type && !t) {
                      t = b.transceivers[h];
                      p = t.iceGatherer;
                      var G = t.iceTransport;
                      var I = t.dtlsTransport;
                      A = t.rtpReceiver;
                      B = t.sendEncodingParameters;
                      z = t.localCapabilities;
                      b.transceivers[h].recvEncodingParameters = x;
                      b.transceivers[h].remoteCapabilities = v;
                      b.transceivers[h].rtcpParameters = D;
                      (q || C) && e.length && G.setRemoteCandidates(e);
                      n && 0 !== h || (G.start(p, w, "controlling"), I.start(y));

                      b._transceive(t, "sendrecv" === u || "recvonly" === u, "sendrecv" === u || "sendonly" === u);

                      !A || "sendrecv" !== u && "sendonly" !== u ? delete t.rtpReceiver : (w = A.track, r ? (f[r.stream] || (f[r.stream] = new c.MediaStream()), f[r.stream].addTrack(w), g.push([w, A, f[r.stream]])) : (f.default || (f.default = new c.MediaStream()), f.default.addTrack(w), g.push([w, A, f.default])));
                    }
                  }
                });
                this.remoteDescription = {
                  type: a.type,
                  sdp: a.sdp
                };

                switch (a.type) {
                  case "offer":
                    this._updateSignalingState("have-remote-offer");

                    break;

                  case "answer":
                    this._updateSignalingState("stable");

                    break;

                  default:
                    throw new TypeError('unsupported type "' + a.type + '"');
                }

                Object.keys(f).forEach(function (a) {
                  var d = f[a];

                  if (d.getTracks().length) {
                    b.remoteStreams.push(d);
                    var e = new Event("addstream");
                    e.stream = d;
                    b.dispatchEvent(e);
                    null !== b.onaddstream && c.setTimeout(function () {
                      b.onaddstream(e);
                    }, 0);
                    g.forEach(function (a) {
                      var e = a[0],
                          f = a[1];

                      if (d.id === a[2].id) {
                        var g = new Event("track");
                        g.track = e;
                        g.receiver = f;
                        g.streams = [d];
                        b.dispatchEvent(g);
                        null !== b.ontrack && c.setTimeout(function () {
                          b.ontrack(g);
                        }, 0);
                      }
                    });
                  }
                });
                c.setTimeout(function () {
                  b && b.transceivers && b.transceivers.forEach(function (a) {
                    a.iceTransport && "new" === a.iceTransport.state && 0 < a.iceTransport.getRemoteCandidates().length && (console.warn("Timeout for addRemoteCandidate. Consider sending an end-of-candidates notification"), a.iceTransport.addRemoteCandidate({}));
                  });
                }, 4E3);
                1 < arguments.length && "function" === typeof arguments[1] && c.setTimeout(arguments[1], 0);
                return Promise.resolve();
              };

              e.prototype.close = function () {
                this.transceivers.forEach(function (a) {
                  a.iceTransport && a.iceTransport.stop();
                  a.dtlsTransport && a.dtlsTransport.stop();
                  a.rtpSender && a.rtpSender.stop();
                  a.rtpReceiver && a.rtpReceiver.stop();
                });

                this._updateSignalingState("closed");
              };

              e.prototype._updateSignalingState = function (a) {
                this.signalingState = a;
                a = new Event("signalingstatechange");
                this.dispatchEvent(a);
                if (null !== this.onsignalingstatechange) this.onsignalingstatechange(a);
              };

              e.prototype._maybeFireNegotiationNeeded = function () {
                var a = this;
                "stable" === this.signalingState && !0 !== this.needNegotiation && (this.needNegotiation = !0, c.setTimeout(function () {
                  if (!1 !== a.needNegotiation) {
                    a.needNegotiation = !1;
                    var b = new Event("negotiationneeded");
                    a.dispatchEvent(b);
                    if (null !== a.onnegotiationneeded) a.onnegotiationneeded(b);
                  }
                }, 0));
              };

              e.prototype._updateConnectionState = function () {
                var a = {
                  "new": 0,
                  closed: 0,
                  connecting: 0,
                  checking: 0,
                  connected: 0,
                  completed: 0,
                  disconnected: 0,
                  failed: 0
                };
                this.transceivers.forEach(function (b) {
                  a[b.iceTransport.state]++;
                  a[b.dtlsTransport.state]++;
                });
                a.connected += a.completed;
                var b = "new";
                if (0 < a.failed) b = "failed";else if (0 < a.connecting || 0 < a.checking) b = "connecting";else if (0 < a.disconnected) b = "disconnected";else if (0 < a.new) b = "new";else if (0 < a.connected || 0 < a.completed) b = "connected";
                if (b !== this.iceConnectionState && (this.iceConnectionState = b, b = new Event("iceconnectionstatechange"), this.dispatchEvent(b), null !== this.oniceconnectionstatechange)) this.oniceconnectionstatechange(b);
              };

              e.prototype.createOffer = function () {
                var a = this;
                if (this._pendingOffer) throw Error("createOffer called while there is a pending offer.");
                var b;
                1 === arguments.length && "function" !== typeof arguments[0] ? b = arguments[0] : 3 === arguments.length && (b = arguments[2]);
                var e = this.transceivers.filter(function (a) {
                  return "audio" === a.kind;
                }).length,
                    h = this.transceivers.filter(function (a) {
                  return "video" === a.kind;
                }).length;

                if (b) {
                  if (b.mandatory || b.optional) throw new TypeError("Legacy mandatory/optional constraints not supported.");
                  void 0 !== b.offerToReceiveAudio && (e = !0 === b.offerToReceiveAudio ? 1 : !1 === b.offerToReceiveAudio ? 0 : b.offerToReceiveAudio);
                  void 0 !== b.offerToReceiveVideo && (h = !0 === b.offerToReceiveVideo ? 1 : !1 === b.offerToReceiveVideo ? 0 : b.offerToReceiveVideo);
                }

                for (this.transceivers.forEach(function (a) {
                  "audio" === a.kind ? (e--, 0 > e && (a.wantReceive = !1)) : "video" === a.kind && (h--, 0 > h && (a.wantReceive = !1));
                }); 0 < e || 0 < h;) {
                  0 < e && (this._createTransceiver("audio"), e--), 0 < h && (this._createTransceiver("video"), h--);
                }

                var l = g(this.transceivers),
                    q = m.writeSessionBoilerplate(this._sdpSessionId);
                l.forEach(function (b, e) {
                  var f = b.track,
                      g = b.kind,
                      h = m.generateIdentifier();
                  b.mid = h;
                  b.iceGatherer || (b.iceGatherer = a.usingBundle && 0 < e ? l[0].iceGatherer : a._createIceGatherer(h, e));
                  h = c.RTCRtpSender.getCapabilities(g);
                  15019 > d && (h.codecs = h.codecs.filter(function (a) {
                    return "rtx" !== a.name;
                  }));
                  h.codecs.forEach(function (a) {
                    "H264" === a.name && void 0 === a.parameters["level-asymmetry-allowed"] && (a.parameters["level-asymmetry-allowed"] = "1");
                  });
                  var q = [{
                    ssrc: 1001 * (2 * e + 1)
                  }];
                  f && 15019 <= d && "video" === g && (q[0].rtx = {
                    ssrc: 1001 * (2 * e + 1) + 1
                  });
                  b.wantReceive && (b.rtpReceiver = new c.RTCRtpReceiver(b.dtlsTransport, g));
                  b.localCapabilities = h;
                  b.sendEncodingParameters = q;
                });
                "max-compat" !== this._config.bundlePolicy && (q += "a\x3dgroup:BUNDLE " + l.map(function (a) {
                  return a.mid;
                }).join(" ") + "\r\n");
                q += "a\x3dice-options:trickle\r\n";
                l.forEach(function (a, b) {
                  q += m.writeMediaSection(a, a.localCapabilities, "offer", a.stream);
                  q += "a\x3drtcp-rsize\r\n";
                });
                this._pendingOffer = l;
                b = new c.RTCSessionDescription({
                  type: "offer",
                  sdp: q
                });
                arguments.length && "function" === typeof arguments[0] && c.setTimeout(arguments[0], 0, b);
                return Promise.resolve(b);
              };

              e.prototype.createAnswer = function () {
                var a = m.writeSessionBoilerplate(this._sdpSessionId);
                this.usingBundle && (a += "a\x3dgroup:BUNDLE " + this.transceivers.map(function (a) {
                  return a.mid;
                }).join(" ") + "\r\n");
                this.transceivers.forEach(function (c, e) {
                  if (c.isDatachannel) a += "m\x3dapplication 0 DTLS/SCTP 5000\r\nc\x3dIN IP4 0.0.0.0\r\na\x3dmid:" + c.mid + "\r\n";else {
                    if (c.stream) {
                      var f;
                      "audio" === c.kind ? f = c.stream.getAudioTracks()[0] : "video" === c.kind && (f = c.stream.getVideoTracks()[0]);
                      f && 15019 <= d && "video" === c.kind && (c.sendEncodingParameters[0].rtx = {
                        ssrc: 1001 * (2 * e + 2) + 1
                      });
                    }

                    e = b(c.localCapabilities, c.remoteCapabilities);
                    !e.codecs.filter(function (a) {
                      return "rtx" === a.name.toLowerCase();
                    }).length && c.sendEncodingParameters[0].rtx && delete c.sendEncodingParameters[0].rtx;
                    a += m.writeMediaSection(c, e, "answer", c.stream);
                    c.rtcpParameters && c.rtcpParameters.reducedSize && (a += "a\x3drtcp-rsize\r\n");
                  }
                });
                var e = new c.RTCSessionDescription({
                  type: "answer",
                  sdp: a
                });
                arguments.length && "function" === typeof arguments[0] && c.setTimeout(arguments[0], 0, e);
                return Promise.resolve(e);
              };

              e.prototype.addIceCandidate = function (a) {
                if (a) {
                  var b = a.sdpMLineIndex;
                  if (a.sdpMid) for (var d = 0; d < this.transceivers.length; d++) {
                    if (this.transceivers[d].mid === a.sdpMid) {
                      b = d;
                      break;
                    }
                  }
                  var e = this.transceivers[b];

                  if (e) {
                    d = 0 < Object.keys(a.candidate).length ? m.parseCandidate(a.candidate) : {};
                    if ("tcp" === d.protocol && (0 === d.port || 9 === d.port) || d.component && "1" !== d.component && 1 !== d.component) return Promise.resolve();
                    e.iceTransport.addRemoteCandidate(d);
                    e = m.splitSections(this.remoteDescription.sdp);
                    e[b + 1] += (d.type ? a.candidate.trim() : "a\x3dend-of-candidates") + "\r\n";
                    this.remoteDescription.sdp = e.join("");
                  }
                } else for (b = 0; b < this.transceivers.length; b++) {
                  if (this.transceivers[b].iceTransport.addRemoteCandidate({}), this.usingBundle) return Promise.resolve();
                }

                1 < arguments.length && "function" === typeof arguments[1] && c.setTimeout(arguments[1], 0);
                return Promise.resolve();
              };

              e.prototype.getStats = function () {
                var a = [];
                this.transceivers.forEach(function (b) {
                  ["rtpSender", "rtpReceiver", "iceGatherer", "iceTransport", "dtlsTransport"].forEach(function (c) {
                    b[c] && a.push(b[c].getStats());
                  });
                });
                var b = 1 < arguments.length && "function" === typeof arguments[1] && arguments[1];
                return new Promise(function (d) {
                  var e = new Map();
                  Promise.all(a).then(function (a) {
                    a.forEach(function (a) {
                      Object.keys(a).forEach(function (b) {
                        var c = a[b];
                        a[b].type = {
                          inboundrtp: "inbound-rtp",
                          outboundrtp: "outbound-rtp",
                          candidatepair: "candidate-pair",
                          localcandidate: "local-candidate",
                          remotecandidate: "remote-candidate"
                        }[c.type] || c.type;
                        e.set(b, a[b]);
                      });
                    });
                    b && c.setTimeout(b, 0, e);
                    d(e);
                  });
                });
              };

              return e;
            };
          }, {
            sdp: 1
          }],
          9: [function (e, d, c) {
            var g = e("../utils");
            d.exports = {
              shimOnTrack: function shimOnTrack(a) {
                "object" !== _typeof(a) || !a.RTCPeerConnection || "ontrack" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, "ontrack", {
                  get: function get() {
                    return this._ontrack;
                  },
                  set: function set(a) {
                    this._ontrack && (this.removeEventListener("track", this._ontrack), this.removeEventListener("addstream", this._ontrackpoly));
                    this.addEventListener("track", this._ontrack = a);
                    this.addEventListener("addstream", this._ontrackpoly = function (a) {
                      a.stream.getTracks().forEach(function (b) {
                        var c = new Event("track");
                        c.track = b;
                        c.receiver = {
                          track: b
                        };
                        c.streams = [a.stream];
                        this.dispatchEvent(c);
                      }.bind(this));
                    }.bind(this));
                  }
                });
              },
              shimSourceObject: function shimSourceObject(a) {
                "object" === _typeof(a) && (!a.HTMLMediaElement || "srcObject" in a.HTMLMediaElement.prototype || Object.defineProperty(a.HTMLMediaElement.prototype, "srcObject", {
                  get: function get() {
                    return this.mozSrcObject;
                  },
                  set: function set(a) {
                    this.mozSrcObject = a;
                  }
                }));
              },
              shimPeerConnection: function shimPeerConnection(a) {
                var b = g.detectBrowser(a);

                if ("object" === _typeof(a) && (a.RTCPeerConnection || a.mozRTCPeerConnection)) {
                  a.RTCPeerConnection || (a.RTCPeerConnection = function (c, d) {
                    if (38 > b.version && c && c.iceServers) {
                      for (var e = [], f = 0; f < c.iceServers.length; f++) {
                        var g = c.iceServers[f];
                        if (g.hasOwnProperty("urls")) for (var h = 0; h < g.urls.length; h++) {
                          var l = {
                            url: g.urls[h]
                          };
                          0 === g.urls[h].indexOf("turn") && (l.username = g.username, l.credential = g.credential);
                          e.push(l);
                        } else e.push(c.iceServers[f]);
                      }

                      c.iceServers = e;
                    }

                    return new a.mozRTCPeerConnection(c, d);
                  }, a.RTCPeerConnection.prototype = a.mozRTCPeerConnection.prototype, a.mozRTCPeerConnection.generateCertificate && Object.defineProperty(a.RTCPeerConnection, "generateCertificate", {
                    get: function get() {
                      return a.mozRTCPeerConnection.generateCertificate;
                    }
                  }), a.RTCSessionDescription = a.mozRTCSessionDescription, a.RTCIceCandidate = a.mozRTCIceCandidate);
                  ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (b) {
                    var c = a.RTCPeerConnection.prototype[b];

                    a.RTCPeerConnection.prototype[b] = function () {
                      arguments[0] = new ("addIceCandidate" === b ? a.RTCIceCandidate : a.RTCSessionDescription)(arguments[0]);
                      return c.apply(this, arguments);
                    };
                  });
                  var c = a.RTCPeerConnection.prototype.addIceCandidate;

                  a.RTCPeerConnection.prototype.addIceCandidate = function () {
                    return arguments[0] ? c.apply(this, arguments) : (arguments[1] && arguments[1].apply(null), Promise.resolve());
                  };

                  var d = function d(a) {
                    var b = new Map();
                    Object.keys(a).forEach(function (c) {
                      b.set(c, a[c]);
                      b[c] = a[c];
                    });
                    return b;
                  },
                      e = {
                    inboundrtp: "inbound-rtp",
                    outboundrtp: "outbound-rtp",
                    candidatepair: "candidate-pair",
                    localcandidate: "local-candidate",
                    remotecandidate: "remote-candidate"
                  },
                      h = a.RTCPeerConnection.prototype.getStats;

                  a.RTCPeerConnection.prototype.getStats = function (a, c, g) {
                    return h.apply(this, [a || null]).then(function (a) {
                      48 > b.version && (a = d(a));
                      if (53 > b.version && !c) try {
                        a.forEach(function (a) {
                          a.type = e[a.type] || a.type;
                        });
                      } catch (w) {
                        if ("TypeError" !== w.name) throw w;
                        a.forEach(function (b, c) {
                          a.set(c, Object.assign({}, b, {
                            type: e[b.type] || b.type
                          }));
                        });
                      }
                      return a;
                    }).then(c, g);
                  };
                }
              },
              shimGetUserMedia: e("./getusermedia")
            };
          }, {
            "../utils": 12,
            "./getusermedia": 10
          }],
          10: [function (e, d, c) {
            var g = e("../utils"),
                a = g.log;

            d.exports = function (b) {
              var c = g.detectBrowser(b),
                  d = b && b.navigator;
              b = b && b.MediaStreamTrack;

              var e = function e(a) {
                return {
                  name: {
                    InternalError: "NotReadableError",
                    NotSupportedError: "TypeError",
                    PermissionDeniedError: "NotAllowedError",
                    SecurityError: "NotAllowedError"
                  }[a.name] || a.name,
                  message: {
                    "The operation is insecure.": "The request is not allowed by the user agent or the platform in the current context."
                  }[a.message] || a.message,
                  constraint: a.constraint,
                  toString: function toString() {
                    return this.name + (this.message && ": ") + this.message;
                  }
                };
              },
                  h = function h(b, f, g) {
                var h = function h(a) {
                  if ("object" !== _typeof(a) || a.require) return a;
                  var b = [];
                  Object.keys(a).forEach(function (c) {
                    if ("require" !== c && "advanced" !== c && "mediaSource" !== c) {
                      var d = a[c] = "object" === _typeof(a[c]) ? a[c] : {
                        ideal: a[c]
                      };
                      void 0 === d.min && void 0 === d.max && void 0 === d.exact || b.push(c);
                      void 0 !== d.exact && ("number" === typeof d.exact ? d.min = d.max = d.exact : a[c] = d.exact, delete d.exact);

                      if (void 0 !== d.ideal) {
                        a.advanced = a.advanced || [];
                        var e = {};
                        e[c] = "number" === typeof d.ideal ? {
                          min: d.ideal,
                          max: d.ideal
                        } : d.ideal;
                        a.advanced.push(e);
                        delete d.ideal;
                        Object.keys(d).length || delete a[c];
                      }
                    }
                  });
                  b.length && (a.require = b);
                  return a;
                };

                b = JSON.parse(JSON.stringify(b));
                38 > c.version && (a("spec: " + JSON.stringify(b)), b.audio && (b.audio = h(b.audio)), b.video && (b.video = h(b.video)), a("ff37: " + JSON.stringify(b)));
                return d.mozGetUserMedia(b, f, function (a) {
                  g(e(a));
                });
              },
                  n = function n(a) {
                return new Promise(function (b, c) {
                  h(a, b, c);
                });
              };

              d.mediaDevices || (d.mediaDevices = {
                getUserMedia: n,
                addEventListener: function addEventListener() {},
                removeEventListener: function removeEventListener() {}
              });

              d.mediaDevices.enumerateDevices = d.mediaDevices.enumerateDevices || function () {
                return new Promise(function (a) {
                  a([{
                    kind: "audioinput",
                    deviceId: "default",
                    label: "",
                    groupId: ""
                  }, {
                    kind: "videoinput",
                    deviceId: "default",
                    label: "",
                    groupId: ""
                  }]);
                });
              };

              if (41 > c.version) {
                var f = d.mediaDevices.enumerateDevices.bind(d.mediaDevices);

                d.mediaDevices.enumerateDevices = function () {
                  return f().then(void 0, function (a) {
                    if ("NotFoundError" === a.name) return [];
                    throw a;
                  });
                };
              }

              if (49 > c.version) {
                var p = d.mediaDevices.getUserMedia.bind(d.mediaDevices);

                d.mediaDevices.getUserMedia = function (a) {
                  return p(a).then(function (b) {
                    if (a.audio && !b.getAudioTracks().length || a.video && !b.getVideoTracks().length) throw b.getTracks().forEach(function (a) {
                      a.stop();
                    }), new DOMException("The object can not be found here.", "NotFoundError");
                    return b;
                  }, function (a) {
                    return Promise.reject(e(a));
                  });
                };
              }

              if (!(55 < c.version && "autoGainControl" in d.mediaDevices.getSupportedConstraints())) {
                var r = function r(a, b, c) {
                  b in a && !(c in a) && (a[c] = a[b], delete a[b]);
                },
                    w = d.mediaDevices.getUserMedia.bind(d.mediaDevices);

                d.mediaDevices.getUserMedia = function (a) {
                  "object" === _typeof(a) && "object" === _typeof(a.audio) && (a = JSON.parse(JSON.stringify(a)), r(a.audio, "autoGainControl", "mozAutoGainControl"), r(a.audio, "noiseSuppression", "mozNoiseSuppression"));
                  return w(a);
                };

                if (b && b.prototype.getSettings) {
                  var y = b.prototype.getSettings;

                  b.prototype.getSettings = function () {
                    var a = y.apply(this, arguments);
                    r(a, "mozAutoGainControl", "autoGainControl");
                    r(a, "mozNoiseSuppression", "noiseSuppression");
                    return a;
                  };
                }

                if (b && b.prototype.applyConstraints) {
                  var z = b.prototype.applyConstraints;

                  b.prototype.applyConstraints = function (a) {
                    "audio" === this.kind && "object" === _typeof(a) && (a = JSON.parse(JSON.stringify(a)), r(a, "autoGainControl", "mozAutoGainControl"), r(a, "noiseSuppression", "mozNoiseSuppression"));
                    return z.apply(this, [a]);
                  };
                }
              }

              d.getUserMedia = function (a, b, e) {
                if (44 > c.version) return h(a, b, e);
                console.warn("navigator.getUserMedia has been replaced by navigator.mediaDevices.getUserMedia");
                d.mediaDevices.getUserMedia(a).then(b, e);
              };
            };
          }, {
            "../utils": 12
          }],
          11: [function (e, d, c) {
            var g = e("../utils");
            d.exports = {
              shimCallbacksAPI: function shimCallbacksAPI(a) {
                if ("object" === _typeof(a) && a.RTCPeerConnection) {
                  a = a.RTCPeerConnection.prototype;
                  var b = a.createOffer,
                      c = a.createAnswer,
                      d = a.setLocalDescription,
                      e = a.setRemoteDescription,
                      g = a.addIceCandidate;

                  a.createOffer = function (a, c) {
                    var d = b.apply(this, [2 <= arguments.length ? arguments[2] : arguments[0]]);
                    if (!c) return d;
                    d.then(a, c);
                    return Promise.resolve();
                  };

                  a.createAnswer = function (a, b) {
                    var d = c.apply(this, [2 <= arguments.length ? arguments[2] : arguments[0]]);
                    if (!b) return d;
                    d.then(a, b);
                    return Promise.resolve();
                  };

                  var h = function h(a, b, c) {
                    a = d.apply(this, [a]);
                    if (!c) return a;
                    a.then(b, c);
                    return Promise.resolve();
                  };

                  a.setLocalDescription = h;

                  h = function h(a, b, c) {
                    a = e.apply(this, [a]);
                    if (!c) return a;
                    a.then(b, c);
                    return Promise.resolve();
                  };

                  a.setRemoteDescription = h;

                  h = function h(a, b, c) {
                    a = g.apply(this, [a]);
                    if (!c) return a;
                    a.then(b, c);
                    return Promise.resolve();
                  };

                  a.addIceCandidate = h;
                }
              },
              shimLocalStreamsAPI: function shimLocalStreamsAPI(a) {
                if ("object" === _typeof(a) && a.RTCPeerConnection) {
                  "getLocalStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getLocalStreams = function () {
                    this._localStreams || (this._localStreams = []);
                    return this._localStreams;
                  });
                  "getStreamById" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getStreamById = function (a) {
                    var b = null;
                    this._localStreams && this._localStreams.forEach(function (c) {
                      c.id === a && (b = c);
                    });
                    this._remoteStreams && this._remoteStreams.forEach(function (c) {
                      c.id === a && (b = c);
                    });
                    return b;
                  });

                  if (!("addStream" in a.RTCPeerConnection.prototype)) {
                    var b = a.RTCPeerConnection.prototype.addTrack;

                    a.RTCPeerConnection.prototype.addStream = function (a) {
                      this._localStreams || (this._localStreams = []);
                      -1 === this._localStreams.indexOf(a) && this._localStreams.push(a);
                      var c = this;
                      a.getTracks().forEach(function (d) {
                        b.call(c, d, a);
                      });
                    };

                    a.RTCPeerConnection.prototype.addTrack = function (a, c) {
                      c && (this._localStreams ? -1 === this._localStreams.indexOf(c) && this._localStreams.push(c) : this._localStreams = [c]);
                      b.call(this, a, c);
                    };
                  }

                  "removeStream" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.removeStream = function (a) {
                    this._localStreams || (this._localStreams = []);

                    var b = this._localStreams.indexOf(a);

                    if (-1 !== b) {
                      this._localStreams.splice(b, 1);

                      var c = this,
                          d = a.getTracks();
                      this.getSenders().forEach(function (a) {
                        -1 !== d.indexOf(a.track) && c.removeTrack(a);
                      });
                    }
                  });
                }
              },
              shimRemoteStreamsAPI: function shimRemoteStreamsAPI(a) {
                "object" === _typeof(a) && a.RTCPeerConnection && ("getRemoteStreams" in a.RTCPeerConnection.prototype || (a.RTCPeerConnection.prototype.getRemoteStreams = function () {
                  return this._remoteStreams ? this._remoteStreams : [];
                }), "onaddstream" in a.RTCPeerConnection.prototype || Object.defineProperty(a.RTCPeerConnection.prototype, "onaddstream", {
                  get: function get() {
                    return this._onaddstream;
                  },
                  set: function set(a) {
                    this._onaddstream && (this.removeEventListener("addstream", this._onaddstream), this.removeEventListener("track", this._onaddstreampoly));
                    this.addEventListener("addstream", this._onaddstream = a);
                    this.addEventListener("track", this._onaddstreampoly = function (a) {
                      var b = a.streams[0];
                      this._remoteStreams || (this._remoteStreams = []);
                      0 <= this._remoteStreams.indexOf(b) || (this._remoteStreams.push(b), b = new Event("addstream"), b.stream = a.streams[0], this.dispatchEvent(b));
                    }.bind(this));
                  }
                }));
              },
              shimGetUserMedia: function shimGetUserMedia(a) {
                var b = a && a.navigator;
                b.getUserMedia || (b.webkitGetUserMedia ? b.getUserMedia = b.webkitGetUserMedia.bind(b) : b.mediaDevices && b.mediaDevices.getUserMedia && (b.getUserMedia = function (a, c, d) {
                  b.mediaDevices.getUserMedia(a).then(c, d);
                }.bind(b)));
              },
              shimRTCIceServerUrls: function shimRTCIceServerUrls(a) {
                var b = a.RTCPeerConnection;

                a.RTCPeerConnection = function (a, c) {
                  if (a && a.iceServers) {
                    for (var d = [], e = 0; e < a.iceServers.length; e++) {
                      var h = a.iceServers[e];
                      !h.hasOwnProperty("urls") && h.hasOwnProperty("url") ? (g.deprecated("RTCIceServer.url", "RTCIceServer.urls"), h = JSON.parse(JSON.stringify(h)), h.urls = h.url, delete h.url, d.push(h)) : d.push(a.iceServers[e]);
                    }

                    a.iceServers = d;
                  }

                  return new b(a, c);
                };

                a.RTCPeerConnection.prototype = b.prototype;
                Object.defineProperty(a.RTCPeerConnection, "generateCertificate", {
                  get: function get() {
                    return b.generateCertificate;
                  }
                });
              }
            };
          }, {
            "../utils": 12
          }],
          12: [function (e, d, c) {
            var g = !0,
                a = !0,
                b = {
              disableLog: function disableLog(a) {
                return "boolean" !== typeof a ? Error("Argument type: " + _typeof(a) + ". Please use a boolean.") : (g = a) ? "adapter.js logging disabled" : "adapter.js logging enabled";
              },
              disableWarnings: function disableWarnings(b) {
                if ("boolean" !== typeof b) return Error("Argument type: " + _typeof(b) + ". Please use a boolean.");
                a = !b;
                return "adapter.js deprecation warnings " + (b ? "disabled" : "enabled");
              },
              log: function log() {
                "object" !== (typeof window === "undefined" ? "undefined" : _typeof(window)) || g || "undefined" !== typeof console && "function" === typeof console.log && console.log.apply(console, arguments);
              },
              deprecated: function deprecated(b, c) {
                a && console.warn(b + " is deprecated, please use " + c + " instead.");
              },
              extractVersion: function extractVersion(a, b, c) {
                return (a = a.match(b)) && a.length >= c && parseInt(a[c], 10);
              },
              detectBrowser: function detectBrowser(a) {
                var b = a && a.navigator,
                    c = {
                  browser: null,
                  version: null
                };
                if ("undefined" === typeof a || !a.navigator) return c.browser = "Not a browser.", c;
                b.mozGetUserMedia ? (c.browser = "firefox", c.version = this.extractVersion(b.userAgent, /Firefox\/(\d+)\./, 1)) : b.webkitGetUserMedia ? a.webkitRTCPeerConnection ? (c.browser = "chrome", c.version = this.extractVersion(b.userAgent, /Chrom(e|ium)\/(\d+)\./, 2)) : b.userAgent.match(/Version\/(\d+).(\d+)/) ? (c.browser = "safari", c.version = this.extractVersion(b.userAgent, /AppleWebKit\/(\d+)\./, 1)) : c.browser = "Unsupported webkit-based browser with GUM support but no WebRTC support." : b.mediaDevices && b.userAgent.match(/Edge\/(\d+).(\d+)$/) ? (c.browser = "edge", c.version = this.extractVersion(b.userAgent, /Edge\/(\d+).(\d+)$/, 2)) : b.mediaDevices && b.userAgent.match(/AppleWebKit\/(\d+)\./) ? (c.browser = "safari", c.version = this.extractVersion(b.userAgent, /AppleWebKit\/(\d+)\./, 1)) : c.browser = "Not a supported browser.";
                return c;
              },
              shimCreateObjectURL: function shimCreateObjectURL(a) {
                var c = a && a.URL;

                if ("object" === _typeof(a) && a.HTMLMediaElement && "srcObject" in a.HTMLMediaElement.prototype) {
                  var d = c.createObjectURL.bind(c),
                      e = c.revokeObjectURL.bind(c),
                      g = new Map(),
                      f = 0;

                  c.createObjectURL = function (a) {
                    console.log('getTracks', a);

                    if ("getTracks" in a) {
                      var c = "polyblob:" + ++f;
                      g.set(c, a);
                      b.deprecated("URL.createObjectURL(stream)", "elem.srcObject \x3d stream");
                      return c;
                    }

                    return d(a);
                  };

                  c.revokeObjectURL = function (a) {
                    e(a);
                    g.delete(a);
                  };

                  var h = Object.getOwnPropertyDescriptor(a.HTMLMediaElement.prototype, "src");
                  Object.defineProperty(a.HTMLMediaElement.prototype, "src", {
                    get: function get() {
                      return h.get.apply(this);
                    },
                    set: function set(a) {
                      this.srcObject = g.get(a) || null;
                      return h.set.apply(this, [a]);
                    }
                  });
                  var n = a.HTMLMediaElement.prototype.setAttribute;

                  a.HTMLMediaElement.prototype.setAttribute = function () {
                    2 === arguments.length && "src" === ("" + arguments[0]).toLowerCase() && (this.srcObject = g.get(arguments[1]) || null);
                    return n.apply(this, arguments);
                  };
                }
              }
            };
            d.exports = {
              log: b.log,
              deprecated: b.deprecated,
              disableLog: b.disableLog,
              disableWarnings: b.disableWarnings,
              extractVersion: b.extractVersion,
              shimCreateObjectURL: b.shimCreateObjectURL,
              detectBrowser: b.detectBrowser.bind(b)
            };
          }, {}]
        }, {}, [2])(2);
      }();
    }).call(r, n(8));
  }, function (p, r, n) {
    n(25)(n(26));
  }, function (p, r) {
    p.exports = function (n) {
      "undefined" !== typeof execScript ? execScript(n) : eval.call(null, n);
    };
  }, function (p, r) {
    p.exports = "/* globals $$, jQuery, Elements, document, window, L */\n\n/**\n* Copyright 2013 Marc J. Schmidt. See the LICENSE file at the top-level\n* directory of this distribution and at\n* https://github.com/marcj/css-element-queries/blob/master/LICENSE.\n*/\nthis.L \x3d this.L || {};\n\n/**\n * @param {HTMLElement} element\n * @param {String}      prop\n * @returns {String|Number}\n */\nL.GetComputedStyle \x3d (computedElement, prop) \x3d\x3e {\n  if (computedElement.currentStyle) {\n    return computedElement.currentStyle[prop];\n  } else if (window.getComputedStyle) {\n    return window.getComputedStyle(computedElement, null).getPropertyValue(prop);\n  }\n  return computedElement.style[prop];\n};\n\n  /**\n   *\n   * @type {Function}\n   * @constructor\n   */\nL.ElementQueries \x3d function ElementQueries() {\n      /**\n       *\n       * @param element\n       * @returns {Number}\n       */\n  function getEmSize(element \x3d document.documentElement) {\n    const fontSize \x3d L.GetComputedStyle(element, 'fontSize');\n    return parseFloat(fontSize) || 16;\n  }\n\n      /**\n       *\n       * @copyright https://github.com/Mr0grog/element-query/blob/master/LICENSE\n       *\n       * @param element\n       * @param value\n       * @param units\n       * @returns {*}\n       */\n  function convertToPx(element, originalValue) {\n    let vh;\n    let vw;\n    let chooser;\n    const units \x3d originalValue.replace(/[0-9]*/, '');\n    const value \x3d parseFloat(originalValue);\n    switch (units) {\n      case 'px':\n        return value;\n      case 'em':\n        return value * getEmSize(element);\n      case 'rem':\n        return value * getEmSize();\n              // Viewport units!\n              // According to http://quirksmode.org/mobile/tableViewport.html\n              // documentElement.clientWidth/Height gets us the most reliable info\n      case 'vw':\n        return (value * document.documentElement.clientWidth) / 100;\n      case 'vh':\n        return (value * document.documentElement.clientHeight) / 100;\n      case 'vmin':\n      case 'vmax':\n        vw \x3d document.documentElement.clientWidth / 100;\n        vh \x3d document.documentElement.clientHeight / 100;\n        chooser \x3d Math[units \x3d\x3d\x3d 'vmin' ? 'min' : 'max'];\n        return value * chooser(vw, vh);\n      default:\n        return value;\n              // for now, not supporting physical units (since they are just a set number of px)\n              // or ex/ch (getting accurate measurements is hard)\n    }\n  }\n\n      /**\n       *\n       * @param {HTMLElement} element\n       * @constructor\n       */\n  function SetupInformation(element) {\n    this.element \x3d element;\n    this.options \x3d [];\n    let i;\n    let j;\n    let option;\n    let width \x3d 0;\n    let height \x3d 0;\n    let value;\n    let actualValue;\n    let attrValues;\n    let attrValue;\n    let attrName;\n\n          /**\n           * @param option {mode: 'min|max', property: 'width|height', value: '123px'}\n           */\n    this.addOption \x3d (newOption) \x3d\x3e {\n      this.options.push(newOption);\n    };\n\n    const attributes \x3d ['min-width', 'min-height', 'max-width', 'max-height'];\n\n          /**\n           * Extracts the computed width/height and sets to min/max- attribute.\n           */\n    this.call \x3d () \x3d\x3e {\n              // extract current dimensions\n      width \x3d this.element.offsetWidth;\n      height \x3d this.element.offsetHeight;\n\n      attrValues \x3d {};\n\n      for (i \x3d 0, j \x3d this.options.length; i \x3c j; i +\x3d 1) {\n        option \x3d this.options[i];\n        value \x3d convertToPx(this.element, option.value);\n\n        actualValue \x3d option.property \x3d\x3d\x3d 'width' ? width : height;\n        attrName \x3d `${option.mode}-${option.property}`;\n        attrValue \x3d '';\n\n        if (option.mode \x3d\x3d\x3d 'min' \x26\x26 actualValue \x3e\x3d value) {\n          attrValue +\x3d option.value;\n        }\n\n        if (option.mode \x3d\x3d\x3d 'max' \x26\x26 actualValue \x3c\x3d value) {\n          attrValue +\x3d option.value;\n        }\n\n        if (!attrValues[attrName]) attrValues[attrName] \x3d '';\n        if (attrValue \x26\x26 (` ${attrValues[attrName]} `)\n                                            .indexOf(` ${attrValue} `) \x3d\x3d\x3d -1) {\n          attrValues[attrName] +\x3d ` ${attrValue}`;\n        }\n      }\n\n      for (let k \x3d 0; k \x3c attributes.length; k +\x3d 1) {\n        if (attrValues[attributes[k]]) {\n          this.element.setAttribute(attributes[k],\n                                                attrValues[attributes[k]].substr(1));\n        } else {\n          this.element.removeAttribute(attributes[k]);\n        }\n      }\n    };\n  }\n\n      /**\n       * @param {HTMLElement} element\n       * @param {Object}      options\n       */\n  function setupElement(originalElement, options) {\n    const element \x3d originalElement;\n    if (element.elementQueriesSetupInformation) {\n      element.elementQueriesSetupInformation.addOption(options);\n    } else {\n      element.elementQueriesSetupInformation \x3d new SetupInformation(element);\n      element.elementQueriesSetupInformation.addOption(options);\n      element.sensor \x3d new L.ResizeSensor(element, () \x3d\x3e {\n        element.elementQueriesSetupInformation.call();\n      });\n    }\n    element.elementQueriesSetupInformation.call();\n    return element;\n  }\n\n      /**\n       * @param {String} selector\n       * @param {String} mode min|max\n       * @param {String} property width|height\n       * @param {String} value\n       */\n  function queueQuery(selector, mode, property, value) {\n    let query;\n    if (document.querySelectorAll) query \x3d document.querySelectorAll.bind(document);\n    if (!query \x26\x26 typeof $$ !\x3d\x3d 'undefined') query \x3d $$;\n    if (!query \x26\x26 typeof jQuery !\x3d\x3d 'undefined') query \x3d jQuery;\n\n    if (!query) {\n      throw new Error('No document.querySelectorAll, jQuery or Mootools\\'s $$ found.');\n    }\n\n    const elements \x3d query(selector) || [];\n    for (let i \x3d 0, j \x3d elements.length; i \x3c j; i +\x3d 1) {\n      elements[i] \x3d setupElement(elements[i], {\n        mode,\n        property,\n        value,\n      });\n    }\n  }\n\n  const regex \x3d /,?([^,\\n]*)\\[[\\s\\t]*(min|max)-(width|height)[\\s\\t]*[~$^]?\x3d[\\s\\t]*\"([^\"]*)\"[\\s\\t]*]([^\\n\\s{]*)/mgi;  // jshint ignore:line\n\n      /**\n       * @param {String} css\n       */\n  function extractQuery(originalCss) {\n    let match;\n    const css \x3d originalCss.replace(/'/g, '\"');\n    while ((match \x3d regex.exec(css)) !\x3d\x3d null) {\n      if (match.length \x3e 5) {\n        queueQuery(match[1] || match[5], match[2], match[3], match[4]);\n      }\n    }\n  }\n\n      /**\n       * @param {CssRule[]|String} rules\n       */\n  function readRules(originalRules) {\n    let selector \x3d '';\n    let rules \x3d [];\n    if (!originalRules) {\n      return;\n    }\n    if (typeof originalRules \x3d\x3d\x3d 'string') {\n      rules \x3d originalRules.toLowerCase();\n      if (rules.indexOf('min-width') !\x3d\x3d -1 || rules.indexOf('max-width') !\x3d\x3d -1) {\n        extractQuery(rules);\n      }\n    } else {\n      for (let i \x3d 0, j \x3d rules.length; i \x3c j; i +\x3d 1) {\n        if (rules[i].type \x3d\x3d\x3d 1) {\n          selector \x3d rules[i].selectorText || rules[i].cssText;\n          if (selector.indexOf('min-height') !\x3d\x3d -1 ||\n                          selector.indexOf('max-height') !\x3d\x3d -1) {\n            extractQuery(selector);\n          } else if (selector.indexOf('min-width') !\x3d\x3d -1 ||\n                                 selector.indexOf('max-width') !\x3d\x3d -1) {\n            extractQuery(selector);\n          }\n        } else if (rules[i].type \x3d\x3d\x3d 4) {\n          readRules(rules[i].cssRules || rules[i].rules);\n        }\n      }\n    }\n  }\n\n      /**\n       * Searches all css rules and setups the event listener\n       * to all elements with element query rules..\n       */\n  this.init \x3d () \x3d\x3e {\n    const styleSheets \x3d document.styleSheets || [];\n    for (let i \x3d 0, j \x3d styleSheets.length; i \x3c j; i +\x3d 1) {\n      readRules(styleSheets[i].cssText ||\n                        styleSheets[i].cssRules ||\n                        styleSheets[i].rules);\n    }\n  };\n};\n\nfunction init() {\n  (new L.ElementQueries()).init();\n}\n\nif (window.addEventListener) {\n  window.addEventListener('load', init, false);\n} else {\n  window.attachEvent('onload', init);\n}\n\n  /**\n   * Iterate over each of the provided element(s).\n   *\n   * @param {HTMLElement|HTMLElement[]} elements\n   * @param {Function}                  callback\n   */\nfunction forEachElement(elements, callback \x3d () \x3d\x3e {}) {\n  const elementsType \x3d Object.prototype.toString.call(elements);\n  const isCollectionTyped \x3d (elementsType \x3d\x3d\x3d '[object Array]' ||\n          (elementsType \x3d\x3d\x3d '[object NodeList]') ||\n          (elementsType \x3d\x3d\x3d '[object HTMLCollection]') ||\n          (typeof jQuery !\x3d\x3d 'undefined' \x26\x26 elements instanceof jQuery) || // jquery\n          (typeof Elements !\x3d\x3d 'undefined' \x26\x26 elements instanceof Elements) // mootools\n      );\n  let i \x3d 0;\n  const j \x3d elements.length;\n  if (isCollectionTyped) {\n    for (; i \x3c j; i +\x3d 1) {\n      callback(elements[i]);\n    }\n  } else {\n    callback(elements);\n  }\n}\n  /**\n   * Class for dimension change detection.\n   *\n   * @param {Element|Element[]|Elements|jQuery} element\n   * @param {Function} callback\n   *\n   * @constructor\n   */\nL.ResizeSensor \x3d function ResizeSensor(element, callback \x3d () \x3d\x3e {}) {\n      /**\n       *\n       * @constructor\n       */\n  function EventQueue() {\n    let q \x3d [];\n    this.add \x3d (ev) \x3d\x3e {\n      q.push(ev);\n    };\n\n    let i;\n    let j;\n    this.call \x3d () \x3d\x3e {\n      for (i \x3d 0, j \x3d q.length; i \x3c j; i +\x3d 1) {\n        q[i].call();\n      }\n    };\n\n    this.remove \x3d (ev) \x3d\x3e {\n      const newQueue \x3d [];\n      for (i \x3d 0, j \x3d q.length; i \x3c j; i +\x3d 1) {\n        if (q[i] !\x3d\x3d ev) newQueue.push(q[i]);\n      }\n      q \x3d newQueue;\n    };\n\n    this.length \x3d () \x3d\x3e q.length;\n  }\n\n      /**\n       *\n       * @param {HTMLElement} element\n       * @param {Function}    resized\n       */\n  function attachResizeEvent(htmlElement, resized) {\n    // Only used for the dirty checking, so the event callback count is limted\n    //  to max 1 call per fps per sensor.\n    // In combination with the event based resize sensor this saves cpu time,\n    // because the sensor is too fast and\n    // would generate too many unnecessary events.\n    const customRequestAnimationFrame \x3d window.requestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    function delay(fn) {\n      return window.setTimeout(fn, 20);\n    };\n\n    const newElement \x3d htmlElement;\n    if (!newElement.resizedAttached) {\n      newElement.resizedAttached \x3d new EventQueue();\n      newElement.resizedAttached.add(resized);\n    } else if (newElement.resizedAttached) {\n      newElement.resizedAttached.add(resized);\n      return;\n    }\n\n    newElement.resizeSensor \x3d document.createElement('div');\n    newElement.resizeSensor.className \x3d 'resize-sensor';\n    const style \x3d 'position: absolute; left: 0; top: 0; right: 0; bottom: 0; ' +\n                      'overflow: hidden; z-index: -1; visibility: hidden;';\n    const styleChild \x3d 'position: absolute; left: 0; top: 0; transition: 0s;';\n\n    newElement.resizeSensor.style.cssText \x3d style;\n    newElement.resizeSensor.innerHTML \x3d\n              `\x3cdiv class\x3d\"resize-sensor-expand\" style\x3d\"${style}\"\x3e` +\n                  `\x3cdiv style\x3d\"${styleChild}\"\x3e\x3c/div\x3e` +\n              '\x3c/div\x3e' +\n              `\x3cdiv class\x3d\"resize-sensor-shrink\" style\x3d\"${style}\"\x3e` +\n                  `\x3cdiv style\x3d\"${styleChild} width: 200%; height: 200%\"\x3e\x3c/div\x3e` +\n              '\x3c/div\x3e';\n    newElement.appendChild(newElement.resizeSensor);\n\n    if (L.GetComputedStyle(newElement, 'position') \x3d\x3d\x3d 'static') {\n      newElement.style.position \x3d 'relative';\n    }\n\n    const expand \x3d newElement.resizeSensor.childNodes[0];\n    const expandChild \x3d expand.childNodes[0];\n    const shrink \x3d newElement.resizeSensor.childNodes[1];\n\n    const reset \x3d () \x3d\x3e {\n      expandChild.style.width \x3d `${100000}px`;\n      expandChild.style.height \x3d `${100000}px`;\n\n      expand.scrollLeft \x3d 100000;\n      expand.scrollTop \x3d 100000;\n\n      shrink.scrollLeft \x3d 100000;\n      shrink.scrollTop \x3d 100000;\n    };\n\n    reset();\n    let dirty \x3d false;\n\n    const dirtyChecking \x3d () \x3d\x3e {\n      if (!newElement.resizedAttached) return;\n\n      if (dirty) {\n        newElement.resizedAttached.call();\n        dirty \x3d false;\n      }\n\n      customRequestAnimationFrame(dirtyChecking);\n    };\n\n    customRequestAnimationFrame(dirtyChecking);\n    let lastWidth;\n    let lastHeight;\n    let cachedWidth;\n    let cachedHeight; // useful to not query offsetWidth twice\n\n    const onScroll \x3d () \x3d\x3e {\n      if ((cachedWidth \x3d newElement.offsetWidth) !\x3d\x3d lastWidth ||\n                (cachedHeight \x3d newElement.offsetHeight) !\x3d\x3d lastHeight) {\n        dirty \x3d true;\n\n        lastWidth \x3d cachedWidth;\n        lastHeight \x3d cachedHeight;\n      }\n      reset();\n    };\n\n    const addEvent \x3d (el, name, cb) \x3d\x3e {\n      if (el.attachEvent) {\n        el.attachEvent(`on${name}`, cb);\n      } else {\n        el.addEventListener(name, cb);\n      }\n    };\n\n    addEvent(expand, 'scroll', onScroll);\n    addEvent(shrink, 'scroll', onScroll);\n  }\n\n  forEachElement(element, (elem) \x3d\x3e {\n    attachResizeEvent(elem, callback);\n  });\n\n  this.detach \x3d (ev) \x3d\x3e {\n    L.ResizeSensor.detach(element, ev);\n  };\n};\n\nL.ResizeSensor.detach \x3d (element, ev) \x3d\x3e {\n  forEachElement(element, (elem) \x3d\x3e {\n    const elementItem \x3d elem;\n    if (elementItem.resizedAttached \x26\x26 typeof ev \x3d\x3d\x3d 'function') {\n      elementItem.resizedAttached.remove(ev);\n      if (elementItem.resizedAttached.length()) return;\n    }\n    if (elementItem.resizeSensor) {\n      if (elementItem.contains(elementItem.resizeSensor)) {\n        elementItem.removeChild(elementItem.resizeSensor);\n      }\n      delete elementItem.resizeSensor;\n      delete elementItem.resizedAttached;\n    }\n  });\n};\n";
  }])["default"];
} catch (e) {
  console && console.log && console.log('eval erizo.js error:', e);
}
},{}],"src/libs/AgoraRTCSDK-2.6.1.js":[function(require,module,exports) {
var define;
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! AgoraRTC|BUILD v2.6.1-0-g01b3be9 */
!function (e, t) {
  "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) && "object" == (typeof module === "undefined" ? "undefined" : _typeof(module)) ? module.exports = t() : "function" == typeof define && define.amd ? define("AgoraRTC", [], t) : "object" == (typeof exports === "undefined" ? "undefined" : _typeof(exports)) ? exports.AgoraRTC = t() : e.AgoraRTC = t();
}(window, function () {
  return function (e) {
    var t = {};

    function n(i) {
      if (t[i]) return t[i].exports;
      var o = t[i] = {
        i: i,
        l: !1,
        exports: {}
      };
      return e[i].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
    }

    return n.m = e, n.c = t, n.d = function (e, t, i) {
      n.o(e, t) || Object.defineProperty(e, t, {
        enumerable: !0,
        get: i
      });
    }, n.r = function (e) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(e, "__esModule", {
        value: !0
      });
    }, n.t = function (e, t) {
      if (1 & t && (e = n(e)), 8 & t) return e;
      if (4 & t && "object" == _typeof(e) && e && e.__esModule) return e;
      var i = Object.create(null);
      if (n.r(i), Object.defineProperty(i, "default", {
        enumerable: !0,
        value: e
      }), 2 & t && "string" != typeof e) for (var o in e) {
        n.d(i, o, function (t) {
          return e[t];
        }.bind(null, o));
      }
      return i;
    }, n.n = function (e) {
      var t = e && e.__esModule ? function () {
        return e.default;
      } : function () {
        return e;
      };
      return n.d(t, "a", t), t;
    }, n.o = function (e, t) {
      return Object.prototype.hasOwnProperty.call(e, t);
    }, n.p = "", n(n.s = 17);
  }([function (e, t, n) {
    "use strict";

    n.r(t);
    var i = n(6),
        o = n.n(i),
        a = n(5),
        r = n(3),
        s = n(1),
        d = 0,
        c = "free",
        u = [],
        l = [],
        p = 0;
    setInterval(function () {
      Object(r.getParameter)("UPLOAD_LOG") && f.info("console log upload");
    }, 9e5);

    var f = function () {
      var e,
          t,
          n,
          i,
          f,
          m,
          g = "https://".concat(Object(r.getParameter)("LOG_UPLOAD_SERVER"), "/upload/v1"),
          v = ["DEBUG", "INFO", "WARNING", "ERROR", "NONE"],
          S = 0,
          I = function e(t) {
        c = "uploading", setTimeout(function () {
          !function (e, t, n) {
            var i;
            Array.isArray(e) || (e = [e]), e = e.map(function (e) {
              return {
                log_item_id: d++,
                log_level: e.log_level,
                payload_str: e.payload
              };
            }), i = {
              sdk_version: r.VERSION,
              process_id: Object(s.a)(),
              payload: JSON.stringify(e)
            };

            try {
              Object(a.c)(g, i, function (e) {
                "OK" === e ? t && t(e) : n && n(e);
              }, function (e) {
                n && n(e);
              }, {
                withCredentials: !0
              });
            } catch (e) {
              n && n(e);
            }
          }(t, function () {
            p = 0, 0 !== u.length ? (l = u.length < 10 ? u.splice(0, u.length) : u.splice(0, 10), e(l)) : c = "free";
          }, function () {
            setTimeout(function () {
              e(l);
            }, p++ < 2 ? 200 : 1e4);
          });
        }, 3e3);
      };

      t = function t() {
        for (var t = [0], n = 0; n < arguments.length; n++) {
          t.push(arguments[n]);
        }

        e.apply(this, t);
      }, n = function n() {
        for (var t = [1], n = 0; n < arguments.length; n++) {
          t.push(arguments[n]);
        }

        e.apply(this, t);
      }, i = function i() {
        for (var t = [2], n = 0; n < arguments.length; n++) {
          t.push(arguments[n]);
        }

        e.apply(this, t);
      }, f = function f() {
        for (var t = [3], n = 0; n < arguments.length; n++) {
          t.push(arguments[n]);
        }

        e.apply(this, t);
      };
      var _ = {};
      return m = function m(e) {
        _[e] || (i.apply(void 0, arguments), _[e] = !0);
      }, {
        DEBUG: 0,
        INFO: 1,
        WARNING: 2,
        ERROR: 3,
        NONE: 4,
        enableLogUpload: function enableLogUpload() {
          Object(r.setParameter)("UPLOAD_LOG", !0);
        },
        disableLogUpload: function disableLogUpload() {
          Object(r.setParameter)("UPLOAD_LOG", !1);
        },
        setProxyServer: function setProxyServer(e) {
          g = e ? "https://".concat(e, "/ls/?h=").concat(Object(r.getParameter)("LOG_UPLOAD_SERVER"), "&p=443&d=upload/v1") : "https://".concat(Object(r.getParameter)("LOG_UPLOAD_SERVER"), "/upload/v1");
        },
        setLogLevel: function setLogLevel(e) {
          e > 4 ? e = 4 : e < 0 && (e = 0), S = e;
        },
        log: e = function e() {
          var e,
              t = arguments[0],
              n = arguments;
          if (n[0] = (e = new Date()).toTimeString().split(" ")[0] + ":" + e.getMilliseconds() + " Agora-SDK [" + (v[t] || "DEFAULT") + "]:", function (e, t) {
            if (Object(r.getParameter)("UPLOAD_LOG")) try {
              t = Array.prototype.slice.call(t);
              var n = "";
              t.forEach(function (e) {
                "object" === o()(e) && (e = JSON.stringify(e)), n = n + e + " ";
              }), u.push({
                payload: n,
                log_level: e
              }), "free" === c && (l = u.length < 10 ? u.splice(0, u.length) : u.splice(0, 10), I(l));
            } catch (e) {}
          }(t, n), !(t < S)) switch (t) {
            case 0:
            case 1:
              console.log.apply(console, n);
              break;

            case 2:
              console.warn.apply(console, n);
              break;

            case 3:
              console.error.apply(console, n);
              break;

            default:
              return void console.log.apply(console, n);
          }
        },
        debug: t,
        info: n,
        warning: i,
        deprecate: m,
        error: f
      };
    }();

    t.default = f;
  }, function (e, t, n) {
    "use strict";

    var i = n(9),
        o = n.n(i),
        a = n(4),
        r = n.n(a),
        s = n(3),
        d = n(0),
        c = n(5),
        u = n(11),
        l = n.n(u);
    n.d(t, "b", function () {
      return g;
    }), n.d(t, "a", function () {
      return m;
    });

    var p = {
      eventType: null,
      sid: null,
      lts: null,
      success: null,
      cname: null,
      uid: null,
      peer: null,
      cid: null,
      elapse: null,
      extend: null,
      vid: 0
    },
        f = null,
        m = function m() {
      return f || (f = "process-" + l()(), d.default.info("processId: " + f)), f;
    },
        g = function () {
      var e = {
        list: {}
      };
      e.url = Object(c.e)() ? "https://".concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), ":6443/events/message") : "http://".concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), ":6080/events/message"), e.urlBackup = Object(c.e)() ? "https://".concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), ":6443/events/message") : "http://".concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), ":6080/events/message"), e.setProxyServer = function (t) {
        t ? (e.url = Object(c.e)() ? "https://".concat(t, "/rs/?h=").concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), "&p=6443&d=events/message") : "http://".concat(t, "/rs/?h=").concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), "&p=6080&d=events/message"), e.urlBackup = Object(c.e)() ? "https://".concat(t, "/rs/?h=").concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), "&p=6443&d=events/message") : "http://".concat(t, "/rs/?h=").concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), "&p=6080&d=events/message"), d.default.debug("reportProxyServerURL: ".concat(e.url)), d.default.debug("reportProxyServerBackupURL: ".concat(e.urlBackup))) : (e.url = Object(c.e)() ? "https://".concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), ":6443/events/message") : "http://".concat(Object(s.getParameter)("EVENT_REPORT_DOMAIN"), ":6080/events/message"), e.urlBackup = Object(c.e)() ? "https://".concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), ":6443/events/message") : "http://".concat(Object(s.getParameter)("EVENT_REPORT_BACKUP_DOMAIN"), ":6080/events/message"));
      }, e.sessionInit = function (t, n) {
        var i = r()({}, p);
        i.startTime = +new Date(), i.sid = t, i.cname = n.cname, e.list[t] = i;
        var o = r()({}, {
          willUploadConsoleLog: Object(s.getParameter)("UPLOAD_LOG")
        }, n.extend),
            a = r()({}, i);
        a.eventType = "session_init", a.appid = n.appid, a.browser = navigator.userAgent, a.build = s.BUILD, a.lts = +new Date(), a.elapse = a.lts - a.startTime, a.extend = JSON.stringify(o), a.mode = n.mode, a.process = m(), a.success = n.succ, a.version = s.VERSION, delete a.startTime, e.send({
          type: "io.agora.pb.Wrtc.Session",
          data: a
        }), e._flushInvokeReport(t);
      }, e.joinChooseServer = function (t, n, i) {
        n.uid && (e.list[t].uid = parseInt(n.uid)), n.cid && (e.list[t].cid = parseInt(n.cid));
        var o = r()({}, e.list[t]);
        o.eventType = "join_choose_server";
        var a = n.lts;
        o.lts = Date.now(), o.eventElapse = o.lts - a, o.chooseServerAddr = n.csAddr, o.errorCode = n.ec, o.elapse = o.lts - o.startTime, o.success = n.succ, o.chooseServerAddrList = JSON.stringify(n.serverList), delete o.startTime, e.send({
          type: "io.agora.pb.Wrtc.JoinChooseServer",
          data: o
        });
      }, e.joinGateway = function (t, n) {
        n.vid && (e.list[t].vid = n.vid);
        var i = r()({}, e.list[t]),
            o = n.lts;
        i.eventType = "join_gateway", i.lts = Date.now(), i.gatewayAddr = n.addr, i.success = n.succ, i.errorCode = n.ec, i.elapse = i.lts - i.startTime, i.eventElapse = i.lts - o, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.JoinGateway",
          data: i
        });
      }, e.publish = function (t, n) {
        var i = r()({}, e.list[t]);
        i.eventType = "publish";
        var o = n.lts;
        i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.success = n.succ, i.errorCode = n.ec, n.videoName && (i.videoName = n.videoName), n.audioName && (i.audioName = n.audioName), n.screenName && (i.screenName = n.screenName), delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.Publish",
          data: i
        }), e._flushInvokeReport(t);
      }, e.subscribe = function (t, n) {
        var i = r()({}, e.list[t]);
        i.eventType = "subscribe";
        var o = n.lts;
        i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.errorCode = n.ec, i.success = n.succ, isFinite(n.peerid) ? i.peer = n.peerid : i.peerSuid = "" + n.peerid, "boolean" == typeof n.video && (i.video = n.video), "boolean" == typeof n.audio && (i.audio = n.audio), delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.Subscribe",
          data: i
        }), e._flushInvokeReport(t);
      }, e.firstRemoteFrame = function (t, n) {
        var i = r()({}, e.list[t]);
        i.eventType = "first_remote_frame";
        var o = n.lts;
        i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.width = n.width, i.height = n.height, i.success = n.succ, i.errorCode = n.ec, isFinite(n.peerid) ? i.peer = n.peerid : i.peerSuid = "" + n.peerid, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.FirstFrame",
          data: i
        });
      }, e.streamSwitch = function (t, n) {
        var i = r()({}, e.list[t]);
        i.eventType = "stream_switch", i.lts = Date.now(), i.isDual = n.isdual, i.elapse = i.lts - i.startTime, i.success = i.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.StreamSwitch",
          data: i
        });
      }, e.audioSendingStopped = function (t, n) {
        var i = r()({}, e.list[t]);
        i.eventType = "audio_sending_stopped", i.lts = Date.now(), i.elapse = i.lts - i.startTime, i.reason = n.reason, i.success = n.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.AudioSendingStopped",
          data: i
        });
      }, e.videoSendingStopped = function (t, n) {
        var i = r()({}, e.list[t]);
        i.eventType = "video_sending_stopped", i.lts = Date.now(), i.elapse = i.lts - i.startTime, i.reson = n.reason, i.success = n.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.VideoSendingStopped",
          data: i
        });
      }, e.requestProxyAppCenter = function (t, n) {
        var i = r()({}, e.list[t]),
            o = n.lts;
        i.eventType = "request_proxy_appcenter", i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.extend = n.extend + "", i.APAddr = n.APAddr, i.workerManagerList = n.workerManagerList, i.response = n.response, i.errorCode = n.ec, i.success = n.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.RequestProxyAppCenter",
          data: i
        });
      }, e.requestProxyWorkerManager = function (t, n) {
        var i = r()({}, e.list[t]),
            o = n.lts;
        i.eventType = "request_proxy_worker_manager", i.lts = Date.now(), i.eventElapse = i.lts - o, i.elapse = i.lts - i.startTime, i.extend = n.extend, i.workerManagerAddr = n.workerManagerAddr, i.response = n.response, i.errorCode = n.ec, i.success = n.succ, delete i.startTime, e.send({
          type: "io.agora.pb.Wrtc.RequestProxyWorkerManager",
          data: i
        });
      };
      var t = 0;
      return e.reportApiInvoke = function (e, n) {
        var i = n.tag,
            a = n.name,
            r = n.getStates,
            s = n.options,
            d = n.timeout,
            c = void 0 === d ? 6e4 : d,
            u = n.callback,
            l = n.reportResult,
            p = void 0 === l || l,
            f = Date.now(),
            m = 0,
            v = t++,
            S = function S() {
          return o()({
            tag: i,
            invokeId: v,
            sid: e,
            name: a,
            apiInvokeTime: f,
            options: s
          }, r && {
            states: (t = r(), Object.keys(t).reduce(function (e, n) {
              var i = e;
              return null != t[n] && (i[n] = t[n]), i;
            }, {}))
          });
          var t;
        },
            I = setTimeout(function () {
          g._sendApiInvoke(o()({}, S(), {
            error: "API_INVOKE_TIMEOUT",
            success: !1
          }));
        }, c);

        return function (e, t) {
          if (clearTimeout(I), ++m > 1 && (e = "EXECUTOR_INVOKE_".concat(m)), e) return g._sendApiInvoke(o()({}, S(), {
            success: !1,
            error: e
          }, r && {
            states: r()
          })), u && u(e);
          g._sendApiInvoke(o()({}, S(), {
            success: !0
          }, p && {
            result: t
          }, r && {
            states: r()
          })), u && u(null, t);
        };
      }, e._cachedItems = [], e._cacheInvokeReport = function (t) {
        t.lts || (t.lts = Date.now()), e._cachedItems.push(t), e._cachedItems.length > 50 && e._cachedItems.shift();
      }, e._flushInvokeReport = function (t) {
        if (e._cachedItems.length) {
          var n = e._cachedItems;
          e._cachedItems = [], d.default.debug("Flush cached event reporting:", n.length), n.forEach(function (n, i) {
            n.sid = t, setTimeout(function () {
              e._sendApiInvoke(n);
            }, 5e3 + 500 * i);
          });
        }
      }, e._sendApiInvoke = function (t) {
        var n = t.tag,
            i = t.invokeId,
            a = t.sid,
            r = t.name,
            d = t.result,
            c = t.states,
            u = t.options,
            l = t.error,
            p = t.success,
            f = t.apiInvokeTime,
            m = t.lts,
            g = Object(s.getParameter)("NOT_REPORT_EVENT");
        if (!(n && g instanceof Array && g.includes(n))) if (e.list[a]) {
          var v = e.list[a],
              S = v.startTime,
              I = v.cname,
              _ = v.uid,
              h = v.cid,
              y = (m = m || Date.now()) - S,
              b = m - f,
              E = o()({
            invokeId: i,
            sid: a,
            cname: I,
            cid: h,
            lts: m,
            uid: _,
            success: p,
            elapse: y,
            apiName: r,
            execElapse: b
          }, void 0 !== u && {
            options: JSON.stringify(u)
          }, void 0 !== c && {
            execStates: JSON.stringify(c)
          }, void 0 !== l && {
            errorCode: JSON.stringify(l)
          }, void 0 !== d && {
            execResult: JSON.stringify(d)
          });
          e.send({
            type: "io.agora.pb.Wrtc.ApiInvoke",
            data: E
          });
        } else e._cacheInvokeReport(arguments[0]);
      }, e.send = function (t) {
        try {
          Object(c.c)(e.url, t, null, function (n) {
            Object(c.c)(e.urlBackup, t, null, function (e) {}, {
              timeout: 1e4
            });
          }, {
            timeout: 1e4
          });
        } catch (e) {}
      }, e;
    }();
  }, function (e, t, n) {
    "use strict";

    n.r(t), n.d(t, "getBrowserInfo", function () {
      return v;
    }), n.d(t, "getBrowserVersion", function () {
      return p;
    }), n.d(t, "getBrowserOS", function () {
      return f;
    }), n.d(t, "isChrome", function () {
      return o;
    }), n.d(t, "isSafari", function () {
      return a;
    }), n.d(t, "isFireFox", function () {
      return r;
    }), n.d(t, "isOpera", function () {
      return s;
    }), n.d(t, "isQQBrowser", function () {
      return d;
    }), n.d(t, "isWeChatBrowser", function () {
      return c;
    }), n.d(t, "isSupportedPC", function () {
      return u;
    }), n.d(t, "isSupportedMobile", function () {
      return l;
    }), n.d(t, "getChromeKernelVersion", function () {
      return g;
    }), n.d(t, "isChromeKernel", function () {
      return m;
    });

    var i,
        o = function o() {
      var e = v();
      return e.name && "Chrome" === e.name;
    },
        a = function a() {
      var e = v();
      return e.name && "Safari" === e.name;
    },
        r = function r() {
      var e = v();
      return e.name && "Firefox" === e.name;
    },
        s = function s() {
      var e = v();
      return e.name && "OPR" === e.name;
    },
        d = function d() {
      var e = v();
      return e.name && "QQBrowser" === e.name;
    },
        c = function c() {
      var e = v();
      return e.name && "MicroMessenger" === e.name;
    },
        u = function u() {
      var e = f();
      return "Linux" === e || "Mac OS X" === e || "Mac OS" === e || -1 !== e.indexOf("Windows");
    },
        l = function l() {
      var e = f();
      return "Android" === e || "iOS" === e;
    },
        p = function p() {
      return v().version;
    },
        f = function f() {
      return v().os;
    },
        m = function m() {
      return !!navigator.userAgent.match(/chrome\/[\d]./i);
    },
        g = function g() {
      var e = navigator.userAgent.match(/chrome\/[\d]./i);
      return e && e[0] && e[0].split("/")[1];
    },
        v = (i = function () {
      var e,
          t = navigator.userAgent,
          n = t.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
      "Chrome" === n[1] && null != (e = t.match(/(OPR(?=\/))\/?(\d+)/i)) && (n = e), "Safari" === n[1] && null != (e = t.match(/version\/(\d+)/i)) && (n[2] = e[1]), ~t.toLowerCase().indexOf("qqbrowser") && null != (e = t.match(/(qqbrowser(?=\/))\/?(\d+)/i)) && (n = e), ~t.toLowerCase().indexOf("micromessenger") && null != (e = t.match(/(micromessenger(?=\/))\/?(\d+)/i)) && (n = e), ~t.toLowerCase().indexOf("edge") && null != (e = t.match(/(edge(?=\/))\/?(\d+)/i)) && (n = e), ~t.toLowerCase().indexOf("trident") && null != (e = /\brv[ :]+(\d+)/g.exec(t) || []) && (n = [null, "IE", e[1]]);
      var i = void 0,
          o = [{
        s: "Windows 10",
        r: /(Windows 10.0|Windows NT 10.0)/
      }, {
        s: "Windows 8.1",
        r: /(Windows 8.1|Windows NT 6.3)/
      }, {
        s: "Windows 8",
        r: /(Windows 8|Windows NT 6.2)/
      }, {
        s: "Windows 7",
        r: /(Windows 7|Windows NT 6.1)/
      }, {
        s: "Windows Vista",
        r: /Windows NT 6.0/
      }, {
        s: "Windows Server 2003",
        r: /Windows NT 5.2/
      }, {
        s: "Windows XP",
        r: /(Windows NT 5.1|Windows XP)/
      }, {
        s: "Windows 2000",
        r: /(Windows NT 5.0|Windows 2000)/
      }, {
        s: "Windows ME",
        r: /(Win 9x 4.90|Windows ME)/
      }, {
        s: "Windows 98",
        r: /(Windows 98|Win98)/
      }, {
        s: "Windows 95",
        r: /(Windows 95|Win95|Windows_95)/
      }, {
        s: "Windows NT 4.0",
        r: /(Windows NT 4.0|WinNT4.0|WinNT|Windows NT)/
      }, {
        s: "Windows CE",
        r: /Windows CE/
      }, {
        s: "Windows 3.11",
        r: /Win16/
      }, {
        s: "Android",
        r: /Android/
      }, {
        s: "Open BSD",
        r: /OpenBSD/
      }, {
        s: "Sun OS",
        r: /SunOS/
      }, {
        s: "Linux",
        r: /(Linux|X11)/
      }, {
        s: "iOS",
        r: /(iPhone|iPad|iPod)/
      }, {
        s: "Mac OS X",
        r: /Mac OS X/
      }, {
        s: "Mac OS",
        r: /(MacPPC|MacIntel|Mac_PowerPC|Macintosh)/
      }, {
        s: "QNX",
        r: /QNX/
      }, {
        s: "UNIX",
        r: /UNIX/
      }, {
        s: "BeOS",
        r: /BeOS/
      }, {
        s: "OS/2",
        r: /OS\/2/
      }, {
        s: "Search Bot",
        r: /(nuhk|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask Jeeves\/Teoma|ia_archiver)/
      }];

      for (var a in o) {
        var r = o[a];

        if (r.r.test(navigator.userAgent)) {
          i = r.s;
          break;
        }
      }

      return {
        name: n[1],
        version: n[2],
        os: i
      };
    }(), function () {
      return i;
    });
  }, function (e, t, n) {
    "use strict";

    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    t.BUILD = "v2.6.1-0-g01b3be9";
    t.VERSION = "2.6.1";
    t.SUPPORT_RESOLUTION_LIST = {
      "90p_1": [160, 90],
      "120p_1": [160, 120],
      "120p_3": [120, 120],
      "120p_4": [212, 120],
      "180p_1": [320, 180],
      "180p_3": [180, 180],
      "180p_4": [240, 180],
      "240p_1": [320, 240],
      "240p_3": [240, 240],
      "240p_4": [424, 240],
      "360p_1": [640, 360],
      "360p_3": [360, 360],
      "360p_4": [640, 360],
      "360p_6": [360, 360],
      "360p_7": [480, 360],
      "360p_8": [480, 360],
      "360p_9": [640, 360],
      "360p_10": [640, 360],
      "360p_11": [640, 360],
      "480p_1": [640, 480],
      "480p_2": [640, 480],
      "480p_3": [480, 480],
      "480p_4": [640, 480],
      "480p_6": [480, 480],
      "480p_8": [848, 480],
      "480p_9": [848, 480],
      "480p_10": [640, 480],
      "720p_1": [1280, 720],
      "720p_2": [1280, 720],
      "720p_3": [1280, 720],
      "720p_5": [960, 720],
      "720p_6": [960, 720],
      "1080p_1": [1920, 1080],
      "1080p_2": [1920, 1080],
      "1080p_3": [1920, 1080],
      "1080p_5": [1920, 1080],
      "1440p_1": [2560, 1440],
      "1440p_2": [2560, 1440],
      "4k_1": [3840, 2160],
      "4k_3": [3840, 2160]
    };
    var i = {
      WEBCS_DOMAIN: ["ap-web-1.agora.io", "ap-web-2.agoraio.cn"],
      WEBCS_DOMAIN_BACKUP_LIST: ["ap-web-3.agora.io", "ap-web-4.agoraio.cn"],
      PROXY_CS: ["ap-proxy-1.agora.io", "ap-proxy-2.agora.io"],
      LOG_UPLOAD_SERVER: "logservice.agora.io",
      EVENT_REPORT_DOMAIN: "webcollector-1.agora.io",
      EVENT_REPORT_BACKUP_DOMAIN: "webcollector-2.agoraio.cn",
      WEBCS_BACKUP_CONNECT_TIMEOUT: 6e3,
      HTTP_CONNECT_TIMEOUT: 5e3,
      UPLOAD_LOG: !1,
      NOT_REPORT_EVENT: [],
      FILEPATH_LENMAX: 255
    };

    t.setParameter = function (e, t) {
      return void 0 !== i[e] && (i[e] = t, !0);
    };

    t.getParameter = function (e) {
      return void 0 !== i[e] ? i[e] : null;
    };
  }, function (e, t) {
    function n() {
      return e.exports = n = Object.assign || function (e) {
        for (var t = 1; t < arguments.length; t++) {
          var n = arguments[t];

          for (var i in n) {
            Object.prototype.hasOwnProperty.call(n, i) && (e[i] = n[i]);
          }
        }

        return e;
      }, n.apply(this, arguments);
    }

    e.exports = n;
  }, function (e, t, n) {
    "use strict";

    n.d(t, "c", function () {
      return u;
    }), n.d(t, "e", function () {
      return l;
    }), n.d(t, "b", function () {
      return s;
    }), n.d(t, "a", function () {
      return d;
    }), n.d(t, "d", function () {
      return c;
    });

    var i = n(3),
        o = n(7),
        a = 0,
        r = 0,
        s = function s() {
      return a;
    },
        d = function d() {
      return r;
    },
        c = function c() {
      a = 0, r = 0;
    },
        u = function u(e, t, n, s, d) {
      var c = new XMLHttpRequest();
      if (c.timeout = t.timeout || Object(i.getParameter)("HTTP_CONNECT_TIMEOUT"), c.open("POST", e, !0), c.setRequestHeader("Content-type", "application/json; charset=utf-8"), d) for (var u in d) {
        "withCredentials" == u ? c.withCredentials = !0 : c.setRequestHeader(u, d[u]);
      }
      c.onload = function (e) {
        r += Object(o.e)(c.responseText), n && n(c.responseText);
      }, c.onerror = function (t) {
        s && s(t, e);
      }, c.ontimeout = function (t) {
        s && s(t, e);
      };
      var l = JSON.stringify(t);
      a += Object(o.e)(l), c.send(l);
    },
        l = function l() {
      return "https:" == document.location.protocol;
    };
  }, function (e, t) {
    function n(e) {
      return (n = "function" == typeof Symbol && "symbol" == _typeof(Symbol.iterator) ? function (e) {
        return _typeof(e);
      } : function (e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : _typeof(e);
      })(e);
    }

    function i(t) {
      return "function" == typeof Symbol && "symbol" === n(Symbol.iterator) ? e.exports = i = function i(e) {
        return n(e);
      } : e.exports = i = function i(e) {
        return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : n(e);
      }, i(t);
    }

    e.exports = i;
  }, function (e, t, n) {
    "use strict";

    n.d(t, "d", function () {
      return v;
    }), n.d(t, "b", function () {
      return f;
    }), n.d(t, "a", function () {
      return p;
    }), n.d(t, "h", function () {
      return m;
    }), n.d(t, "c", function () {
      return g;
    }), n.d(t, "g", function () {
      return I;
    }), n.d(t, "f", function () {
      return h;
    }), n.d(t, "e", function () {
      return _;
    });

    var i = n(6),
        o = n.n(i),
        a = n(2),
        r = n(0),
        s = n(11),
        d = n.n(s),
        c = n(10),
        u = n(8),
        l = null,
        p = function p(e) {
      return this.audioContext = (l || (l = Object(c.a)()), l), this.sourceNode = e.otWebkitAudioSource || this.audioContext.createMediaStreamSource(e), this.analyser = this.audioContext.createAnalyser(), this.timeDomainData = new Uint8Array(this.analyser.frequencyBinCount), this.sourceNode.connect(this.analyser), this.getAudioLevel = function () {
        if (this.analyser) {
          this.analyser.getByteTimeDomainData(this.timeDomainData);

          for (var e = 0, t = 0; t < this.timeDomainData.length; t++) {
            e = Math.max(e, Math.abs(this.timeDomainData[t] - 128));
          }

          return e / 128;
        }

        return r.default.warning("can't find analyser in audioLevelHelper"), 0;
      }, this;
    };

    function f() {
      return d()().replace(/-/g, "").toUpperCase();
    }

    var m = function m(e, t, n) {
      try {
        var i = document.createElement("video");
        i.setAttribute("autoplay", ""), i.setAttribute("muted", ""), i.setAttribute("playsinline", ""), i.setAttribute("style", "position: absolute; top: 0; left: 0; width:1px; high:1px;"), document.body.appendChild(i), i.addEventListener("playing", function (e) {
          a.isFireFox() ? i.videoWidth && (t(i.videoWidth, i.videoHeight), document.body.removeChild(i)) : (t(i.videoWidth, i.videoHeight), document.body.removeChild(i));
        }), Object(u.c)(i, e);
      } catch (e) {
        n(e);
      }
    },
        g = function g(e) {
      return "number" == typeof e && 0 <= e && e <= 4294967295;
    },
        v = function v(e) {
      var t = ["lowLatency", "userConfigExtraInfo", "transcodingUsers"];

      for (var n in e) {
        if ("lowLatency" === n && "boolean" != typeof e[n] || "userConfigExtraInfo" === n && "object" !== o()(e[n]) || "transcodingUsers" === n && !S(e[n]) || !~t.indexOf(n) && "number" != typeof e[n]) throw new Error("Param [" + n + "] is inValid");
      }

      return !0;
    },
        S = function S(e) {
      for (var t = 0; t < e.length; t++) {
        for (var n in e[t]) {
          if ("number" != typeof e[t][n]) throw new Error("Param user[" + t + "] - [" + n + "] is inValid");
        }
      }

      return !0;
    },
        I = function I(e) {
      isNaN(e) && (e = 1e3);
      var t = +new Date(),
          n = (t = (9301 * t + 49297) % 233280) / 233280;
      return Math.ceil(n * e);
    },
        _ = function _(e) {
      var t = encodeURIComponent(e).match(/%[89ABab]/g);
      return e.length + (t ? t.length : 0);
    },
        h = function h() {
      if (!document.getElementById("agora-ban-tip")) {
        var e = document.createElement("div");
        e.id = "agora-ban-tip", e.style = "position: absolute; width: 100%; height: 100%; display: flex; justify-content: center; align-items: center; color: #fff;", document.querySelector("body").prepend(e);
        var t = document.createElement("div");
        t.style = "background: #000; width: 346px; height: 116px; z-index: 100000; opacity: 0.6; border-radius: 10px; box-shadow: 0 2px 4px #000;", e.append(t);
        var n = document.createElement("div");
        n.style = "height: 76px; display: flex; justify-content: center; align-items: center;";
        var i = document.createElement("span");
        i.style = "height: 28px; width: 28px; color: #000; text-align: center; line-height: 30px; background: #fff; border-radius: 50%; font-weight: 600; font-size: 20px;margin-right: 5px;", i.innerText = "!";
        var o = document.createElement("span");
        o.innerText = "This browser does not support webRTC", n.append(i), n.append(o);
        var a = document.createElement("div");
        a.style = "height: 38px; display: flex; border-top: #fff 1px solid; justify-content: center; align-items: center;", a.innerText = "OK", t.append(n), t.append(a), a.onclick = function () {
          var e = document.getElementById("agora-ban-tip");
          e.parentNode.removeChild(e);
        };
      }
    };
  }, function (e, t, n) {
    "use strict";

    n.d(t, "a", function () {
      return _;
    }), n.d(t, "b", function () {
      return r;
    }), n.d(t, "c", function () {
      return c;
    });
    var i = n(6),
        o = n.n(i),
        a = null,
        r = null,
        s = null,
        d = null,
        c = null,
        u = null,
        l = null,
        p = {
      addStream: null
    },
        f = {
      log: function log() {},
      extractVersion: function extractVersion(e, t, n) {
        var i = e.match(t);
        return i && i.length >= n && parseInt(i[n]);
      }
    };
    if ("object" == ("undefined" == typeof window ? "undefined" : o()(window)) ? (!window.HTMLMediaElement || "srcObject" in window.HTMLMediaElement.prototype ? (c = function c(e, t) {
      e.srcObject = t;
    }, u = function u(e) {
      return e.srcObject;
    }) : (c = function c(e, t) {
      "mozSrcObject" in e ? e.mozSrcObject = t : (e._srcObject = t, e.src = t ? URL.createObjectURL(t) : null);
    }, u = function u(e) {
      return "mozSrcObject" in e ? e.mozSrcObject : e._srcObject;
    }), a = window.navigator && window.navigator.getUserMedia) : (c = function c(e, t) {
      e.srcObject = t;
    }, u = function u(e) {
      return e.srcObject;
    }), r = function r(e, t) {
      c(e, t);
    }, function (e, t) {
      c(e, u(t));
    }, "undefined" != typeof window && window.navigator) {
      if (navigator.mozGetUserMedia && window.mozRTCPeerConnection) {
        for (var m in f.log("This appears to be Firefox"), "firefox", s = f.extractVersion(navigator.userAgent, /Firefox\/([0-9]+)\./, 1), 31, l = mozRTCPeerConnection, p) {
          p[m] = l.prototype[m];
        }

        if (d = function d(e, t) {
          if (s < 38 && e && e.iceServers) {
            for (var n = [], i = 0; i < e.iceServers.length; i++) {
              var o = e.iceServers[i];
              if (o.hasOwnProperty("urls")) for (var a = 0; a < o.urls.length; a++) {
                var r = {
                  url: o.urls[a]
                };
                0 === o.urls[a].indexOf("turn") && (r.username = o.username, r.credential = o.credential), n.push(r);
              } else n.push(e.iceServers[i]);
            }

            e.iceServers = n;
          }

          var d = new l(e, t);

          for (var c in p) {
            d[c] = p[c];
          }

          return d;
        }, window.RTCSessionDescription || (window.RTCSessionDescription = mozRTCSessionDescription), window.RTCIceCandidate || (window.RTCIceCandidate = mozRTCIceCandidate), a = function a(e, t, n) {
          var i = function i(e) {
            if ("object" !== o()(e) || e.require) return e;
            var t = [];
            return Object.keys(e).forEach(function (n) {
              if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
                var i = e[n] = "object" === o()(e[n]) ? e[n] : {
                  ideal: e[n]
                };

                if (void 0 === i.min && void 0 === i.max && void 0 === i.exact || t.push(n), void 0 !== i.exact && ("number" == typeof i.exact ? i.min = i.max = i.exact : e[n] = i.exact, delete i.exact), void 0 !== i.ideal) {
                  e.advanced = e.advanced || [];
                  var a = {};
                  "number" == typeof i.ideal ? a[n] = {
                    min: i.ideal,
                    max: i.ideal
                  } : a[n] = i.ideal, e.advanced.push(a), delete i.ideal, Object.keys(i).length || delete e[n];
                }
              }
            }), t.length && (e.require = t), e;
          };

          return s < 38 && (f.log("spec: " + JSON.stringify(e)), e.audio && (e.audio = i(e.audio)), e.video && (e.video = i(e.video)), f.log("ff37: " + JSON.stringify(e))), navigator.mozGetUserMedia(e, t, n);
        }, navigator.getUserMedia = a, navigator.mediaDevices || (navigator.mediaDevices = {
          getUserMedia: I,
          addEventListener: function addEventListener() {},
          removeEventListener: function removeEventListener() {}
        }), navigator.mediaDevices.enumerateDevices = navigator.mediaDevices.enumerateDevices || function () {
          return new Promise(function (e) {
            e([{
              kind: "audioinput",
              deviceId: "default",
              label: "",
              groupId: ""
            }, {
              kind: "videoinput",
              deviceId: "default",
              label: "",
              groupId: ""
            }]);
          });
        }, s < 41) {
          var g = navigator.mediaDevices.enumerateDevices.bind(navigator.mediaDevices);

          navigator.mediaDevices.enumerateDevices = function () {
            return g().then(void 0, function (e) {
              if ("NotFoundError" === e.name) return [];
              throw e;
            });
          };
        }
      } else if (navigator.webkitGetUserMedia && window.webkitRTCPeerConnection) {
        for (var m in f.log("This appears to be Chrome"), "chrome", s = f.extractVersion(navigator.userAgent, /Chrom(e|ium)\/([0-9]+)\./, 2), 38, l = webkitRTCPeerConnection, p) {
          p[m] = l.prototype[m];
        }

        d = function d(e, t) {
          e && e.iceTransportPolicy && (e.iceTransports = e.iceTransportPolicy);
          var n = new l(e, t);

          for (var i in p) {
            n[i] = p[i];
          }

          var o = n.getStats.bind(n);
          return n.getStats = function (e, t, n) {
            var i = this,
                a = arguments;
            if (arguments.length > 0 && "function" == typeof e) return o(e, t);

            var r = function r(e) {
              var t = {};
              return e.result().forEach(function (e) {
                var n = {
                  id: e.id,
                  timestamp: e.timestamp,
                  type: e.type
                };
                e.names().forEach(function (t) {
                  n[t] = e.stat(t);
                }), t[n.id] = n;
              }), t;
            };

            if (arguments.length >= 2) {
              return o.apply(this, [function (e) {
                a[1](r(e));
              }, arguments[0]]);
            }

            return new Promise(function (t, n) {
              1 === a.length && null === e ? o.apply(i, [function (e) {
                t.apply(null, [r(e)]);
              }, n]) : o.apply(i, [t, n]);
            });
          }, n;
        }, ["createOffer", "createAnswer"].forEach(function (e) {
          var t = webkitRTCPeerConnection.prototype[e];

          webkitRTCPeerConnection.prototype[e] = function () {
            var e = this;

            if (arguments.length < 1 || 1 === arguments.length && "object" === o()(arguments[0])) {
              var n = 1 === arguments.length ? arguments[0] : void 0;
              return new Promise(function (i, o) {
                t.apply(e, [i, o, n]);
              });
            }

            return t.apply(this, arguments);
          };
        }), ["setLocalDescription", "setRemoteDescription", "addIceCandidate"].forEach(function (e) {
          var t = webkitRTCPeerConnection.prototype[e];

          webkitRTCPeerConnection.prototype[e] = function () {
            var e = arguments,
                n = this;
            return new Promise(function (i, o) {
              t.apply(n, [e[0], function () {
                i(), e.length >= 2 && e[1].apply(null, []);
              }, function (t) {
                o(t), e.length >= 3 && e[2].apply(null, [t]);
              }]);
            });
          };
        });

        var v = function v(e) {
          if ("object" !== o()(e) || e.mandatory || e.optional) return e;
          var t = {};
          return Object.keys(e).forEach(function (n) {
            if ("require" !== n && "advanced" !== n && "mediaSource" !== n) {
              var i = "object" === o()(e[n]) ? e[n] : {
                ideal: e[n]
              };
              void 0 !== i.exact && "number" == typeof i.exact && (i.min = i.max = i.exact);

              var a = function a(e, t) {
                return e ? e + t.charAt(0).toUpperCase() + t.slice(1) : "deviceId" === t ? "sourceId" : t;
              };

              if (void 0 !== i.ideal) {
                t.optional = t.optional || [];
                var r = {};
                "number" == typeof i.ideal ? (r[a("min", n)] = i.ideal, t.optional.push(r), (r = {})[a("max", n)] = i.ideal, t.optional.push(r)) : (r[a("", n)] = i.ideal, t.optional.push(r));
              }

              void 0 !== i.exact && "number" != typeof i.exact ? (t.mandatory = t.mandatory || {}, t.mandatory[a("", n)] = i.exact) : ["min", "max"].forEach(function (e) {
                void 0 !== i[e] && (t.mandatory = t.mandatory || {}, t.mandatory[a(e, n)] = i[e]);
              });
            }
          }), e.advanced && (t.optional = (t.optional || []).concat(e.advanced)), t;
        };

        if (a = function a(e, t, n) {
          return e.audio && (e.audio = v(e.audio)), e.video && (e.video = v(e.video)), f.log("chrome: " + JSON.stringify(e)), navigator.webkitGetUserMedia(e, t, n);
        }, navigator.getUserMedia = a, navigator.mediaDevices || (navigator.mediaDevices = {
          getUserMedia: I,
          enumerateDevices: function enumerateDevices() {
            return new Promise(function (e) {
              var t = {
                audio: "audioinput",
                video: "videoinput"
              };
              return MediaStreamTrack.getSources(function (n) {
                e(n.map(function (e) {
                  return {
                    label: e.label,
                    kind: t[e.kind],
                    deviceId: e.id,
                    groupId: ""
                  };
                }));
              });
            });
          }
        }), navigator.mediaDevices.getUserMedia) {
          var S = navigator.mediaDevices.getUserMedia.bind(navigator.mediaDevices);

          navigator.mediaDevices.getUserMedia = function (e) {
            return f.log("spec:   " + JSON.stringify(e)), e.audio = v(e.audio), e.video = v(e.video), f.log("chrome: " + JSON.stringify(e)), S(e);
          };
        } else navigator.mediaDevices.getUserMedia = function (e) {
          return I(e);
        };

        void 0 === navigator.mediaDevices.addEventListener && (navigator.mediaDevices.addEventListener = function () {
          f.log("Dummy mediaDevices.addEventListener called.");
        }), void 0 === navigator.mediaDevices.removeEventListener && (navigator.mediaDevices.removeEventListener = function () {
          f.log("Dummy mediaDevices.removeEventListener called.");
        }), r = function r(e, t) {
          s >= 43 ? c(e, t) : void 0 !== e.src ? e.src = t ? URL.createObjectURL(t) : null : f.log("Error attaching stream to element.");
        }, function (e, t) {
          s >= 43 ? c(e, u(t)) : e.src = t.src;
        };
      } else navigator.mediaDevices && navigator.userAgent.match(/Edge\/(\d+).(\d+)$/) ? (f.log("This appears to be Edge"), "edge", s = f.extractVersion(navigator.userAgent, /Edge\/(\d+).(\d+)$/, 2), 12) : f.log("Browser does not appear to be WebRTC-capable");
    } else f.log("This does not appear to be a browser"), "not a browser";

    function I(e) {
      return new Promise(function (t, n) {
        a(e, t, n);
      });
    }

    var _;

    try {
      Object.defineProperty({}, "version", {
        set: function set(e) {
          s = e;
        }
      });
    } catch (e) {}

    d ? _ = d : "undefined" != typeof window && (_ = window.RTCPeerConnection);
  }, function (e, t, n) {
    var i = n(15);

    e.exports = function (e) {
      for (var t = 1; t < arguments.length; t++) {
        var n = null != arguments[t] ? arguments[t] : {},
            o = Object.keys(n);
        "function" == typeof Object.getOwnPropertySymbols && (o = o.concat(Object.getOwnPropertySymbols(n).filter(function (e) {
          return Object.getOwnPropertyDescriptor(n, e).enumerable;
        }))), o.forEach(function (t) {
          i(e, t, n[t]);
        });
      }

      return e;
    };
  }, function (e, t, n) {
    "use strict";

    n.d(t, "a", function () {
      return o;
    });

    var i = window.AudioContext || window.webkitAudioContext,
        o = function o() {
      if (i) return new i();
      throw new Error("AUDIO_CONTEXT_NOT_SUPPORTED");
    };
  }, function (e, t, n) {
    var i = n(13),
        o = n(14);

    e.exports = function (e, t, n) {
      var a = t && n || 0;
      "string" == typeof e && (t = "binary" === e ? new Array(16) : null, e = null);
      var r = (e = e || {}).random || (e.rng || i)();
      if (r[6] = 15 & r[6] | 64, r[8] = 63 & r[8] | 128, t) for (var s = 0; s < 16; ++s) {
        t[a + s] = r[s];
      }
      return t || o(r);
    };
  }, function (e, t, n) {
    "use strict";

    var _this = this;

    var i = this && this.__awaiter || function (e, t, n, i) {
      return new (n || (n = Promise))(function (o, a) {
        function r(e) {
          try {
            d(i.next(e));
          } catch (e) {
            a(e);
          }
        }

        function s(e) {
          try {
            d(i.throw(e));
          } catch (e) {
            a(e);
          }
        }

        function d(e) {
          e.done ? o(e.value) : new n(function (t) {
            t(e.value);
          }).then(r, s);
        }

        d((i = i.apply(e, t || [])).next());
      });
    };

    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var o = n(16),
        a = n(2),
        r = n(0);

    t.getSupportedCodec = function (e) {
      return i(_this, void 0, void 0,
      /*#__PURE__*/
      regeneratorRuntime.mark(function _callee() {
        var t, _e2, _n, _t, _i, _e3, _t2, _i2;

        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                t = {
                  video: [],
                  audio: []
                };

                if (!("undefined" == typeof window)) {
                  _context.next = 4;
                  break;
                }

                _e2 = "NOT_BROWSER_ENV";
                return _context.abrupt("return", (r.default.error("getSupportedCodec: ".concat(_e2)), Promise.reject(_e2)));

              case 4:
                _context.prev = 4;
                _n = o.createRTCPeerConnection({
                  iceServers: []
                });
                _context.next = 11;
                break;

              case 8:
                _context.prev = 8;
                _context.t0 = _context["catch"](4);
                return _context.abrupt("return", (r.default.error("Failed to init RTCPeerConnection", _context.t0), Promise.reject(_context.t0)));

              case 11:
                if (!_n) {
                  _context.next = 42;
                  break;
                }

                if (!(e && e.stream)) {
                  _context.next = 27;
                  break;
                }

                e.stream.getTracks && _n.addTrack ? e.stream.getTracks().forEach(function (t) {
                  _n.addTrack(t, e.stream);
                }) : _n.addStream(e.stream);

                if (!(a.isSafari() || a.isFireFox())) {
                  _context.next = 20;
                  break;
                }

                _context.next = 17;
                return _n.createOffer();

              case 17:
                _context.t1 = _context.sent;
                _context.next = 23;
                break;

              case 20:
                _context.next = 22;
                return new Promise(function (e, t) {
                  _n.createOffer(e, t);
                });

              case 22:
                _context.t1 = _context.sent;

              case 23:
                _t = _context.t1;

                _n.close();

                _i = _t.sdp;
                return _context.abrupt("return", s(_i));

              case 27:
                _e3 = {
                  mandatory: {
                    OfferToReceiveAudio: !0,
                    OfferToReceiveVideo: !0
                  }
                };

                if (!((a.isSafari() || a.isFireFox() || a.isWeChatBrowser()) && _n.addTransceiver)) {
                  _context.next = 36;
                  break;
                }

                _n.addTransceiver("audio");

                _n.addTransceiver("video");

                _context.next = 33;
                return _n.createOffer();

              case 33:
                _t2 = _context.sent;
                _context.next = 39;
                break;

              case 36:
                _context.next = 38;
                return new Promise(function (t, i) {
                  var o = setTimeout(function () {
                    i("CREATEOFFER_TIMEOUT");
                  }, 3e3);

                  _n.createOffer(function (e) {
                    clearTimeout(o), t(e);
                  }, function (e) {
                    clearTimeout(o), i(e);
                  }, _e3);
                });

              case 38:
                _t2 = _context.sent;

              case 39:
                _n.close();

                _i2 = _t2.sdp;
                return _context.abrupt("return", s(_i2));

              case 42:
                return _context.abrupt("return", (r.default.warning("getSupportedCodec: no RTCPeerConnection constructor is detected"), Promise.resolve(t)));

              case 43:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[4, 8]]);
      }));
    };

    var s = function s(e) {
      var t = {
        video: [],
        audio: []
      };
      return e.match(/ VP8/i) && t.video.push("VP8"), e.match(/ H264/i) && t.video.push("H264"), e.match(/ opus/i) && t.audio.push("OPUS"), Promise.resolve(t);
    };
  }, function (e, t) {
    var n = "undefined" != typeof crypto && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || "undefined" != typeof msCrypto && "function" == typeof window.msCrypto.getRandomValues && msCrypto.getRandomValues.bind(msCrypto);

    if (n) {
      var i = new Uint8Array(16);

      e.exports = function () {
        return n(i), i;
      };
    } else {
      var o = new Array(16);

      e.exports = function () {
        for (var e, t = 0; t < 16; t++) {
          0 == (3 & t) && (e = 4294967296 * Math.random()), o[t] = e >>> ((3 & t) << 3) & 255;
        }

        return o;
      };
    }
  }, function (e, t) {
    for (var n = [], i = 0; i < 256; ++i) {
      n[i] = (i + 256).toString(16).substr(1);
    }

    e.exports = function (e, t) {
      var i = t || 0,
          o = n;
      return [o[e[i++]], o[e[i++]], o[e[i++]], o[e[i++]], "-", o[e[i++]], o[e[i++]], "-", o[e[i++]], o[e[i++]], "-", o[e[i++]], o[e[i++]], "-", o[e[i++]], o[e[i++]], o[e[i++]], o[e[i++]], o[e[i++]], o[e[i++]]].join("");
    };
  }, function (e, t) {
    e.exports = function (e, t, n) {
      return t in e ? Object.defineProperty(e, t, {
        value: n,
        enumerable: !0,
        configurable: !0,
        writable: !0
      }) : e[t] = n, e;
    };
  }, function (e, t, n) {
    "use strict";

    Object.defineProperty(t, "__esModule", {
      value: !0
    });
    var i = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.RTCPeerConnection,
        o = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.webkitRTCPeerConnection,
        a = "object" == (typeof window === "undefined" ? "undefined" : _typeof(window)) && window.mozRTCPeerConnection;

    t.createRTCPeerConnection = function (e) {
      var t = i || o || a;
      return t ? new t(e) : null;
    };
  }, function (e, t, n) {
    "use strict";

    n.r(t);

    var i = n(3),
        o = n(0),
        a = n(1),
        r = function r() {
      var e = {
        dispatcher: {}
      };
      return e.dispatcher.eventListeners = {}, e.addEventListener = function (t, n) {
        void 0 === e.dispatcher.eventListeners[t] && (e.dispatcher.eventListeners[t] = []), e.dispatcher.eventListeners[t].push(n);
      }, e.hasListeners = function (t) {
        return !(!e.dispatcher.eventListeners[t] || !e.dispatcher.eventListeners[t].length);
      }, e.on = e.addEventListener, e.removeEventListener = function (t, n) {
        var i;
        -1 !== (i = e.dispatcher.eventListeners[t].indexOf(n)) && e.dispatcher.eventListeners[t].splice(i, 1);
      }, e.dispatchEvent = function (t) {
        var n;

        for (n in e.dispatcher.eventListeners[t.type]) {
          e.dispatcher.eventListeners[t.type] && e.dispatcher.eventListeners[t.type].hasOwnProperty(n) && "function" == typeof e.dispatcher.eventListeners[t.type][n] && e.dispatcher.eventListeners[t.type][n](t);
        }
      }, e.dispatchSocketEvent = function (t) {
        var n;

        for (n in e.dispatcher.eventListeners[t.type]) {
          e.dispatcher.eventListeners[t.type] && e.dispatcher.eventListeners[t.type].hasOwnProperty(n) && "function" == typeof e.dispatcher.eventListeners[t.type][n] && e.dispatcher.eventListeners[t.type][n](t.msg);
        }
      }, e;
    },
        s = function s(e) {
      var t = {};
      return t.type = e.type, t;
    },
        d = function d(e) {
      var t = s(e);
      return t.stream = e.stream, t.reason = e.reason, t.msg = e.msg, t;
    },
        c = function c(e) {
      var t = s(e);
      return t.uid = e.uid, t.attr = e.attr, t.stream = e.stream, t;
    },
        u = function u(e) {
      var t = s(e);
      return t.msg = e.msg, t;
    },
        l = function l(e) {
      var t = s(e);
      return t.url = e.url, t.uid = e.uid, t.status = e.status, t.reason = e.reason, t;
    },
        p = n(2),
        f = function f() {};

    f.prototype.set = function (e, t) {
      ["BatteryLevel"].indexOf(e) > -1 && (this[e] = t);
    };

    var m = new function () {
      var e = r();
      return e.states = {
        UNINIT: "UNINIT",
        INITING: "INITING",
        INITED: "INITED"
      }, e.state = e.states.UNINIT, e.batteryManager = null, e._init = function (t, n) {
        e.state = e.states.INITING, navigator.getBattery ? navigator.getBattery().then(function (n) {
          e.batteryManager = n, t && setTimeout(function () {
            t();
          }, 0);
        }).catch(function (e) {
          o.default.debug("navigator.getBattery is disabled", e), t && t();
        }) : (e.state = e.states.INITED, t && t());
      }, e._getBatteryStats = function () {
        var t = {};
        return e.batteryManager && e.batteryManager.level ? t.BatteryLevel = Math.floor(100 * e.batteryManager.level) : t.BatteryLevel = "UNSUPPORTED", t;
      }, e.getStats = function (t, n) {
        var i = new f(),
            o = e._getBatteryStats();

        o && o.BatteryLevel && i.set("BatteryLevel", o.BatteryLevel), t && t(i);
      }, e._init(), e;
    }(),
        g = n(6),
        v = n.n(g),
        S = n(4),
        I = n.n(S),
        _ = function _(e) {
      var t = r();
      return t.url = ".", t;
    },
        h = n(8),
        y = {
      101100: "NO_FLAG_SET",
      101101: "FLAG_SET_BUT_EMPTY",
      101102: "INVALID_FALG_SET",
      101203: "NO_SERVICE_AVIABLE",
      0: "OK_CODE",
      5: "INVALID_VENDOR_KEY",
      7: "INVALID_CHANNEL_NAME",
      8: "INTERNAL_ERROR",
      9: "NO_AUTHORIZED",
      10: "DYNAMIC_KEY_TIMEOUT",
      11: "NO_ACTIVE_STATUS",
      13: "DYNAMIC_KEY_EXPIRED",
      14: "STATIC_USE_DYANMIC_KEY",
      15: "DYNAMIC_USE_STATIC_KEY"
    },
        b = {
      2000: "ERR_NO_VOCS_AVAILABLE",
      2001: "ERR_NO_VOS_AVAILABLE",
      2002: "ERR_JOIN_CHANNEL_TIMEOUT",
      2003: "WARN_REPEAT_JOIN",
      2004: "ERR_JOIN_BY_MULTI_IP",
      101: "ERR_INVALID_VENDOR_KEY",
      102: "ERR_INVALID_CHANNEL_NAME",
      103: "WARN_NO_AVAILABLE_CHANNEL",
      104: "WARN_LOOKUP_CHANNEL_TIMEOUT",
      105: "WARN_LOOKUP_CHANNEL_REJECTED",
      106: "WARN_OPEN_CHANNEL_TIMEOUT",
      107: "WARN_OPEN_CHANNEL_REJECTED",
      108: "WARN_REQUEST_DEFERRED",
      109: "ERR_DYNAMIC_KEY_TIMEOUT",
      110: "ERR_NO_AUTHORIZED",
      111: "ERR_VOM_SERVICE_UNAVAILABLE",
      112: "ERR_NO_CHANNEL_AVAILABLE_CODE",
      113: "ERR_TOO_MANY_USERS",
      114: "ERR_MASTER_VOCS_UNAVAILABLE",
      115: "ERR_INTERNAL_ERROR",
      116: "ERR_NO_ACTIVE_STATUS",
      117: "ERR_INVALID_UID",
      118: "ERR_DYNAMIC_KEY_EXPIRED",
      119: "ERR_STATIC_USE_DYANMIC_KE",
      120: "ERR_DYNAMIC_USE_STATIC_KE",
      2: "K_TIMESTAMP_EXPIRED",
      3: "K_CHANNEL_PERMISSION_INVALID",
      4: "K_CERTIFICATE_INVALID",
      5: "K_CHANNEL_NAME_EMPTY",
      6: "K_CHANNEL_NOT_FOUND",
      7: "K_TICKET_INVALID",
      8: "K_CHANNEL_CONFLICTED",
      9: "K_SERVICE_NOT_READY",
      10: "K_SERVICE_TOO_HEAVY",
      14: "K_UID_BANNED",
      15: "K_IP_BANNED",
      16: "K_CHANNEL_BANNED"
    },
        E = ["NO_SERVICE_AVIABLE"],
        R = {
      19: "ERR_ALREADY_IN_USE",
      10: "ERR_TIMEDOUT",
      3: "ERR_NOT_READY",
      9: "ERR_NO_PERMISSION",
      0: "UNKNOW_ERROR"
    },
        A = {
      FAILED: "FAILED",
      INVALID_KEY: "INVALID_KEY",
      INVALID_CLIENT_MODE: "INVALID_CLIENT_MODE",
      INVALID_CLIENT_CODEC: "INVALID_CLIENT_CODEC",
      CLIENT_MODE_CODEC_MISMATCH: "CLIENT_MODE_CODEC_MISMATCH",
      WEB_API_NOT_SUPPORTED: "WEB_API_NOT_SUPPORTED",
      INVALID_PARAMETER: "INVALID_PARAMETER",
      INVALID_OPERATION: "INVALID_OPERATION",
      INVALID_LOCAL_STREAM: "INVALID_LOCAL_STREAM",
      INVALID_REMOTE_STREAM: "INVALID_REMOTE_STREAM",
      INVALID_DYNAMIC_KEY: "INVALID_DYNAMIC_KEY",
      DYNAMIC_KEY_TIMEOUT: "DYNAMIC_KEY_TIMEOUT",
      NO_VOCS_AVAILABLE: "NO_VOCS_AVAILABLE",
      NO_VOS_AVAILABLE: "ERR_NO_VOS_AVAILABLE",
      JOIN_CHANNEL_TIMEOUT: "ERR_JOIN_CHANNEL_TIMEOUT",
      NO_AVAILABLE_CHANNEL: "NO_AVAILABLE_CHANNEL",
      LOOKUP_CHANNEL_TIMEOUT: "LOOKUP_CHANNEL_TIMEOUT",
      LOOKUP_CHANNEL_REJECTED: "LOOKUP_CHANNEL_REJECTED",
      OPEN_CHANNEL_TIMEOUT: "OPEN_CHANNEL_TIMEOUT",
      OPEN_CHANNEL_REJECTED: "OPEN_CHANNEL_REJECTED",
      REQUEST_DEFERRED: "REQUEST_DEFERRED",
      STREAM_ALREADY_PUBLISHED: "STREAM_ALREADY_PUBLISHED",
      STREAM_NOT_YET_PUBLISHED: "STREAM_NOT_YET_PUBLISHED",
      JOIN_TOO_FREQUENT: "JOIN_TOO_FREQUENT",
      SOCKET_ERROR: "SOCKET_ERROR",
      SOCKET_DISCONNECTED: "SOCKET_DISCONNECTED",
      PEERCONNECTION_FAILED: "PEERCONNECTION_FAILED",
      CONNECT_GATEWAY_ERROR: "CONNECT_GATEWAY_ERROR",
      SERVICE_NOT_AVAILABLE: "SERVICE_NOT_AVAILABLE",
      JOIN_CHANNEL_FAILED: "JOIN_CHANNEL_FAILED",
      PUBLISH_STREAM_FAILED: "PUBLISH_STREAM_FAILED",
      UNPUBLISH_STREAM_FAILED: "UNPUBLISH_STREAM_FAILED",
      SUBSCRIBE_STREAM_FAILED: "SUBSCRIBE_STREAM_FAILED",
      UNSUBSCRIBE_STREAM_FAILED: "UNSUBSCRIBE_STREAM_FAILED",
      NO_SUCH_REMOTE_STREAM: "NO_SUCH_REMOTE_STREAM",
      ERR_FAILED: "1",
      ERR_INVALID_VENDOR_KEY: "101",
      ERR_INVALID_CHANNEL_NAME: "102",
      WARN_NO_AVAILABLE_CHANNEL: "103",
      WARN_LOOKUP_CHANNEL_TIMEOUT: "104",
      WARN_LOOKUP_CHANNEL_REJECTED: "105",
      WARN_OPEN_CHANNEL_TIMEOUT: "106",
      WARN_OPEN_CHANNEL_REJECTED: "107",
      WARN_REQUEST_DEFERRED: "108",
      ERR_DYNAMIC_KEY_TIMEOUT: "109",
      ERR_INVALID_DYNAMIC_KEY: "110",
      ERR_NO_VOCS_AVAILABLE: "2000",
      ERR_NO_VOS_AVAILABLE: "2001",
      ERR_JOIN_CHANNEL_TIMEOUT: "2002",
      IOS_NOT_SUPPORT: "IOS_NOT_SUPPORT",
      WECHAT_NOT_SUPPORT: "WECHAT_NOT_SUPPORT",
      SHARING_SCREEN_NOT_SUPPORT: "SHARING_SCREEN_NOT_SUPPORT",
      STILL_ON_PUBLISHING: "STILL_ON_PUBLISHING",
      LOW_STREAM_ALREADY_PUBLISHED: "LOW_STREAM_ALREADY_PUBLISHED",
      LOW_STREAM_NOT_YET_PUBLISHED: "LOW_STREAM_ALREADY_PUBLISHED",
      HIGH_STREAM_NOT_VIDEO_TRACE: "HIGH_STREAM_NOT_VIDEO_TRACE",
      NOT_FIND_DEVICE_BY_LABEL: "NOT_FIND_DEVICE_BY_LABEL",
      ENABLE_DUALSTREAM_FAILED: "ENABLE_DUALSTREAM_FAILED",
      DISABLE_DUALSTREAM_FAILED: "DISABLE_DUALSTREAM_FAILED",
      PLAYER_NOT_FOUND: "PLAYER_NOT_FOUND",
      ELECTRON_NOT_SUPPORT_SHARING_SCREEN: "ELECTRON_NOT_SUPPORT_SHARING_SCREEN",
      BAD_ENVIRONMENT: "BAD_ENVIRONMENT"
    },
        T = function T(e) {
      var t = _({});

      t.id = e.id, t.fit = e.options && e.options.fit, "contain" !== t.fit && "cover" !== t.fit && (t.fit = null), t.url = e.url, t.stream = e.stream.stream, t.elementID = e.elementID, t.setAudioOutput = function (e, n, i) {
        var a = t.video || t.audio;
        return a ? a.setSinkId ? void a.setSinkId(e).then(function () {
          return o.default.debug("[" + t.id + "] " + "video ".concat(t.id, " setAudioOutput ").concat(e, " SUCCESS")), a == t.video && t.audio ? t.audio.setSinkId(e) : Promise.resolve();
        }).then(function () {
          return o.default.debug("[" + t.id + "] " + "audio ".concat(t.id, " setAudioOutput ").concat(e, " SUCCESS")), n && n();
        }).catch(function (e) {
          return o.default.error("[" + t.id + "] VideoPlayer.setAudioOutput", e), i && i(e);
        }) : (o.default.error("[" + t.id + "] ", A.WEB_API_NOT_SUPPORTED), i && i(A.WEB_API_NOT_SUPPORTED)) : (o.default.error("[" + t.id + "] ", A.PLAYER_NOT_FOUND), i && i(A.PLAYER_NOT_FOUND));
      }, t.destroy = function () {
        Object(h.c)(t.video, null), Object(h.c)(t.audio, null), t.video.pause(), delete t.resizer, document.getElementById(t.div.id) && t.parentNode.contains(t.div) && t.parentNode.removeChild(t.div);
      }, t.div = document.createElement("div"), t.div.setAttribute("id", "player_" + t.id), e.stream.video ? t.div.setAttribute("style", "width: 100%; height: 100%; position: relative; background-color: black; overflow: hidden;") : t.div.setAttribute("style", "width: 100%; height: 100%; position: relative; overflow: hidden;"), t.video = document.createElement("video"), t.video.setAttribute("id", "video" + t.id), e.stream.local && !e.stream.screen ? e.stream.mirror ? t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; transform: rotateY(180deg); object-fit: ".concat(t.fit || "cover", ";")) : t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; object-fit: ".concat(t.fit || "cover", ";")) : e.stream.video ? t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; object-fit: ".concat(t.fit || "cover", ";")) : e.stream.screen ? t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; object-fit: ".concat(t.fit || "contain")) : t.video.setAttribute("style", "width: 100%; height: 100%; position: absolute; display: none; object-fit: ".concat(t.fit || "cover"));
      var n = {
        autoplay: !0,
        muted: !!e.stream.local || !(!p.isSafari() && "iOS" !== p.getBrowserOS()) && "video_element_muted",
        playsinline: !0,
        controls: !(!p.isSafari() && "iOS" !== p.getBrowserOS() || e.stream.local),
        volume: null
      },
          i = I()({}, n, e.options);
      if (!0 !== i.muted || i.volume || (i.volume = 0), i.autoplay && t.video.setAttribute("autoplay", ""), !0 !== i.muted && "video_element_muted" !== i.muted || (t.video.setAttribute("muted", ""), t.video.muted = !0), i.playsinline && t.video.setAttribute("playsinline", ""), i.controls && t.video.setAttribute("controls", ""), Number.isFinite(i.volume) && (t.video.volume = i.volume), t.audio = document.createElement("audio"), t.audio.setAttribute("id", "audio" + t.id), i.autoplay && t.audio.setAttribute("autoplay", ""), !0 === i.muted && t.audio.setAttribute("muted", ""), !0 === i.muted && (t.audio.muted = !0), i.playsinline && t.audio.setAttribute("playsinline", ""), Number.isFinite(i.volume) && (t.audio.volume = i.volume), void 0 !== t.elementID ? (document.getElementById(t.elementID).appendChild(t.div), t.container = document.getElementById(t.elementID)) : (document.body.appendChild(t.div), t.container = document.body), t.parentNode = t.div.parentNode, t.video.addEventListener("playing", function (e) {
        !function e() {
          t.video.videoWidth * t.video.videoHeight > 4 ? o.default.debug("[" + t.id + "] video dimensions:", t.video.videoWidth, t.video.videoHeight) : setTimeout(e, 50);
        }();
      }), e.stream.hasVideo() || e.stream.hasScreen()) t.div.appendChild(t.video), t.div.appendChild(t.audio), Object(h.b)(t.video, e.stream.stream), Object(h.b)(t.audio, e.stream.stream);else if (!1 !== i.muted && "video_element_muted" !== i.muted || (t.video.removeAttribute("muted"), t.video.muted = !1, t.div.appendChild(t.video)), window.MediaStream && p.isSafari()) {
        var a = new MediaStream(e.stream.stream.getAudioTracks());
        Object(h.c)(t.video, a);
      } else Object(h.c)(t.video, e.stream.stream);
      return t.setAudioVolume = function (e) {
        var n = parseInt(e) / 100;
        isFinite(n) && (n < 0 ? n = 0 : n > 1 && (n = 1), t.video && (t.video.volume = n), t.audio && (t.audio.volume = n));
      }, t;
    },
        O = function O(e) {
      var t = {},
          n = webkitRTCPeerConnection;
      t.pc_config = {
        iceServers: []
      }, t.con = {
        optional: [{
          DtlsSrtpKeyAgreement: !0
        }]
      }, e.iceServers instanceof Array ? t.pc_config.iceServers = e.iceServers : (e.stunServerUrl && (e.stunServerUrl instanceof Array ? e.stunServerUrl.map(function (e) {
        "string" == typeof e && "" !== e && t.pc_config.iceServers.push({
          url: e
        });
      }) : "string" == typeof e.stunServerUrl && "" !== e.stunServerUrl && t.pc_config.iceServers.push({
        url: e.stunServerUrl
      })), e.turnServer && (e.turnServer instanceof Array ? e.turnServer.map(function (e) {
        "string" == typeof e.url && "" !== e.url && t.pc_config.iceServers.push({
          username: e.username,
          credential: e.password,
          url: e.url
        });
      }) : "string" == typeof e.turnServer.url && "" !== e.turnServer.url && t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.password,
        url: e.turnServer.url
      }))), void 0 === e.audio && (e.audio = !0), void 0 === e.video && (e.video = !0), t.mediaConstraints = {
        mandatory: {
          OfferToReceiveVideo: e.video,
          OfferToReceiveAudio: e.audio
        }
      }, t.roapSessionId = 103, t.peerConnection = new n(t.pc_config, t.con), t.peerConnection.onicecandidate = function (e) {
        e.candidate ? t.iceCandidateCount += 1 : (o.default.debug("PeerConnection State: " + t.peerConnection.iceGatheringState), void 0 === t.ices && (t.ices = 0), t.ices = t.ices + 1, t.ices >= 1 && t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded()));
      };

      var i = function i(t) {
        var n, i;
        return e.minVideoBW && e.maxVideoBW && (i = (n = t.match(/m=video.*\r\n/))[0] + "b=AS:" + e.maxVideoBW + "\r\n", t = t.replace(n[0], i), o.default.debug("Set Video Bitrate - min:" + e.minVideoBW + " max:" + e.maxVideoBW)), e.maxAudioBW && (i = (n = t.match(/m=audio.*\r\n/))[0] + "b=AS:" + e.maxAudioBW + "\r\n", t = t.replace(n[0], i)), t;
      };

      return t.processSignalingMessage = function (e) {
        var n,
            o = JSON.parse(e);
        t.incomingMessage = o, "new" === t.state ? "OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "offer-sent" === t.state ? "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.sendOK(), t.state = "established") : "pr-answer" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "pr-answer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : "offer" === o.messageType ? t.error("Not written yet") : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "established" === t.state && ("OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state));
      }, t.addStream = function (e) {
        t.peerConnection.addStream(e), t.markActionNeeded();
      }, t.removeStream = function () {
        t.markActionNeeded();
      }, t.close = function () {
        t.state = "closed", t.peerConnection.close();
      }, t.markActionNeeded = function () {
        t.actionNeeded = !0, t.doLater(function () {
          t.onstablestate();
        });
      }, t.doLater = function (e) {
        window.setTimeout(e, 1);
      }, t.onstablestate = function () {
        var e;

        if (t.actionNeeded) {
          if ("new" === t.state || "established" === t.state) t.peerConnection.createOffer(function (e) {
            if (e.sdp = i(e.sdp), o.default.debug("Changed", e.sdp), e.sdp !== t.prevOffer) return t.peerConnection.setLocalDescription(e), t.state = "preparing-offer", void t.markActionNeeded();
            o.default.debug("Not sending a new offer");
          }, function (e) {
            o.default.debug("peer connection create offer failed ", e);
          }, t.mediaConstraints);else if ("preparing-offer" === t.state) {
            if (t.moreIceComing) return;
            t.prevOffer = t.peerConnection.localDescription.sdp, t.sendMessage("OFFER", t.prevOffer), t.state = "offer-sent";
          } else if ("offer-received" === t.state) t.peerConnection.createAnswer(function (e) {
            if (t.peerConnection.setLocalDescription(e), t.state = "offer-received-preparing-answer", t.iceStarted) t.markActionNeeded();else {
              var n = new Date();
              o.default.debug(n.getTime() + ": Starting ICE in responder"), t.iceStarted = !0;
            }
          }, function (e) {
            o.default.debug("peer connection create answer failed ", e);
          }, t.mediaConstraints);else if ("offer-received-preparing-answer" === t.state) {
            if (t.moreIceComing) return;
            e = t.peerConnection.localDescription.sdp, t.sendMessage("ANSWER", e), t.state = "established";
          } else t.error("Dazed and confused in state " + t.state + ", stopping here");
          t.actionNeeded = !1;
        }
      }, t.sendOK = function () {
        t.sendMessage("OK");
      }, t.sendMessage = function (e, n) {
        var i = {};
        i.messageType = e, i.sdp = n, "OFFER" === e ? (i.offererSessionId = t.sessionId, i.answererSessionId = t.otherSessionId, i.seq = t.sequenceNumber += 1, i.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (i.offererSessionId = t.incomingMessage.offererSessionId, i.answererSessionId = t.sessionId, i.seq = t.incomingMessage.seq), t.onsignalingmessage(JSON.stringify(i));
      }, t._getSender = function (e) {
        if (t.peerConnection && t.peerConnection.getSenders) {
          var n = t.peerConnection.getSenders().find(function (t) {
            return t.track.kind == e;
          });
          if (n) return n;
        }

        return null;
      }, t.hasSender = function (e) {
        return !!t._getSender(e);
      }, t.replaceTrack = function (e, n, i) {
        var o = t._getSender(e.kind);

        if (!o) return i("NO_SENDER_FOUND");

        try {
          o.replaceTrack(e);
        } catch (e) {
          return i && i(e);
        }

        setTimeout(function () {
          return n && n();
        }, 50);
      }, t.error = function (e) {
        throw "Error in RoapOnJsep: " + e;
      }, t.sessionId = t.roapSessionId += 1, t.sequenceNumber = 0, t.actionNeeded = !1, t.iceStarted = !1, t.moreIceComing = !0, t.iceCandidateCount = 0, t.onsignalingmessage = e.callback, t.peerConnection.onopen = function () {
        t.onopen && t.onopen();
      }, t.peerConnection.onaddstream = function (e) {
        t.onaddstream && t.onaddstream(e);
      }, t.peerConnection.onremovestream = function (e) {
        t.onremovestream && t.onremovestream(e);
      }, t.peerConnection.oniceconnectionstatechange = function (e) {
        t.oniceconnectionstatechange && t.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      }, t.onaddstream = null, t.onremovestream = null, t.state = "new", t.markActionNeeded(), t;
    },
        C = function C(e) {
      var t = {},
          n = h.a;
      t.uid = e.uid, t.isVideoMute = e.isVideoMute, t.isAudioMute = e.isAudioMute, t.isSubscriber = e.isSubscriber, t.clientId = e.clientId, t.pc_config = {
        iceServers: [{
          url: "stun:webcs.agora.io:3478"
        }]
      }, t.con = {
        optional: [{
          DtlsSrtpKeyAgreement: !0
        }]
      }, e.iceServers instanceof Array ? t.pc_config.iceServers = e.iceServers : (e.stunServerUrl && (e.stunServerUrl instanceof Array ? e.stunServerUrl.map(function (e) {
        "string" == typeof e && "" !== e && t.pc_config.iceServers.push({
          url: e
        });
      }) : "string" == typeof e.stunServerUrl && "" !== e.stunServerUrl && t.pc_config.iceServers.push({
        url: e.stunServerUrl
      })), e.turnServer && (e.turnServer instanceof Array ? e.turnServer.map(function (e) {
        "string" == typeof e.url && "" !== e.url && t.pc_config.iceServers.push({
          username: e.username,
          credential: e.credential,
          url: e.url
        });
      }) : "string" == typeof e.turnServer.url && "" !== e.turnServer.url && (t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.udpport + "?transport=udp"
      }), "string" == typeof e.turnServer.tcpport && "" !== e.turnServer.tcpport && t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.tcpport + "?transport=tcp"
      }), !0 === e.turnServer.forceturn && (t.pc_config.iceTransportPolicy = "relay")))), void 0 === e.audio && (e.audio = !0), void 0 === e.video && (e.video = !0), t.mediaConstraints = {
        mandatory: {
          OfferToReceiveVideo: e.video,
          OfferToReceiveAudio: e.audio
        }
      }, t.roapSessionId = 103;

      try {
        t.pc_config.sdpSemantics = "plan-b", t.peerConnection = new n(t.pc_config, t.con);
      } catch (e) {
        delete t.pc_config.sdpSemantics, t.peerConnection = new n(t.pc_config, t.con);
      }

      t.peerConnection.onicecandidate = function (e) {
        var n, i, a, r;
        i = (n = t.peerConnection.localDescription.sdp).match(/a=candidate:.+typ\ssrflx.+\r\n/), a = n.match(/a=candidate:.+typ\shost.+\r\n/), r = n.match(/a=candidate:.+typ\srelay.+\r\n/), 0 === t.iceCandidateCount && (t.timeout = setTimeout(function () {
          t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded());
        }, 1e3)), null === i && null === a && null === r || void 0 !== t.ice || (o.default.debug("[" + t.clientId + "]srflx candidate : " + i + " relay candidate: " + r + " host candidate : " + a), clearTimeout(t.timeout), t.ice = 0, t.moreIceComing = !1, t.markActionNeeded()), t.iceCandidateCount = t.iceCandidateCount + 1;
      }, o.default.debug("[" + t.clientId + ']Created webkitRTCPeerConnnection with config "' + JSON.stringify(t.pc_config) + '".');

      var i = function i(t) {
        return e.screen && (t = t.replace("a=x-google-flag:conference\r\n", "")), t;
      },
          a = function a(n) {
        var i, a;

        if (e.minVideoBW && e.maxVideoBW) {
          a = (i = n.match(/m=video.*\r\n/))[0] + "b=AS:" + e.maxVideoBW + "\r\n";
          var r = 0,
              s = 0;
          "h264" === e.codec ? (r = n.search(/a=rtpmap:(\d+) H264\/90000\r\n/), s = n.search(/H264\/90000\r\n/)) : "vp8" === e.codec && (r = n.search(/a=rtpmap:(\d+) VP8\/90000\r\n/), s = n.search(/VP8\/90000\r\n/)), -1 !== r && -1 !== s && s - r > 10 && (a = a + "a=fmtp:" + n.slice(r + 9, s - 1) + " x-google-min-bitrate=" + e.minVideoBW + "\r\n"), n = n.replace(i[0], a), o.default.debug("[" + t.clientId + "]Set Video Bitrate - min:" + e.minVideoBW + " max:" + e.maxVideoBW);
        }

        return e.maxAudioBW && (a = (i = n.match(/m=audio.*\r\n/))[0] + "b=AS:" + e.maxAudioBW + "\r\n", n = n.replace(i[0], a)), n;
      };

      return t.processSignalingMessage = function (e) {
        var n,
            o = JSON.parse(e);
        t.incomingMessage = o, "new" === t.state ? "OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "offer-sent" === t.state ? "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), n.sdp = a(n.sdp), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.sendOK(), t.state = "established") : "pr-answer" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "pr-answer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : "offer" === o.messageType ? t.error("Not written yet") : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "established" === t.state && ("OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), n.sdp = a(n.sdp), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state));
      }, t.getVideoRelatedStats = function (e) {
        t.peerConnection.getStats(null, function (n) {
          Object.keys(n).forEach(function (i) {
            var o = n[i];
            t.isSubscriber ? "video" === o.mediaType && o.id && ~o.id.indexOf("recv") && e && e({
              mediaType: "video",
              peerId: t.uid,
              isVideoMute: t.isVideoMute,
              frameRateReceived: o.googFrameRateReceived,
              frameRateDecoded: o.googFrameRateDecoded,
              bytesReceived: o.bytesReceived,
              packetsReceived: o.packetsReceived,
              packetsLost: o.packetsLost
            }) : "video" === o.mediaType && o.id && ~o.id.indexOf("send") && e && e({
              mediaType: "video",
              isVideoMute: t.isVideoMute,
              frameRateInput: o.googFrameRateInput,
              frameRateSent: o.googFrameRateSent,
              googRtt: o.googRtt
            });
          });
        });
      }, t.getAudioRelatedStats = function (e) {
        t.peerConnection.getStats(null, function (n) {
          Object.keys(n).forEach(function (i) {
            var o = n[i];
            t.isSubscriber && "audio" === o.mediaType && o.id && ~o.id.indexOf("recv") && e && e({
              mediaType: "audio",
              peerId: t.uid,
              isAudioMute: t.isAudioMute,
              frameDropped: parseInt(o.googDecodingPLC) + parseInt(o.googDecodingPLCCNG) + "",
              frameReceived: o.googDecodingCTN,
              googJitterReceived: o.googJitterReceived,
              bytesReceived: o.bytesReceived,
              packetsReceived: o.packetsReceived,
              packetsLost: o.packetsLost
            });
          });
        });
      }, t.getStatsRate = function (e) {
        t.getStats(function (t) {
          e(t);
        });
      }, t.getStats = function (e) {
        t.peerConnection.getStats(null, function (n) {
          var i = [],
              o = [],
              a = null;
          Object.keys(n).forEach(function (e) {
            var t = n[e];
            o.push(t), "ssrc" !== t.type && "VideoBwe" !== t.type || (a = t.timestamp, i.push(t));
          }), i.push({
            id: "time",
            startTime: t.connectedTime,
            timestamp: a || new Date()
          }), e(i, o);
        });
      }, t.addTrack = function (e, n) {
        t.peerConnection.addTrack(e, n);
      }, t.removeTrack = function (e, n) {
        t.peerConnection.removeTrack(t.peerConnection.getSenders().find(function (t) {
          return t.track == e;
        }));
      }, t.addStream = function (e) {
        t.peerConnection.addStream(e), t.markActionNeeded();
      }, t.removeStream = function () {
        t.markActionNeeded();
      }, t.close = function () {
        t.state = "closed", t.peerConnection.close();
      }, t.markActionNeeded = function () {
        t.actionNeeded = !0, t.doLater(function () {
          t.onstablestate();
        });
      }, t.doLater = function (e) {
        window.setTimeout(e, 1);
      }, t.onstablestate = function () {
        var e;

        if (t.actionNeeded) {
          if ("new" === t.state || "established" === t.state) t.peerConnection.createOffer(function (e) {
            if (e.sdp !== t.prevOffer) return t.peerConnection.setLocalDescription(e), t.state = "preparing-offer", void t.markActionNeeded();
            o.default.debug("[" + t.clientId + "]Not sending a new offer");
          }, function (e) {
            o.default.debug("[" + t.clientId + "]peer connection create offer failed ", e);
          }, t.mediaConstraints);else if ("preparing-offer" === t.state) {
            if (t.moreIceComing) return;
            t.prevOffer = t.peerConnection.localDescription.sdp, t.prevOffer = t.prevOffer.replace(/a=candidate:.+typ\shost.+\r\n/g, "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n"), t.sendMessage("OFFER", t.prevOffer), t.state = "offer-sent";
          } else if ("offer-received" === t.state) t.peerConnection.createAnswer(function (e) {
            if (t.peerConnection.setLocalDescription(e), t.state = "offer-received-preparing-answer", t.iceStarted) t.markActionNeeded();else {
              var n = new Date();
              o.default.debug("[" + t.clientId + "]" + n.getTime() + ": Starting ICE in responder"), t.iceStarted = !0;
            }
          }, function (e) {
            o.default.debug("[" + t.clientId + "]peer connection create answer failed ", e);
          }, t.mediaConstraints);else if ("offer-received-preparing-answer" === t.state) {
            if (t.moreIceComing) return;
            e = t.peerConnection.localDescription.sdp, t.sendMessage("ANSWER", e), t.state = "established";
          } else t.error("Dazed and confused in state " + t.state + ", stopping here");
          t.actionNeeded = !1;
        }
      }, t.sendOK = function () {
        t.sendMessage("OK");
      }, t.sendMessage = function (e, n) {
        var i = {};
        i.messageType = e, i.sdp = n, "OFFER" === e ? (i.offererSessionId = t.sessionId, i.answererSessionId = t.otherSessionId, i.seq = t.sequenceNumber += 1, i.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (i.offererSessionId = t.incomingMessage.offererSessionId, i.answererSessionId = t.sessionId, i.seq = t.incomingMessage.seq), t.onsignalingmessage(JSON.stringify(i));
      }, t._getSender = function (e) {
        if (t.peerConnection && t.peerConnection.getSenders) {
          var n = t.peerConnection.getSenders().find(function (t) {
            return t.track.kind == e;
          });
          if (n) return n;
        }

        return null;
      }, t.hasSender = function (e) {
        return !!t._getSender(e);
      }, t.replaceTrack = function (e, n, i) {
        var o = t._getSender(e.kind);

        if (!o) return i("NO_SENDER_FOUND");

        try {
          o.replaceTrack(e);
        } catch (e) {
          return i && i(e);
        }

        setTimeout(function () {
          return n && n();
        }, 50);
      }, t.error = function (e) {
        throw "Error in RoapOnJsep: " + e;
      }, t.sessionId = t.roapSessionId += 1, t.sequenceNumber = 0, t.actionNeeded = !1, t.iceStarted = !1, t.moreIceComing = !0, t.iceCandidateCount = 0, t.onsignalingmessage = e.callback, t.peerConnection.ontrack = function (e) {
        t.onaddstream && (t.onaddstream(e, "ontrack"), t.peerConnection.onaddstream = null);
      }, t.peerConnection.onaddstream = function (e) {
        t.onaddstream && (t.onaddstream(e, "onaddstream"), t.peerConnection.ontrack = null);
      }, t.peerConnection.onremovestream = function (e) {
        t.onremovestream && t.onremovestream(e);
      }, t.peerConnection.oniceconnectionstatechange = function (e) {
        "connected" === e.currentTarget.iceConnectionState && (t.connectedTime = new Date()), t.oniceconnectionstatechange && t.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      }, t.peerConnection.onnegotiationneeded = function () {
        void 0 !== t.prevOffer && t.peerConnection.createOffer().then(function (e) {
          return e.sdp = e.sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n"), e.sdp = i(e.sdp), e.sdp = a(e.sdp), t.peerConnection.setLocalDescription(e);
        }).then(function () {
          t.onnegotiationneeded && t.onnegotiationneeded(t.peerConnection.localDescription.sdp);
        }).catch(function (e) {
          console.log("createOffer error: ", e);
        });
      }, t.onaddstream = null, t.onremovestream = null, t.onnegotiationneeded = null, t.state = "new", t.markActionNeeded(), t;
    },
        N = function N(e) {
      var t = {},
          n = h.a;
      t.uid = e.uid, t.isVideoMute = e.isVideoMute, t.isAudioMute = e.isAudioMute, t.isSubscriber = e.isSubscriber, t.clientId = e.clientId, t.pc_config = {
        iceServers: [{
          urls: ["stun:webcs.agora.io:3478", "stun:stun.l.google.com:19302"]
        }],
        bundlePolicy: "max-bundle"
      }, t.con = {
        optional: [{
          DtlsSrtpKeyAgreement: !0
        }]
      }, e.iceServers instanceof Array ? t.pc_config.iceServers = e.iceServers : (e.stunServerUrl && (e.stunServerUrl instanceof Array ? e.stunServerUrl.map(function (e) {
        "string" == typeof e && "" !== e && t.pc_config.iceServers.push({
          url: e
        });
      }) : "string" == typeof e.stunServerUrl && "" !== e.stunServerUrl && t.pc_config.iceServers.push({
        url: e.stunServerUrl
      })), e.turnServer && (e.turnServer instanceof Array ? e.turnServer.map(function (e) {
        "string" == typeof e.url && "" !== e.url && t.pc_config.iceServers.push({
          username: e.username,
          credential: e.credential,
          url: e.url
        });
      }) : "string" == typeof e.turnServer.url && "" !== e.turnServer.url && (t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: ["turn:" + e.turnServer.url + ":" + e.turnServer.udpport + "?transport=udp"]
      }), "string" == typeof e.turnServer.tcpport && "" !== e.turnServer.tcpport && t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: ["turn:" + e.turnServer.url + ":" + e.turnServer.tcpport + "?transport=tcp"]
      }), !0 === e.turnServer.forceturn && (t.pc_config.iceTransportPolicy = "relay")))), void 0 === e.audio && (e.audio = !0), void 0 === e.video && (e.video = !0), t.mediaConstraints = {
        mandatory: {
          OfferToReceiveVideo: e.video,
          OfferToReceiveAudio: e.audio
        }
      }, t.roapSessionId = 103;

      try {
        t.pc_config.sdpSemantics = "plan-b", t.peerConnection = new n(t.pc_config, t.con);
      } catch (e) {
        delete t.pc_config.sdpSemantics, t.peerConnection = new n(t.pc_config, t.con);
      }

      o.default.debug("[" + t.clientId + ']safari Created RTCPeerConnnection with config "' + JSON.stringify(t.pc_config) + '".'), t.peerConnection.onicecandidate = function (e) {
        var n, i, a, r;
        i = (n = t.peerConnection.localDescription.sdp).match(/a=candidate:.+typ\ssrflx.+\r\n/), a = n.match(/a=candidate:.+typ\shost.+\r\n/), r = n.match(/a=candidate:.+typ\srelay.+\r\n/), 0 === t.iceCandidateCount && (t.timeout = setTimeout(function () {
          t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded());
        }, 1e3)), null === i && null === a && null === r || void 0 !== t.ice || (o.default.debug("[" + t.clientId + "]srflx candidate : " + i + " relay candidate: " + r + " host candidate : " + a), clearTimeout(t.timeout), t.ice = 0, t.moreIceComing = !1, t.markActionNeeded()), t.iceCandidateCount = t.iceCandidateCount + 1;
      };

      var i = function i(t) {
        return e.screen && (t = t.replace("a=x-google-flag:conference\r\n", "")), t;
      },
          a = function a(n) {
        var i, a;
        return e.minVideoBW && e.maxVideoBW && (a = (i = n.match(/m=video.*\r\n/))[0] + "b=AS:" + e.maxVideoBW + "\r\n", n = n.replace(i[0], a), o.default.debug("[" + t.clientId + "]Set Video Bitrate - min:" + e.minVideoBW + " max:" + e.maxVideoBW)), e.maxAudioBW && (a = (i = n.match(/m=audio.*\r\n/))[0] + "b=AS:" + e.maxAudioBW + "\r\n", n = n.replace(i[0], a)), n;
      };

      t.processSignalingMessage = function (e) {
        var n,
            o = JSON.parse(e);
        t.incomingMessage = o, "new" === t.state ? "OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "offer-sent" === t.state ? "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), n.sdp = a(n.sdp), n.sdp = n.sdp.replace(/a=x-google-flag:conference\r\n/g, ""), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.sendOK(), t.state = "established") : "pr-answer" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "pr-answer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : "offer" === o.messageType ? t.error("Not written yet") : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state) : "established" === t.state && ("OFFER" === o.messageType ? (n = {
          sdp: o.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new RTCSessionDescription(n)), t.state = "offer-received", t.markActionNeeded()) : "ANSWER" === o.messageType ? ((n = {
          sdp: o.sdp,
          type: "answer"
        }).sdp = i(n.sdp), n.sdp = a(n.sdp), t.peerConnection.setRemoteDescription(new RTCSessionDescription(n))) : t.error("Illegal message for this state: " + o.messageType + " in state " + t.state));
      };

      var r = {
        id: "",
        type: "",
        mediaType: "",
        googCodecName: "opus",
        aecDivergentFilterFraction: "0",
        audioInputLevel: "0",
        bytesSent: "0",
        packetsSent: "0",
        googEchoCancellationReturnLoss: "0",
        googEchoCancellationReturnLossEnhancement: "0"
      },
          s = {
        id: "",
        type: "",
        mediaType: "",
        googCodecName: "h264" === e.codec ? "H264" : "VP8",
        bytesSent: "0",
        packetsLost: "0",
        packetsSent: "0",
        googAdaptationChanges: "0",
        googAvgEncodeMs: "0",
        googEncodeUsagePercent: "0",
        googFirsReceived: "0",
        googFrameHeightSent: "0",
        googFrameHeightInput: "0",
        googFrameRateInput: "0",
        googFrameRateSent: "0",
        googFrameWidthSent: "0",
        googFrameWidthInput: "0",
        googNacksReceived: "0",
        googPlisReceived: "0",
        googRtt: "0",
        googFramesEncoded: "0"
      },
          d = {
        id: "",
        type: "",
        mediaType: "",
        audioOutputLevel: "0",
        bytesReceived: "0",
        packetsLost: "0",
        packetsReceived: "0",
        googAccelerateRate: "0",
        googCurrentDelayMs: "0",
        googDecodingCNG: "0",
        googDecodingCTN: "0",
        googDecodingCTSG: "0",
        googDecodingNormal: "0",
        googDecodingPLC: "0",
        googDecodingPLCCNG: "0",
        googExpandRate: "0",
        googJitterBufferMs: "0",
        googJitterReceived: "0",
        googPreemptiveExpandRate: "0",
        googPreferredJitterBufferMs: "0",
        googSecondaryDecodedRate: "0",
        googSpeechExpandRate: "0"
      },
          c = {
        id: "",
        type: "",
        mediaType: "",
        googTargetDelayMs: "0",
        packetsLost: "0",
        googDecodeMs: "0",
        googMaxDecodeMs: "0",
        googRenderDelayMs: "0",
        googFrameWidthReceived: "0",
        googFrameHeightReceived: "0",
        googFrameRateReceived: "0",
        googFrameRateDecoded: "0",
        googFrameRateOutput: "0",
        googFramesDecoded: "0",
        googFrameReceived: "0",
        googJitterBufferMs: "0",
        googCurrentDelayMs: "0",
        googMinPlayoutDelayMs: "0",
        googNacksSent: "0",
        googPlisSent: "0",
        googFirsSent: "0",
        bytesReceived: "0",
        packetsReceived: "0"
      },
          u = {
        id: "bweforvideo",
        type: "VideoBwe",
        googAvailableSendBandwidth: "0",
        googAvailableReceiveBandwidth: "0",
        googActualEncBitrate: "0",
        googRetransmitBitrate: "0",
        googTargetEncBitrate: "0",
        googBucketDelay: "0",
        googTransmitBitrate: "0"
      },
          l = 0,
          p = 0,
          f = 0;
      return t.getVideoRelatedStats = function (n) {
        t.peerConnection.getStats().then(function (i) {
          var o = {
            peerId: t.uid,
            mediaType: "video",
            isVideoMute: t.isVideoMute
          };
          i.forEach(function (i) {
            if (t.isSubscriber) {
              if ("track" === i.type && (~i.id.indexOf("video") || ~i.trackIdentifier.indexOf("v"))) {
                if (!t.lastReport) return void (t.lastReport = i);
                o.frameRateReceived = i.framesReceived - t.lastReport.framesReceived + "", o.frameRateDecoded = i.framesDecoded - t.lastReport.framesDecoded + "", t.lastReport = i;
              }

              "inbound-rtp" === i.type && ~i.id.indexOf("Video") && (o.bytesReceived = i.bytesReceived + "", o.packetsReceived = i.packetsReceived + "", o.packetsLost = i.packetsLost + "");
            } else if ("outbound-rtp" === i.type && ~i.id.indexOf("Video")) {
              if (!t.lastReport) return void (t.lastReport = i);
              n && n({
                mediaType: "video",
                isVideoMute: t.isVideoMute,
                frameRateInput: e.maxFrameRate + "",
                frameRateSent: i.framesEncoded - t.lastReport.framesEncoded + ""
              }), t.lastReport = i;
            }
          }), n && n(o);
        });
      }, t.getAudioRelatedStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          n.forEach(function (n) {
            t.isSubscriber && "inbound-rtp" === n.type && ~n.id.indexOf("Audio") && e && e({
              peerId: t.uid,
              mediaType: "audio",
              isAudioMute: t.isAudioMute,
              frameDropped: n.packetsLost + "",
              frameReceived: n.packetsReceived + "",
              googJitterReceived: n.jitter + "",
              bytesReceived: n.bytesReceived + "",
              packetsReceived: n.packetsReceived + "",
              packetsLost: n.packetsLost + ""
            });
          });
        });
      }, t.getStatsRate = function (e) {
        t.getStats(function (t) {
          t.forEach(function (e) {
            "outbound-rtp" === e.type && "video" === e.mediaType && e.googFramesEncoded && (e.googFrameRateSent = ((e.googFramesEncoded - l) / 3).toString(), l = e.googFramesEncoded), "inbound-rtp" === e.type && -1 != e.id.indexOf("55543") && (e.googFrameRateReceived && (e.googFrameRateReceived = ((e.googFrameReceived - f) / 3).toString(), f = e.googFrameReceived), e.googFrameRateDecoded && (e.googFrameRateDecoded = ((e.googFramesDecoded - p) / 3).toString(), p = e.googFramesDecoded));
          }), e(t);
        });
      }, t.getStats = function (e) {
        var n = [];
        t.peerConnection.getStats().then(function (i) {
          i.forEach(function (e) {
            n.push(e), "outbound-rtp" === e.type && "audio" === e.mediaType && (r.id = e.id, r.type = e.type, r.mediaType = e.mediaType, r.bytesSent = e.bytesSent ? e.bytesSent + "" : "0", r.packetsSent = e.packetsSent ? e.packetsSent + "" : "0"), "outbound-rtp" === e.type && "video" === e.mediaType && (s.id = e.id, s.type = e.type, s.mediaType = e.mediaType, s.bytesSent = e.bytesSent ? e.bytesSent + "" : "0", s.packetsSent = e.packetsSent ? e.packetsSent + "" : "0", s.googPlisReceived = e.pliCount ? e.pliCount + "" : "0", s.googNacksReceived = e.nackCount ? e.nackCount + "" : "0", s.googFirsReceived = e.firCount ? e.firCount + "" : "0", s.googFramesEncoded = e.framesEncoded ? e.framesEncoded + "" : "0"), "inbound-rtp" === e.type && -1 != e.id.indexOf("44444") && (d.id = e.id, d.type = e.type, d.mediaType = "audio", d.packetsReceived = e.packetsReceived ? e.packetsReceived + "" : "0", d.bytesReceived = e.bytesReceived ? e.bytesReceived + "" : "0", d.packetsLost = e.packetsLost ? e.packetsLost + "" : "0", d.packetsReceived = e.packetsReceived ? e.packetsReceived + "" : "0", d.googJitterReceived = e.jitter ? e.jitter + "" : "0"), "inbound-rtp" === e.type && -1 != e.id.indexOf("55543") && (c.id = e.id, c.type = e.type, c.mediaType = "video", c.packetsReceived = e.packetsReceived ? e.packetsReceived + "" : "0", c.bytesReceived = e.bytesReceived ? e.bytesReceived + "" : "0", c.packetsLost = e.packetsLost ? e.packetsLost + "" : "0", c.googJitterBufferMs = e.jitter ? e.jitter + "" : "0", c.googNacksSent = e.nackCount ? e.nackCount + "" : "0", c.googPlisSent = e.pliCount ? e.pliCount + "" : "0", c.googFirsSent = e.firCount ? e.firCount + "" : "0"), "track" !== e.type || -1 == e.id.indexOf("55543") && !~e.trackIdentifier.indexOf("v") || (c.googFrameWidthReceived = e.frameWidth ? e.frameWidth + "" : "0", c.googFrameHeightReceived = e.frameHeight ? e.frameHeight + "" : "0", c.googFrameReceived = e.framesReceived ? e.framesReceived + "" : "0", c.googFramesDecoded = e.framesDecoded ? e.framesDecoded + "" : "0"), "track" !== e.type || -1 == e.id.indexOf("44444") && !~e.trackIdentifier.indexOf("a") || (d.audioOutputLevel = e.audioLevel + "", r.audioInputLevel = e.audioLevel + ""), "candidate-pair" === e.type && (0 == e.availableIncomingBitrate ? u.googAvailableSendBandwidth = e.availableOutgoingBitrate + "" : u.googAvailableReceiveBandwidth = e.availableIncomingBitrate + "");
          });
          var o = [u, r, s, d, c];
          o.push({
            id: "time",
            startTime: t.connectedTime,
            timestamp: new Date()
          }), e(o, n);
        }).catch(function (e) {
          console.error(e);
        });
      }, t.addTrack = function (e, n) {
        t.peerConnection.addTrack(e, n);
      }, t.removeTrack = function (e, n) {
        var i = t.peerConnection.getSenders().find(function (t) {
          return t.track == e;
        });
        i.replaceTrack(null), t.peerConnection.removeTrack(i);
      }, t.addStream = function (e) {
        window.navigator.userAgent.indexOf("Safari") > -1 && -1 === navigator.userAgent.indexOf("Chrome") ? e.getTracks().forEach(function (n) {
          return t.peerConnection.addTrack(n, e);
        }) : t.peerConnection.addStream(e), t.markActionNeeded();
      }, t.removeStream = function () {
        t.markActionNeeded();
      }, t.close = function () {
        t.state = "closed", t.peerConnection.close();
      }, t.markActionNeeded = function () {
        t.actionNeeded = !0, t.doLater(function () {
          t.onstablestate();
        });
      }, t.doLater = function (e) {
        window.setTimeout(e, 1);
      }, t.onstablestate = function () {
        var n;

        if (t.actionNeeded) {
          if ("new" === t.state || "established" === t.state) e.isSubscriber && (t.peerConnection.addTransceiver("audio", {
            direction: "recvonly"
          }), t.peerConnection.addTransceiver("video", {
            direction: "recvonly"
          })), t.peerConnection.createOffer(t.mediaConstraints).then(function (n) {
            if (n.sdp = a(n.sdp), e.isSubscriber || (n.sdp = n.sdp.replace(/a=extmap:4 urn:3gpp:video-orientation\r\n/g, "")), n.sdp !== t.prevOffer) return t.peerConnection.setLocalDescription(n), t.state = "preparing-offer", void t.markActionNeeded();
            o.default.debug("[" + t.clientId + "]Not sending a new offer");
          }).catch(function (e) {
            o.default.debug("[" + t.clientId + "]peer connection create offer failed ", e);
          });else if ("preparing-offer" === t.state) {
            if (t.moreIceComing) return;
            t.prevOffer = t.peerConnection.localDescription.sdp, t.prevOffer = t.prevOffer.replace(/a=candidate:.+typ\shost.+\r\n/g, "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n"), t.sendMessage("OFFER", t.prevOffer), t.state = "offer-sent";
          } else if ("offer-received" === t.state) t.peerConnection.createAnswer(function (e) {
            if (t.peerConnection.setLocalDescription(e), t.state = "offer-received-preparing-answer", t.iceStarted) t.markActionNeeded();else {
              var n = new Date();
              o.default.debug("[" + t.clientId + "]" + n.getTime() + ": Starting ICE in responder"), t.iceStarted = !0;
            }
          }, function (e) {
            o.default.debug("[" + t.clientId + "]peer connection create answer failed ", e);
          }, t.mediaConstraints);else if ("offer-received-preparing-answer" === t.state) {
            if (t.moreIceComing) return;
            n = t.peerConnection.localDescription.sdp, t.sendMessage("ANSWER", n), t.state = "established";
          } else t.error("Dazed and confused in state " + t.state + ", stopping here");
          t.actionNeeded = !1;
        }
      }, t.sendOK = function () {
        t.sendMessage("OK");
      }, t.sendMessage = function (e, n) {
        var i = {};
        i.messageType = e, i.sdp = n, "OFFER" === e ? (i.offererSessionId = t.sessionId, i.answererSessionId = t.otherSessionId, i.seq = t.sequenceNumber += 1, i.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (i.offererSessionId = t.incomingMessage.offererSessionId, i.answererSessionId = t.sessionId, i.seq = t.incomingMessage.seq), t.onsignalingmessage(JSON.stringify(i));
      }, t._getSender = function (e) {
        if (t.peerConnection && t.peerConnection.getSenders) {
          var n = t.peerConnection.getSenders().find(function (t) {
            return t.track.kind == e;
          });
          if (n) return n;
        }

        return null;
      }, t.hasSender = function (e) {
        return !!t._getSender(e);
      }, t.replaceTrack = function (e, n, i) {
        var o = t._getSender(e.kind);

        if (!o) return i("NO_SENDER_FOUND");

        try {
          o.replaceTrack(e);
        } catch (e) {
          return i && i(e);
        }

        setTimeout(function () {
          return n && n();
        }, 50);
      }, t.error = function (e) {
        throw "Error in RoapOnJsep: " + e;
      }, t.sessionId = t.roapSessionId += 1, t.sequenceNumber = 0, t.actionNeeded = !1, t.iceStarted = !1, t.moreIceComing = !0, t.iceCandidateCount = 0, t.onsignalingmessage = e.callback, t.peerConnection.ontrack = function (e) {
        t.onaddstream && t.onaddstream(e, "ontrack");
      }, t.peerConnection.onremovestream = function (e) {
        t.onremovestream && t.onremovestream(e);
      }, t.peerConnection.oniceconnectionstatechange = function (e) {
        "connected" === e.currentTarget.iceConnectionState && (t.connectedTime = new Date()), t.oniceconnectionstatechange && t.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      }, t.peerConnection.onnegotiationneeded = function () {
        void 0 !== t.prevOffer && t.peerConnection.createOffer().then(function (e) {
          return e.sdp = e.sdp.replace(/a=recvonly\r\n/g, "a=inactive\r\n"), e.sdp = i(e.sdp), e.sdp = a(e.sdp), t.peerConnection.setLocalDescription(e);
        }).then(function () {
          t.onnegotiationneeded && t.onnegotiationneeded(t.peerConnection.localDescription.sdp);
        }).catch(function (e) {
          console.log("createOffer error: ", e);
        });
      }, t.onaddstream = null, t.onremovestream = null, t.state = "new", t.markActionNeeded(), t;
    },
        w = function w() {
      var e = {
        addStream: function addStream() {}
      };
      return e;
    },
        D = function D(e) {
      var t = {},
          n = (mozRTCPeerConnection, mozRTCSessionDescription),
          i = !1;
      t.uid = e.uid, t.isVideoMute = e.isVideoMute, t.isAudioMute = e.isAudioMute, t.isSubscriber = e.isSubscriber, t.clientId = e.clientId, t.pc_config = {
        iceServers: []
      }, e.iceServers instanceof Array ? e.iceServers.map(function (e) {
        0 === e.url.indexOf("stun:") && t.pc_config.iceServers.push({
          url: e.url
        });
      }) : (e.stunServerUrl && (e.stunServerUrl instanceof Array ? e.stunServerUrl.map(function (e) {
        "string" == typeof e && "" !== e && t.pc_config.iceServers.push({
          url: e
        });
      }) : "string" == typeof e.stunServerUrl && "" !== e.stunServerUrl && t.pc_config.iceServers.push({
        url: e.stunServerUrl
      })), e.turnServer && "string" == typeof e.turnServer.url && "" !== e.turnServer.url && (t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.udpport + "?transport=udp"
      }), "string" == typeof e.turnServer.tcpport && "" !== e.turnServer.tcpport && t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.tcpport + "?transport=tcp"
      }), !0 === e.turnServer.forceturn && (t.pc_config.iceTransportPolicy = "relay"))), void 0 === e.audio && (e.audio = !0), void 0 === e.video && (e.video = !0), t.mediaConstraints = {
        offerToReceiveAudio: e.audio,
        offerToReceiveVideo: e.video,
        mozDontOfferDataChannel: !0
      }, t.roapSessionId = 103, t.peerConnection = new h.a(t.pc_config), o.default.debug("[" + t.clientId + ']safari Created RTCPeerConnnection with config "' + JSON.stringify(t.pc_config) + '".'), t.peerConnection.onicecandidate = function (e) {
        var n, i, a, r;
        i = (n = t.peerConnection.localDescription.sdp).match(/a=candidate:.+typ\ssrflx.+\r\n/), a = n.match(/a=candidate:.+typ\shost.+\r\n/), r = n.match(/a=candidate:.+typ\srelay.+\r\n/), 0 === t.iceCandidateCount && (t.timeout = setTimeout(function () {
          t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded());
        }, 1e3)), null === i && null === a && null === r || void 0 !== t.ice || (o.default.debug("[" + t.clientId + "]srflx candidate : " + i + " relay candidate: " + r + " host candidate : " + a), clearTimeout(t.timeout), t.ice = 0, t.moreIceComing = !1, t.markActionNeeded()), t.iceCandidateCount = t.iceCandidateCount + 1;
      }, t.checkMLineReverseInSDP = function (e) {
        return !(!~e.indexOf("m=audio") || !~e.indexOf("m=video")) && e.indexOf("m=audio") > e.indexOf("m=video");
      }, t.reverseMLineInSDP = function (e) {
        var t = e.split("m=audio"),
            n = t[1].split("m=video"),
            i = "m=video" + n[1],
            o = "m=audio" + n[0];
        return e = t[0] + i + o;
      }, t.processSignalingMessage = function (e) {
        var i,
            a = JSON.parse(e);
        t.incomingMessage = a, "new" === t.state ? "OFFER" === a.messageType ? (a.sdp = u(a.sdp), i = {
          sdp: a.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          o.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          o.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        }), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + a.messageType + " in state " + t.state) : "offer-sent" === t.state ? "ANSWER" === a.messageType ? (a.sdp = u(a.sdp), a.sdp = a.sdp.replace(/ generation 0/g, ""), a.sdp = a.sdp.replace(/ udp /g, " UDP "), -1 !== a.sdp.indexOf("a=group:BUNDLE") ? (a.sdp = a.sdp.replace(/a=group:BUNDLE audio video/, "a=group:BUNDLE sdparta_0 sdparta_1"), a.sdp = a.sdp.replace(/a=mid:audio/, "a=mid:sdparta_0"), a.sdp = a.sdp.replace(/a=mid:video/, "a=mid:sdparta_1")) : (a.sdp = a.sdp.replace(/a=mid:audio/, "a=mid:sdparta_0"), a.sdp = a.sdp.replace(/a=mid:video/, "a=mid:sdparta_0")), i = {
          sdp: a.sdp,
          type: "answer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          o.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          o.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e);
        }), t.sendOK(), t.state = "established") : "pr-answer" === a.messageType ? (i = {
          sdp: a.sdp,
          type: "pr-answer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          o.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          o.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        })) : "offer" === a.messageType ? t.error("Not written yet") : t.error("Illegal message for this state: " + a.messageType + " in state " + t.state) : "established" === t.state && ("OFFER" === a.messageType ? (i = {
          sdp: a.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          o.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          o.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        }), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + a.messageType + " in state " + t.state));
      };
      var a = {
        id: "",
        type: "",
        mediaType: "opus",
        googCodecName: "opus",
        aecDivergentFilterFraction: "0",
        audioInputLevel: "0",
        bytesSent: "0",
        packetsSent: "0",
        googEchoCancellationReturnLoss: "0",
        googEchoCancellationReturnLossEnhancement: "0"
      },
          r = {
        id: "",
        type: "",
        mediaType: "",
        googCodecName: "h264" === e.codec ? "H264" : "VP8",
        bytesSent: "0",
        packetsLost: "0",
        packetsSent: "0",
        googAdaptationChanges: "0",
        googAvgEncodeMs: "0",
        googEncodeUsagePercent: "0",
        googFirsReceived: "0",
        googFrameHeightSent: "0",
        googFrameHeightInput: "0",
        googFrameRateInput: "0",
        googFrameRateSent: "0",
        googFrameWidthSent: "0",
        googFrameWidthInput: "0",
        googNacksReceived: "0",
        googPlisReceived: "0",
        googRtt: "0"
      },
          s = {
        id: "",
        type: "",
        mediaType: "",
        audioOutputLevel: "0",
        bytesReceived: "0",
        packetsLost: "0",
        packetsReceived: "0",
        googAccelerateRate: "0",
        googCurrentDelayMs: "0",
        googDecodingCNG: "0",
        googDecodingCTN: "0",
        googDecodingCTSG: "0",
        googDecodingNormal: "0",
        googDecodingPLC: "0",
        googDecodingPLCCNG: "0",
        googExpandRate: "0",
        googJitterBufferMs: "0",
        googJitterReceived: "0",
        googPreemptiveExpandRate: "0",
        googPreferredJitterBufferMs: "0",
        googSecondaryDecodedRate: "0",
        googSpeechExpandRate: "0"
      },
          d = {
        id: "",
        type: "",
        mediaType: "",
        googTargetDelayMs: "0",
        packetsLost: "0",
        googDecodeMs: "0",
        googMaxDecodeMs: "0",
        googRenderDelayMs: "0",
        googFrameWidthReceived: "0",
        googFrameHeightReceived: "0",
        googFrameRateReceived: "0",
        googFrameRateDecoded: "0",
        googFrameRateOutput: "0",
        googJitterBufferMs: "0",
        googCurrentDelayMs: "0",
        googMinPlayoutDelayMs: "0",
        googNacksSent: "0",
        googPlisSent: "0",
        googFirsSent: "0",
        bytesReceived: "0",
        packetsReceived: "0",
        googFramesDecoded: "0"
      },
          c = 0;
      t.getVideoRelatedStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          Object.keys(n).forEach(function (i) {
            var o = n[i];

            if (t.isSubscriber) {
              if ("inboundrtp" === o.type && "video" === o.mediaType) {
                if (!t.lastReport) return void (t.lastReport = o);
                e && e({
                  browser: "firefox",
                  mediaType: "video",
                  peerId: t.uid,
                  isVideoMute: t.isVideoMute,
                  frameRateReceived: o.framerateMean + "",
                  frameRateDecoded: o.framesDecoded - t.lastReport.framesDecoded + "",
                  bytesReceived: o.bytesReceived + "",
                  packetsReceived: o.packetsReceived + "",
                  packetsLost: o.packetsLost + ""
                }), t.lastReport = o;
              }
            } else if ("outboundrtp" === o.type && "video" === o.mediaType) {
              if (!t.lastReport) return void (t.lastReport = o);
              e && e({
                mediaType: "video",
                isVideoMute: t.isVideoMute,
                frameRateInput: o.framerateMean + "",
                frameRateSent: o.framesEncoded - t.lastReport.framesEncoded + ""
              }), t.lastReport = o;
            }
          });
        });
      }, t.getAudioRelatedStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          Object.keys(n).forEach(function (i) {
            var o = n[i];
            t.isSubscriber && "inboundrtp" === o.type && "audio" === o.mediaType && e && e({
              browser: "firefox",
              mediaType: "audio",
              peerId: t.uid,
              isAudioMute: t.isAudioMute,
              frameDropped: o.packetsLost + "",
              frameReceived: o.packetsReceived + "",
              googJitterReceived: o.jitter + "",
              bytesReceived: o.bytesReceived + "",
              packetsReceived: o.packetsReceived + "",
              packetsLost: o.packetsLost + ""
            });
          });
        });
      }, t.getStatsRate = function (e) {
        t.getStats(function (t) {
          t.forEach(function (e) {
            "inboundrtp" === e.type && "video" === e.mediaType && e.googFrameRateDecoded && (e.googFrameRateDecoded = ((e.googFramesDecoded - c) / 3).toString(), c = e.googFramesDecoded);
          }), e(t);
        });
      }, t.getStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          var i = [];
          Object.keys(n).forEach(function (e) {
            var t = n[e];
            i.push(t), "outboundrtp" === t.type && "video" === t.mediaType && -1 === t.id.indexOf("rtcp") && (r.id = t.id, r.type = t.type, r.mediaType = t.mediaType, r.bytesSent = t.bytesSent ? t.bytesSent + "" : "0", r.packetsSent = t.packetsSent ? t.packetsSent + "" : "0", r.googPlisReceived = t.pliCount ? t.pliCount + "" : "0", r.googNacksReceived = t.nackCount ? t.nackCount + "" : "0", r.googFirsReceived = t.firCount ? t.firCount + "" : "0", r.googFrameRateSent = t.framerateMean ? t.framerateMean + "" : "0"), "outboundrtp" === t.type && "audio" === t.mediaType && -1 === t.id.indexOf("rtcp") && (a.id = t.id, a.type = t.type, a.mediaType = t.mediaType, a.bytesSent = t.bytesSent ? t.bytesSent + "" : "0", a.packetsSent = t.packetsSent ? t.packetsSent + "" : "0"), "inboundrtp" !== t.type || "audio" !== t.mediaType || t.isRemote || -1 !== t.id.indexOf("rtcp") || (s.id = t.id, s.type = t.type, s.mediaType = t.mediaType, s.bytesReceived = t.bytesReceived ? t.bytesReceived + "" : "0", s.packetsLost = t.packetsLost ? t.packetsLost + "" : "0", s.packetsReceived = t.packetsReceived ? t.packetsReceived + "" : "0", s.googJitterReceived = t.jitter ? t.jitter + "" : "0"), "inboundrtp" !== t.type || "video" !== t.mediaType || t.isRemote || -1 !== t.id.indexOf("rtcp") || (d.id = t.id, d.type = t.type, d.mediaType = t.mediaType, d.bytesReceived = t.bytesReceived ? t.bytesReceived + "" : "0", d.googFrameRateReceived = t.framerateMean ? t.framerateMean + "" : "0", d.googFramesDecoded = t.framesDecoded ? t.framesDecoded + "" : "0", d.packetsLost = t.packetsLost ? t.packetsLost + "" : "0", d.packetsReceived = t.packetsReceived ? t.packetsReceived + "" : "0", d.googJitterBufferMs = t.jitter ? t.jitter + "" : "0", d.googNacksSent = t.nackCount ? t.nackCount + "" : "0", d.googPlisSent = t.pliCount ? t.pliCount + "" : "0", d.googFirsSent = t.firCount ? t.firCount + "" : "0"), -1 !== t.id.indexOf("outbound_rtcp_video") && (r.packetsLost = t.packetsLost ? t.packetsLost + "" : "0");
          });
          var o = [r, a, s, d];
          o.push({
            id: "time",
            startTime: t.connectedTime,
            timestamp: new Date()
          }), e(o, i);
        }, function (e) {
          o.default.error("[" + t.clientId + "]" + e);
        });
      }, t.addStream = function (e) {
        i = !0, t.peerConnection.addStream(e), t.markActionNeeded();
      }, t.removeStream = function () {
        t.markActionNeeded();
      }, t.close = function () {
        t.state = "closed", t.peerConnection.close();
      }, t.markActionNeeded = function () {
        t.actionNeeded = !0, t.doLater(function () {
          t.onstablestate();
        });
      }, t.doLater = function (e) {
        window.setTimeout(e, 1);
      }, t.onstablestate = function () {
        if (t.actionNeeded) {
          if ("new" === t.state || "established" === t.state) i && (t.mediaConstraints = void 0), t.peerConnection.createOffer(function (e) {
            if (e.sdp = u(e.sdp), e.sdp = e.sdp.replace(/a=extmap:1 http:\/\/www.webrtc.org\/experiments\/rtp-hdrext\/abs-send-time/, "a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"), e.sdp !== t.prevOffer) return t.peerConnection.setLocalDescription(e), t.state = "preparing-offer", void t.markActionNeeded();
            o.default.debug("[" + t.clientId + "]Not sending a new offer");
          }, function (e) {
            o.default.debug("[" + t.clientId + "]Ups! create offer failed ", e);
          }, t.mediaConstraints);else if ("preparing-offer" === t.state) {
            if (t.moreIceComing) return;
            t.prevOffer = t.peerConnection.localDescription.sdp, t.prevOffer = t.prevOffer.replace(/a=candidate:.+typ\shost.+\r\n/g, "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n"), t.sendMessage("OFFER", t.prevOffer), t.state = "offer-sent";
          } else if ("offer-received" === t.state) t.peerConnection.createAnswer(function (e) {
            if (t.peerConnection.setLocalDescription(e), t.state = "offer-received-preparing-answer", t.iceStarted) t.markActionNeeded();else {
              var n = new Date();
              o.default.debug("[" + t.clientId + "]" + n.getTime() + ": Starting ICE in responder"), t.iceStarted = !0;
            }
          }, function () {
            o.default.debug("[" + t.clientId + "]Ups! Something went wrong");
          });else if ("offer-received-preparing-answer" === t.state) {
            if (t.moreIceComing) return;
            var e = t.peerConnection.localDescription.sdp;
            t.sendMessage("ANSWER", e), t.state = "established";
          } else t.error("Dazed and confused in state " + t.state + ", stopping here");
          t.actionNeeded = !1;
        }
      }, t.sendOK = function () {
        t.sendMessage("OK");
      }, t.sendMessage = function (e, n) {
        var i = {};
        i.messageType = e, i.sdp = n, "OFFER" === e ? (i.offererSessionId = t.sessionId, i.answererSessionId = t.otherSessionId, i.seq = t.sequenceNumber += 1, i.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (i.offererSessionId = t.incomingMessage.offererSessionId, i.answererSessionId = t.sessionId, i.seq = t.incomingMessage.seq), t.onsignalingmessage(JSON.stringify(i));
      }, t._getSender = function (e) {
        if (t.peerConnection && t.peerConnection.getSenders) {
          var n = t.peerConnection.getSenders().find(function (t) {
            return t.track.kind == e;
          });
          if (n) return n;
        }

        return null;
      }, t.hasSender = function (e) {
        return !!t._getSender(e);
      }, t.replaceTrack = function (e, n, i) {
        var o = t._getSender(e.kind);

        if (!o) return i("NO_SENDER_FOUND");

        try {
          o.replaceTrack(e);
        } catch (e) {
          return i && i(e);
        }

        setTimeout(function () {
          return n && n();
        }, 50);
      }, t.error = function (e) {
        throw "Error in RoapOnJsep: " + e;
      }, t.sessionId = t.roapSessionId += 1, t.sequenceNumber = 0, t.actionNeeded = !1, t.iceStarted = !1, t.moreIceComing = !0, t.iceCandidateCount = 0, t.onsignalingmessage = e.callback, t.peerConnection.ontrack = function (e) {
        t.onaddstream && t.onaddstream(e, "ontrack");
      }, t.peerConnection.onremovestream = function (e) {
        t.onremovestream && t.onremovestream(e);
      }, t.peerConnection.oniceconnectionstatechange = function (e) {
        "connected" === e.currentTarget.iceConnectionState && (t.connectedTime = new Date()), t.oniceconnectionstatechange && t.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      };

      var u = function u(t) {
        var n;

        if (e.video && e.maxVideoBW && (null == (n = t.match(/m=video.*\r\n/)) && (n = t.match(/m=video.*\n/)), n && n.length > 0)) {
          var i = n[0] + "b=TIAS:" + 1e3 * e.maxVideoBW + "\r\n";
          t = t.replace(n[0], i);
        }

        return e.audio && e.maxAudioBW && (null == (n = t.match(/m=audio.*\r\n/)) && (n = t.match(/m=audio.*\n/)), n && n.length > 0) && (i = n[0] + "b=TIAS:" + 1e3 * e.maxAudioBW + "\r\n", t = t.replace(n[0], i)), t;
      };

      return t.onaddstream = null, t.onremovestream = null, t.state = "new", t.markActionNeeded(), t;
    },
        k = function k(e) {
      var t = {},
          n = (mozRTCPeerConnection, mozRTCSessionDescription),
          i = !1;
      t.uid = e.uid, t.isVideoMute = e.isVideoMute, t.isAudioMute = e.isAudioMute, t.isSubscriber = e.isSubscriber, t.clientId = e.clientId, t.pc_config = {
        iceServers: []
      }, e.iceServers instanceof Array ? e.iceServers.map(function (e) {
        0 === e.url.indexOf("stun:") && t.pc_config.iceServers.push({
          url: e.url
        });
      }) : (e.stunServerUrl && (e.stunServerUrl instanceof Array ? e.stunServerUrl.map(function (e) {
        "string" == typeof e && "" !== e && t.pc_config.iceServers.push({
          url: e
        });
      }) : "string" == typeof e.stunServerUrl && "" !== e.stunServerUrl && t.pc_config.iceServers.push({
        url: e.stunServerUrl
      })), e.turnServer && "string" == typeof e.turnServer.url && "" !== e.turnServer.url && (t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.udpport + "?transport=udp"
      }), "string" == typeof e.turnServer.tcpport && "" !== e.turnServer.tcpport && t.pc_config.iceServers.push({
        username: e.turnServer.username,
        credential: e.turnServer.credential,
        credentialType: "password",
        urls: "turn:" + e.turnServer.url + ":" + e.turnServer.tcpport + "?transport=tcp"
      }), !0 === e.turnServer.forceturn && (t.pc_config.iceTransportPolicy = "relay"))), void 0 === e.audio && (e.audio = !0), void 0 === e.video && (e.video = !0), t.mediaConstraints = {
        offerToReceiveAudio: e.audio,
        offerToReceiveVideo: e.video,
        mozDontOfferDataChannel: !0
      }, t.roapSessionId = 103, t.peerConnection = new h.a(t.pc_config), o.default.debug("[" + t.clientId + ']safari Created RTCPeerConnnection with config "' + JSON.stringify(t.pc_config) + '".'), t.peerConnection.onicecandidate = function (e) {
        var n, i, a, r;
        i = (n = t.peerConnection.localDescription.sdp).match(/a=candidate:.+typ\ssrflx.+\r\n/), a = n.match(/a=candidate:.+typ\shost.+\r\n/), r = n.match(/a=candidate:.+typ\srelay.+\r\n/), 0 === t.iceCandidateCount && (t.timeout = setTimeout(function () {
          t.moreIceComing && (t.moreIceComing = !1, t.markActionNeeded());
        }, 1e3)), null === i && null === a && null === r || void 0 !== t.ice || (o.default.debug("[" + t.clientId + "]srflx candidate : " + i + " relay candidate: " + r + " host candidate : " + a), clearTimeout(t.timeout), t.ice = 0, t.moreIceComing = !1, t.markActionNeeded()), t.iceCandidateCount = t.iceCandidateCount + 1;
      }, t.checkMLineReverseInSDP = function (e) {
        return !(!~e.indexOf("m=audio") || !~e.indexOf("m=video")) && e.indexOf("m=audio") > e.indexOf("m=video");
      }, t.reverseMLineInSDP = function (e) {
        var t = e.split("m=audio"),
            n = t[1].split("m=video"),
            i = "m=video" + n[1],
            o = "m=audio" + n[0];
        return e = t[0] + i + o;
      }, t.processSignalingMessage = function (e) {
        var i,
            a = JSON.parse(e);
        t.incomingMessage = a, "new" === t.state ? "OFFER" === a.messageType ? (a.sdp = u(a.sdp), i = {
          sdp: a.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          o.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          o.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        }), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + a.messageType + " in state " + t.state) : "offer-sent" === t.state ? "ANSWER" === a.messageType ? (a.sdp = u(a.sdp), a.sdp = a.sdp.replace(/ generation 0/g, ""), a.sdp = a.sdp.replace(/ udp /g, " UDP "), -1 !== a.sdp.indexOf("a=group:BUNDLE") ? (a.sdp = a.sdp.replace(/a=group:BUNDLE audio video/, "a=group:BUNDLE sdparta_0 sdparta_1"), a.sdp = a.sdp.replace(/a=mid:audio/, "a=mid:sdparta_0"), a.sdp = a.sdp.replace(/a=mid:video/, "a=mid:sdparta_1")) : (a.sdp = a.sdp.replace(/a=mid:audio/, "a=mid:sdparta_0"), a.sdp = a.sdp.replace(/a=mid:video/, "a=mid:sdparta_0")), i = {
          sdp: a.sdp,
          type: "answer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          o.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          o.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e);
        }), t.sendOK(), t.state = "established") : "pr-answer" === a.messageType ? (i = {
          sdp: a.sdp,
          type: "pr-answer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          o.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          o.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        })) : "offer" === a.messageType ? t.error("Not written yet") : t.error("Illegal message for this state: " + a.messageType + " in state " + t.state) : "established" === t.state && ("OFFER" === a.messageType ? (i = {
          sdp: a.sdp,
          type: "offer"
        }, t.peerConnection.setRemoteDescription(new n(i), function () {
          o.default.debug("[" + t.clientId + "]setRemoteDescription succeeded");
        }, function (e) {
          o.default.info("[" + t.clientId + "]setRemoteDescription failed: " + e.name);
        }), t.state = "offer-received", t.markActionNeeded()) : t.error("Illegal message for this state: " + a.messageType + " in state " + t.state));
      };
      var a = {
        id: "",
        type: "",
        mediaType: "opus",
        googCodecName: "opus",
        aecDivergentFilterFraction: "0",
        audioInputLevel: "0",
        bytesSent: "0",
        packetsSent: "0",
        googEchoCancellationReturnLoss: "0",
        googEchoCancellationReturnLossEnhancement: "0"
      },
          r = {
        id: "",
        type: "",
        mediaType: "",
        googCodecName: "h264" === e.codec ? "H264" : "VP8",
        bytesSent: "0",
        packetsLost: "0",
        packetsSent: "0",
        googAdaptationChanges: "0",
        googAvgEncodeMs: "0",
        googEncodeUsagePercent: "0",
        googFirsReceived: "0",
        googFrameHeightSent: "0",
        googFrameHeightInput: "0",
        googFrameRateInput: "0",
        googFrameRateSent: "0",
        googFrameWidthSent: "0",
        googFrameWidthInput: "0",
        googNacksReceived: "0",
        googPlisReceived: "0",
        googRtt: "0"
      },
          s = {
        id: "",
        type: "",
        mediaType: "",
        audioOutputLevel: "0",
        bytesReceived: "0",
        packetsLost: "0",
        packetsReceived: "0",
        googAccelerateRate: "0",
        googCurrentDelayMs: "0",
        googDecodingCNG: "0",
        googDecodingCTN: "0",
        googDecodingCTSG: "0",
        googDecodingNormal: "0",
        googDecodingPLC: "0",
        googDecodingPLCCNG: "0",
        googExpandRate: "0",
        googJitterBufferMs: "0",
        googJitterReceived: "0",
        googPreemptiveExpandRate: "0",
        googPreferredJitterBufferMs: "0",
        googSecondaryDecodedRate: "0",
        googSpeechExpandRate: "0"
      },
          d = {
        id: "",
        type: "",
        mediaType: "",
        googTargetDelayMs: "0",
        packetsLost: "0",
        googDecodeMs: "0",
        googMaxDecodeMs: "0",
        googRenderDelayMs: "0",
        googFrameWidthReceived: "0",
        googFrameHeightReceived: "0",
        googFrameRateReceived: "0",
        googFrameRateDecoded: "0",
        googFrameRateOutput: "0",
        googJitterBufferMs: "0",
        googCurrentDelayMs: "0",
        googMinPlayoutDelayMs: "0",
        googNacksSent: "0",
        googPlisSent: "0",
        googFirsSent: "0",
        bytesReceived: "0",
        packetsReceived: "0",
        googFramesDecoded: "0"
      },
          c = 0;
      t.getVideoRelatedStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          var i = !0,
              o = !1,
              a = void 0;

          try {
            for (var r, s = n.values()[Symbol.iterator](); !(i = (r = s.next()).done); i = !0) {
              var d = r.value;

              if (t.isSubscriber) {
                if (("inbound-rtp" === d.type || "inboundrtp" === d.type) && "video" === d.mediaType) {
                  if (!t.lastReport) return void (t.lastReport = d);
                  e && e({
                    browser: "firefox",
                    mediaType: "video",
                    peerId: t.uid,
                    isVideoMute: t.isVideoMute,
                    frameRateReceived: d.framerateMean + "",
                    frameRateDecoded: d.framesDecoded - t.lastReport.framesDecoded + "",
                    bytesReceived: d.bytesReceived + "",
                    packetsReceived: d.packetsReceived + "",
                    packetsLost: d.packetsLost + ""
                  }), t.lastReport = d;
                }
              } else if (("outbound-rtp" === d.type || "outboundrtp" === d.type) && "video" === d.mediaType) {
                if (!t.lastReport) return void (t.lastReport = d);
                e && e({
                  mediaType: "video",
                  isVideoMute: t.isVideoMute,
                  frameRateInput: d.framerateMean + "",
                  frameRateSent: d.framesEncoded - t.lastReport.framesEncoded + ""
                }), t.lastReport = d;
              }
            }
          } catch (e) {
            o = !0, a = e;
          } finally {
            try {
              i || null == s.return || s.return();
            } finally {
              if (o) throw a;
            }
          }
        });
      }, t.getAudioRelatedStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          var i = !0,
              o = !1,
              a = void 0;

          try {
            for (var r, s = n.values()[Symbol.iterator](); !(i = (r = s.next()).done); i = !0) {
              var d = r.value;
              t.isSubscriber && ("inbound-rtp" !== d.type && "inboundrtp" !== d.type || "audio" !== d.mediaType || e && e({
                browser: "firefox",
                mediaType: "audio",
                peerId: t.uid,
                isAudioMute: t.isAudioMute,
                frameDropped: d.packetsLost + "",
                frameReceived: d.packetsReceived + "",
                googJitterReceived: d.jitter + "",
                bytesReceived: d.bytesReceived + "",
                packetsReceived: d.packetsReceived + "",
                packetsLost: d.packetsLost + ""
              }));
            }
          } catch (e) {
            o = !0, a = e;
          } finally {
            try {
              i || null == s.return || s.return();
            } finally {
              if (o) throw a;
            }
          }
        });
      }, t.getStatsRate = function (e) {
        t.getStats(function (t) {
          t.forEach(function (e) {
            "inbound-rtp" !== e.type && "inboundrtp" !== e.type || "video" !== e.mediaType || e.googFrameRateDecoded && (e.googFrameRateDecoded = ((e.googFramesDecoded - c) / 3).toString(), c = e.googFramesDecoded);
          }), e(t);
        });
      }, t.getStats = function (e) {
        t.peerConnection.getStats().then(function (n) {
          var i = [],
              o = !0,
              c = !1,
              u = void 0;

          try {
            for (var l, p = n.values()[Symbol.iterator](); !(o = (l = p.next()).done); o = !0) {
              var f = l.value;
              i.push(f), "outbound-rtp" !== f.type && "outboundrtp" !== f.type || "video" !== f.mediaType || -1 !== f.id.indexOf("rtcp") || (r.id = f.id, r.type = f.type, r.mediaType = f.mediaType, r.bytesSent = f.bytesSent ? f.bytesSent + "" : "0", r.packetsSent = f.packetsSent ? f.packetsSent + "" : "0", r.googPlisReceived = f.pliCount ? f.pliCount + "" : "0", r.googNacksReceived = f.nackCount ? f.nackCount + "" : "0", r.googFirsReceived = f.firCount ? f.firCount + "" : "0", r.googFrameRateSent = f.framerateMean ? f.framerateMean + "" : "0"), "outbound-rtp" !== f.type && "outboundrtp" !== f.type || "audio" !== f.mediaType || -1 !== f.id.indexOf("rtcp") || (a.id = f.id, a.type = f.type, a.mediaType = f.mediaType, a.bytesSent = f.bytesSent ? f.bytesSent + "" : "0", a.packetsSent = f.packetsSent ? f.packetsSent + "" : "0"), "inbound-rtp" !== f.type && "inboundrtp" !== f.type || "audio" !== f.mediaType || f.isRemote || -1 !== f.id.indexOf("rtcp") || (s.id = f.id, s.type = f.type, s.mediaType = f.mediaType, s.bytesReceived = f.bytesReceived ? f.bytesReceived + "" : "0", s.packetsLost = f.packetsLost ? f.packetsLost + "" : "0", s.packetsReceived = f.packetsReceived ? f.packetsReceived + "" : "0", s.googJitterReceived = f.jitter ? f.jitter + "" : "0"), "inbound-rtp" !== f.type && "inboundrtp" !== f.type || "video" !== f.mediaType || f.isRemote || -1 !== f.id.indexOf("rtcp") || (d.id = f.id, d.type = f.type, d.mediaType = f.mediaType, d.bytesReceived = f.bytesReceived ? f.bytesReceived + "" : "0", d.googFrameRateReceived = f.framerateMean ? f.framerateMean + "" : "0", d.googFramesDecoded = f.framesDecoded ? f.framesDecoded + "" : "0", d.packetsLost = f.packetsLost ? f.packetsLost + "" : "0", d.packetsReceived = f.packetsReceived ? f.packetsReceived + "" : "0", d.googJitterBufferMs = f.jitter ? f.jitter + "" : "0", d.googNacksSent = f.nackCount ? f.nackCount + "" : "0", d.googPlisSent = f.pliCount ? f.pliCount + "" : "0", d.googFirsSent = f.firCount ? f.firCount + "" : "0"), -1 !== f.id.indexOf("outbound_rtcp_video") && (r.packetsLost = f.packetsLost ? f.packetsLost + "" : "0");
            }
          } catch (e) {
            c = !0, u = e;
          } finally {
            try {
              o || null == p.return || p.return();
            } finally {
              if (c) throw u;
            }
          }

          var m = [r, a, s, d];
          m.push({
            id: "time",
            startTime: t.connectedTime,
            timestamp: new Date()
          }), e(m, i);
        }, function (e) {
          o.default.error("[" + t.clientId + "]" + e);
        });
      }, t.addStream = function (e) {
        i = !0, t.peerConnection.addStream(e), t.markActionNeeded();
      }, t.removeStream = function () {
        t.markActionNeeded();
      }, t.close = function () {
        t.state = "closed", t.peerConnection.close();
      }, t.markActionNeeded = function () {
        t.actionNeeded = !0, t.doLater(function () {
          t.onstablestate();
        });
      }, t.doLater = function (e) {
        window.setTimeout(e, 1);
      }, t.onstablestate = function () {
        if (t.actionNeeded) {
          if ("new" === t.state || "established" === t.state) i && (t.mediaConstraints = void 0), t.peerConnection.createOffer(function (e) {
            if (e.sdp = u(e.sdp), e.sdp = e.sdp.replace(/a=extmap:1 http:\/\/www.webrtc.org\/experiments\/rtp-hdrext\/abs-send-time/, "a=extmap:3 http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"), e.sdp !== t.prevOffer) return t.peerConnection.setLocalDescription(e), t.state = "preparing-offer", void t.markActionNeeded();
            o.default.debug("[" + t.clientId + "]Not sending a new offer");
          }, function (e) {
            o.default.debug("[" + t.clientId + "]Ups! create offer failed ", e);
          }, t.mediaConstraints);else if ("preparing-offer" === t.state) {
            if (t.moreIceComing) return;
            t.prevOffer = t.peerConnection.localDescription.sdp, t.prevOffer = t.prevOffer.replace(/a=candidate:.+typ\shost.+\r\n/g, "a=candidate:2243255435 1 udp 2122194687 192.168.0.1 30000 typ host generation 0 network-id 1\r\n"), t.sendMessage("OFFER", t.prevOffer), t.state = "offer-sent";
          } else if ("offer-received" === t.state) t.peerConnection.createAnswer(function (e) {
            if (t.peerConnection.setLocalDescription(e), t.state = "offer-received-preparing-answer", t.iceStarted) t.markActionNeeded();else {
              var n = new Date();
              o.default.debug("[" + t.clientId + "]" + n.getTime() + ": Starting ICE in responder"), t.iceStarted = !0;
            }
          }, function () {
            o.default.debug("[" + t.clientId + "]Ups! Something went wrong");
          });else if ("offer-received-preparing-answer" === t.state) {
            if (t.moreIceComing) return;
            var e = t.peerConnection.localDescription.sdp;
            t.sendMessage("ANSWER", e), t.state = "established";
          } else t.error("Dazed and confused in state " + t.state + ", stopping here");
          t.actionNeeded = !1;
        }
      }, t.sendOK = function () {
        t.sendMessage("OK");
      }, t.sendMessage = function (e, n) {
        var i = {};
        i.messageType = e, i.sdp = n, "OFFER" === e ? (i.offererSessionId = t.sessionId, i.answererSessionId = t.otherSessionId, i.seq = t.sequenceNumber += 1, i.tiebreaker = Math.floor(429496723 * Math.random() + 1)) : (i.offererSessionId = t.incomingMessage.offererSessionId, i.answererSessionId = t.sessionId, i.seq = t.incomingMessage.seq), t.onsignalingmessage(JSON.stringify(i));
      }, t._getSender = function (e) {
        if (t.peerConnection && t.peerConnection.getSenders) {
          var n = t.peerConnection.getSenders().find(function (t) {
            return t.track.kind == e;
          });
          if (n) return n;
        }

        return null;
      }, t.hasSender = function (e) {
        return !!t._getSender(e);
      }, t.replaceTrack = function (e, n, i) {
        var o = t._getSender(e.kind);

        if (!o) return i("NO_SENDER_FOUND");

        try {
          o.replaceTrack(e);
        } catch (e) {
          return i && i(e);
        }

        setTimeout(function () {
          return n && n();
        }, 50);
      }, t.error = function (e) {
        throw "Error in RoapOnJsep: " + e;
      }, t.sessionId = t.roapSessionId += 1, t.sequenceNumber = 0, t.actionNeeded = !1, t.iceStarted = !1, t.moreIceComing = !0, t.iceCandidateCount = 0, t.onsignalingmessage = e.callback, t.peerConnection.ontrack = function (e) {
        t.onaddstream && t.onaddstream(e, "ontrack");
      }, t.peerConnection.onremovestream = function (e) {
        t.onremovestream && t.onremovestream(e);
      }, t.peerConnection.oniceconnectionstatechange = function (e) {
        "connected" === e.currentTarget.iceConnectionState && (t.connectedTime = new Date()), t.oniceconnectionstatechange && t.oniceconnectionstatechange(e.currentTarget.iceConnectionState);
      };

      var u = function u(t) {
        var n;

        if (e.video && e.maxVideoBW && (null == (n = t.match(/m=video.*\r\n/)) && (n = t.match(/m=video.*\n/)), n && n.length > 0)) {
          var i = n[0] + "b=TIAS:" + 1e3 * e.maxVideoBW + "\r\n";
          t = t.replace(n[0], i);
        }

        return e.audio && e.maxAudioBW && (null == (n = t.match(/m=audio.*\r\n/)) && (n = t.match(/m=audio.*\n/)), n && n.length > 0) && (i = n[0] + "b=TIAS:" + 1e3 * e.maxAudioBW + "\r\n", t = t.replace(n[0], i)), t;
      };

      return t.onaddstream = null, t.onremovestream = null, t.state = "new", t.markActionNeeded(), t;
    },
        M = null,
        P = function P() {
      try {
        M = window.require("electron");
      } catch (e) {}

      return M;
    },
        L = function L(e) {
      var t = a.b.reportApiInvoke(null, {
        callback: e,
        name: "getScreenSources",
        options: arguments,
        tag: "tracer"
      }),
          n = P();
      if (!n) return t && t("electron is null");
      n.desktopCapturer.getSources({
        types: ["window", "screen"]
      }, function (e, n) {
        if (e) return t && t(e);
        t && t(null, n);
      });
    },
        x = function x(e, t, n) {
      var i = t.attributes.width;
      t = {
        audio: !1,
        video: {
          mandatory: {
            chromeMediaSource: "desktop",
            chromeMediaSourceId: e,
            maxHeight: t.attributes.height,
            maxWidth: i,
            maxFrameRate: t.attributes.maxFr,
            minFrameRate: t.attributes.minFr
          }
        }
      };
      navigator.webkitGetUserMedia(t, function (e) {
        n && n(null, e);
      }, function (e) {
        n && n(e);
      });
    },
        V = function V() {
      return !!P();
    },
        F = L,
        B = x,
        U = function U(e, t) {
      L(function (n, i) {
        if (n) return t && t(n);
        !function (e, t) {
          var n = document.createElement("div");
          n.innerText = "share screen", n.setAttribute("style", "text-align: center; height: 25px; line-height: 25px; border-radius: 4px 4px 0 0; background: #D4D2D4; border-bottom:  solid 1px #B9B8B9;");
          var i = document.createElement("div");
          i.setAttribute("style", "width: 100%; height: 500px; padding: 15px 25px ; box-sizing: border-box;");
          var o = document.createElement("div");
          o.innerText = "Agora Web Screensharing wants to share the contents of your screen with webdemo.agorabeckon.com. Choose what you'd like to share.", o.setAttribute("style", "height: 12%;");
          var a = document.createElement("div");
          a.setAttribute("style", "width: 100%; height: 80%; background: #FFF; border:  solid 1px #CBCBCB; display: flex; flex-wrap: wrap; justify-content: space-around; overflow-y: scroll; padding: 0 15px; box-sizing: border-box;");
          var r = document.createElement("div");
          r.setAttribute("style", "text-align: right; padding: 16px 0;");
          var s = document.createElement("button");
          s.innerHTML = "cancel", s.setAttribute("style", "width: 85px;"), s.onclick = function () {
            document.body.removeChild(d), t && t("NotAllowedError");
          }, r.appendChild(s), i.appendChild(o), i.appendChild(a), i.appendChild(r);
          var d = document.createElement("div");
          d.setAttribute("style", "position: absolute; z-index: 99999999; top: 50%; left: 50%; width: 620px; height: 525px; background: #ECECEC; border-radius: 4px; -webkit-transform: translate(-50%,-50%); transform: translate(-50%,-50%);"), d.appendChild(n), d.appendChild(i), document.body.appendChild(d), e.map(function (e) {
            if (e.id) {
              var n = document.createElement("div");
              n.setAttribute("style", "width: 30%; height: 160px; padding: 20px 0; text-align: center;box-sizing: content-box;"), n.innerHTML = '<div style="height: 120px; display: table-cell; vertical-align: middle;"><img style="width: 100%; background: #333333; box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 0.2);" src=' + e.thumbnail.toDataURL() + ' /></div><span style="\theight: 40px; line-height: 40px; display: inline-block; width: 70%; word-break: keep-all; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">' + e.name + "</span>", n.onclick = function () {
                document.body.removeChild(d), t && t(null, e.id);
              }, a.appendChild(n);
            }
          });
        }(i, function (n, i) {
          if (n) return t && t(n);
          x(i, e, t);
        });
      });
    },
        j = 103,
        W = function W(e) {
      var t = {};
      if (t.clientId = e.clientId, e.session_id = j += 1, "undefined" != typeof window && window.navigator) {
        if (null !== window.navigator.userAgent.match("Firefox")) t.browser = "mozilla", t = p.getBrowserVersion() >= 66 ? k(e) : D(e);else if ("iOS" === p.getBrowserOS() || p.isSafari()) o.default.debug("[" + t.streamId + "][" + t.clientId + "]Safari"), (t = N(e)).browser = "safari";else if (window.navigator.userAgent.indexOf("MSIE ")) (t = C(e)).browser = "ie";else if (window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] >= 26) (t = C(e)).browser = "chrome-stable";else {
          if (!(window.navigator.userAgent.toLowerCase().indexOf("chrome") >= 40)) throw t.browser = "none", "WebRTC stack not available";
          (t = O(e)).browser = "chrome-canary";
        }
      } else o.default.error("[" + t.streamId + "][" + t.clientId + "]Publish/subscribe video/audio streams not supported yet"), t = w(e);
      return t;
    },
        H = function H(e, t, n) {
      var i = {};

      if (i.config = e, i.streamId = e.streamId, navigator.getMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia, e.screen) {
        if (V()) return e.sourceId ? B(e.sourceId, e, function (e, i) {
          if (e) return n && n();
          t && t(i);
        }) : U(e, function (e, i) {
          if (e) return n && n();
          t && t(i);
        });

        if (o.default.debug("[" + i.streamId + "]Screen access requested"), null !== window.navigator.userAgent.match("Firefox")) {
          e.mediaSource = e.mediaSource || "screen";
          if (!~["screen", "window", "application"].indexOf(e.mediaSource)) return n && n("Invalid mediaSource, mediaSource should be one of [screen, window, application]");
          if (!e.attributes) return n && n("Share screen attributes is null");
          var a = {};
          a.video = {
            frameRate: {
              ideal: e.attributes.mxaFr,
              max: e.attributes.mxaFr
            },
            height: {
              ideal: e.attributes.height
            },
            width: {
              ideal: e.attributes.width
            },
            mediaSource: e.mediaSource
          }, navigator.getMedia(a, t, n);
        } else if (null !== window.navigator.userAgent.match("Chrome")) {
          if (window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] < 34) return void n({
            code: "This browser does not support screen sharing"
          });
          var r = "okeephmleflklcdebijnponpabbmmgeo";
          if (e.extensionId) o.default.debug("[" + i.streamId + "]extensionId supplied, using " + e.extensionId), r = e.extensionId;else if (window.navigator.mediaDevices.getDisplayMedia) {
            var s = {
              video: {
                height: {
                  ideal: e.attributes.height
                },
                width: {
                  ideal: e.attributes.width
                },
                frameRate: {
                  ideal: e.attributes.maxFr,
                  max: e.attributes.maxFr
                }
              }
            };
            return o.default.debug("use getDisplayMedia, config.attributes:", e.attributes), o.default.debug("use getDisplayMedia, constraints:", s), window.navigator.mediaDevices.getDisplayMedia(s).then(function (e) {
              t && t(e);
            }).catch(n);
          }
          o.default.debug("[" + i.streamId + "]Screen access on chrome stable, looking for extension");

          try {
            chrome.runtime.sendMessage(r, {
              getStream: !0
            }, function (r) {
              if (void 0 !== r) {
                var s = r.streamId,
                    d = e.attributes.width,
                    c = e.attributes.height,
                    u = e.attributes.maxFr,
                    l = e.attributes.minFr;
                a = {
                  video: {
                    mandatory: {
                      chromeMediaSource: "desktop",
                      chromeMediaSourceId: s,
                      maxHeight: c,
                      maxWidth: d,
                      maxFrameRate: u,
                      minFrameRate: l
                    }
                  }
                }, navigator.getMedia(a, t, n);
              } else {
                o.default.error("[" + i.streamId + "]No response from Chrome Plugin. Plugin not installed properly");
                n({
                  name: "PluginNotInstalledProperly",
                  message: "No response from Chrome Plugin. Plugin not installed properly."
                });
              }
            });
          } catch (e) {
            o.default.debug("[" + i.streamId + "]AgoraRTC screensharing plugin is not accessible");
            return void n({
              code: "no_plugin_present"
            });
          }
        } else o.default.debug("[" + i.streamId + "]This browser does not support screenSharing");
      } else window.navigator.userAgent.indexOf("Safari") > -1 && -1 === navigator.userAgent.indexOf("Chrome") ? navigator.mediaDevices.getUserMedia(e).then(t).catch(n) : "undefined" != typeof navigator && navigator.getMedia ? navigator.getMedia(e, t, n) : o.default.error("[" + i.streamId + "]Video/audio streams not supported yet");
    },
        G = n(7),
        J = function J(e, t, n) {
      if (["End2EndDelay", "TransportDelay", "PacketLossRate", "RecvLevel", "RecvBitrate", "CodecType", "MuteState", "TotalFreezeTime", "TotalPlayDuration", "RecordingLevel", "SendLevel", "SamplingRate", "SendBitrate", "CodecType", "MuteState", "End2EndDelay", "TransportDelay", "PacketLossRate", "RecvBitrate", "RecvResolutionWidth", "RecvResolutionHeight", "RenderResolutionHeight", "RenderResolutionWidth", "RenderFrameRate", "TotalFreezeTime", "TotalPlayDuration", "TargetSendBitrate", "SendFrameRate", "SendFrameRate", "SendBitrate", "SendResolutionWidth", "SendResolutionHeight", "CaptureResolutionHeight", "CaptureResolutionWidth", "EncodeDelay", "MuteState", "TotalFreezeTime", "TotalDuration", "CaptureFrameRate", "RTT", "OutgoingAvailableBandwidth", "Duration", "UserCount", "SendBytes", "RecvBytes", "SendBitrate", "RecvBitrate", "accessDelay", "audioSendBytes", "audioSendPackets", "videoSendBytes", "videoSendPackets", "videoSendPacketsLost", "videoSendFrameRate", "audioSendPacketsLost", "videoSendResolutionWidth", "videoSendResolutionHeight", "accessDelay", "audioReceiveBytes", "audioReceivePackets", "audioReceivePacketsLost", "videoReceiveBytes", "videoReceivePackets", "videoReceivePacketsLost", "videoReceiveFrameRate", "videoReceiveDecodeFrameRate", "videoReceiveResolutionWidth", "videoReceiveResolutionHeight", "endToEndDelay", "videoReceiveDelay", "audioReceiveDelay", "FirstFrameTime", "VideoFreezeRate", "AudioFreezeRate", "RenderResolutionWidth", "RenderResolutionHeight"].indexOf(t) > -1 && ("string" == typeof n || isFinite(n))) return e[t] = "" + n;
    },
        z = n(10),
        K = new function () {
      var e = r();
      return e.devicesHistory = {}, e.states = {
        UNINIT: "UNINIT",
        INITING: "INITING",
        INITED: "INITED"
      }, e.state = e.states.UNINIT, e.deviceStates = {
        ACTIVE: "ACTIVE",
        INACTIVE: "INACTIVE"
      }, e.deviceReloadTimer = null, e._init = function (t, n) {
        e.state = e.states.INITING, e.devicesHistory = {}, e._reloadDevicesInfo(function () {
          e.state = e.states.INITED, e.dispatchEvent({
            type: "inited"
          }), t && t();
        }, function (t) {
          o.default.warning("Device Detection functionality cannot start properly."), e.state = e.states.UNINIT, n && n(t);
        });
      }, e._enumerateDevices = function (e, t) {
        if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) return o.default.warning("enumerateDevices() not supported."), t && t("enumerateDevices() not supported");
        navigator.mediaDevices.enumerateDevices().then(function (t) {
          e && setTimeout(function () {
            e(t);
          }, 0);
        }).catch(function (e) {
          t && t(e);
        });
      }, e._reloadDevicesInfo = function (t, n) {
        var i = [];

        e._enumerateDevices(function (n) {
          var a = Date.now();

          for (var r in n.forEach(function (t) {
            var n = e.devicesHistory[t.deviceId];

            if ((n ? n.state : e.deviceStates.INACTIVE) != e.deviceStates.ACTIVE) {
              var o = n || {
                initAt: a
              };
              o.device = t, o.state = e.deviceStates.ACTIVE, i.push(o), e.devicesHistory[t.deviceId] = o;
            }

            e.devicesHistory[t.deviceId].lastReloadAt = a;
          }), e.devicesHistory) {
            var s = e.devicesHistory[r];
            s && s.state == e.deviceStates.ACTIVE && s.lastReloadAt !== a && (s.state = e.deviceStates.INACTIVE, i.push(s)), s.lastReloadAt = a;
          }

          e.state == e.states.INITED && i.forEach(function (t) {
            var n = I()({}, t);

            switch (t.device.kind) {
              case "audioinput":
                n.type = "recordingDeviceChanged";
                break;

              case "audiooutput":
                n.type = "playoutDeviceChanged";
                break;

              case "videoinput":
                n.type = "cameraChanged";
                break;

              default:
                o.default.warning("Unknown device change", n), n.type = "unknownDeviceChanged";
            }

            e.dispatchEvent(n);
          }), t && t();
        }, n);
      }, e.getDeviceById = function (t, n, i) {
        e.getDevices(function (e) {
          for (var o = 0; o < e.length; o++) {
            var a = e[o];
            if (a && a.deviceId === t) return n && n(a);
          }

          return i && i();
        });
      }, e.searchDeviceNameById = function (t) {
        var n = e.devicesHistory[t];
        return n ? n.device.label || n.device.deviceId : null;
      }, e.getDevices = function (t, n) {
        e._enumerateDevices(t, function (e) {
          n && n(e.name + ": " + e.message);
        });
      }, e.getVideoCameraIdByLabel = function (t, n, i) {
        e.getCameras(function (e) {
          var o = !0,
              a = !1,
              r = void 0;

          try {
            for (var s, d = e[Symbol.iterator](); !(o = (s = d.next()).done); o = !0) {
              var c = s.value;
              if (c.label === t) return n && n(c.deviceId);
            }
          } catch (e) {
            a = !0, r = e;
          } finally {
            try {
              o || null == d.return || d.return();
            } finally {
              if (a) throw r;
            }
          }

          return i && i(A.NOT_FIND_DEVICE_BY_LABEL);
        }, i);
      }, e.getRecordingDevices = function (t, n) {
        return e._enumerateDevices(function (e) {
          var n = e.filter(function (e) {
            return "audioinput" == e.kind;
          });
          t && t(n);
        }, function (e) {
          n && n(e);
        });
      }, e.getPlayoutDevices = function (t, n) {
        return e._enumerateDevices(function (e) {
          var n = e.filter(function (e) {
            return "audiooutput" == e.kind;
          });
          t && t(n);
        }, function (e) {
          n && n(e);
        });
      }, e.getCameras = function (t, n) {
        return e._enumerateDevices(function (e) {
          var n = e.filter(function (e) {
            return "videoinput" == e.kind;
          });
          t && t(n);
        }, function (e) {
          n && n(e);
        });
      }, e._init(function () {
        navigator.mediaDevices && navigator.mediaDevices.addEventListener && navigator.mediaDevices.addEventListener("devicechange", function () {
          e._reloadDevicesInfo();
        }), e.deviceReloadTimer = setInterval(e._reloadDevicesInfo, 5e3);
      }), e;
    }(),
        Y = function Y(e, t, n) {
      for (var i = 0; i < n.length; i++) {
        if (e === n[i]) return !0;
      }

      throw new Error("".concat(t, " can only be set as ").concat(JSON.stringify(n)));
    },
        q = function q(e, t) {
      if (!e) throw new Error("Invalid param: ".concat(t || "param", " cannot be empty"));
      if ("object" !== v()(e)) throw new Error("".concat(t || "This paramter", " is of the object type"));
      return !0;
    },
        Q = function Q(e, t, n, i, o) {
      if (re(n) && (n = 1), i = i || 255, re(o) && (o = !0), re(e)) throw new Error("".concat(t || "param", " cannot be empty"));
      if (!Z(e, n, i, o)) throw new Error("Invalid ".concat(t || "string param", ": Length of the string: [").concat(n, ",").concat(i, "].").concat(o ? " ASCII characters only." : ""));
    },
        X = function X(e, t, n, i) {
      if (re(n) && (n = 1), i = i || 1e4, re(e)) throw new Error("".concat(t || "param", " cannot be empty"));
      if (!ee(e, n, i)) throw new Error("Invalid ".concat(t || "number param", ": The value range is [").concat(n, ",").concat(i, "]. integer only"));
    },
        $ = function $(e, t) {
      if (re(e)) throw new Error("".concat(t || "param", " cannot be empty"));
      if (!te(e)) throw new Error("Invalid ".concat(t || "boolean param", ": The value is of the boolean type."));
    },
        Z = function Z(e, t, n, i) {
      return t || (t = 0), n || (n = Number.MAX_SAFE_INTEGER), re(i) && (i = !0), ae(e) && (!i || ie(e)) && e.length >= t && e.length <= n;
    },
        ee = function ee(e, t, n) {
      return oe(e) && e >= t && e <= n;
    },
        te = function te(e) {
      return "boolean" == typeof e;
    },
        ne = function ne(e) {
      return Z(e, 1, 2047);
    },
        ie = function ie(e) {
      if ("string" == typeof e) {
        for (var t = 0; t < e.length; t++) {
          var n = e.charCodeAt(t);
          if (n < 0 || n > 255) return !1;
        }

        return !0;
      }
    },
        oe = function oe(e) {
      return "number" == typeof e && e % 1 == 0;
    },
        ae = function ae(e) {
      return "string" == typeof e;
    },
        re = function re(e) {
      return null == e;
    };

    var se = function se(e) {
      var t = r();
      if (t.params = I()({}, e), t.stream = e.stream, t.url = e.url, t.onClose = void 0, t.local = !1, t.videoSource = e.videoSource, t.audioSource = e.audioSource, t.video = !!e.video, t.audio = !!e.audio, t.screen = !!e.screen, t.screenAttributes = {
        width: 1920,
        height: 1080,
        maxFr: 5,
        minFr: 1
      }, t.videoSize = e.videoSize, t.player = void 0, t.audioLevelHelper = null, e.attributes = e.attributes || {}, t.attributes = e.attributes, t.microphoneId = e.microphoneId, t.cameraId = e.cameraId, t.inSwitchDevice = !1, t.userMuteVideo = !1, t.userMuteAudio = !1, t.peerMuteVideo = !1, t.peerMuteAudio = !1, t.lowStream = null, t.videoWidth = 0, t.videoHeight = 0, t.streamId = null, t.streamId = e.streamID, t.userId = null, t.mirror = !1 !== e.mirror, t.DTX = e.audioProcessing && e.audioProcessing.DTX, t.audioProcessing = e.audioProcessing, t.highQuality = !1, t.stereo = !1, t.speech = !1, t.screen || delete t.screen, !(void 0 === t.videoSize || t.videoSize instanceof Array && 4 === t.videoSize.length)) throw Error("Invalid Video Size");

      function n(e, t) {
        return {
          width: {
            ideal: e
          },
          height: {
            ideal: t
          }
        };
      }

      t.videoSize = [640, 480, 640, 480], void 0 !== e.local && !0 !== e.local || (t.local = !0), t.initialized = !t.local, function (e) {
        e.audioMixing = {
          audioContextInited: !1,
          defaultVolume: 100,
          inEarMonitoring: "FILE",
          sounds: {},
          states: {
            IDLE: "IDLE",
            STARTING: "STARTING",
            BUSY: "BUSY",
            PAUSED: "PAUSED"
          },
          inEarMonitoringModes: {
            NONE: "NONE",
            FILE: "FILE",
            MICROPHONE: "MOCROPHONE",
            ALL: "ALL"
          },
          ctx: null,
          mediaStreamSource: null,
          mediaStreamDest: null,
          buffer: {}
        }, e._initSoundIfNotExists = function (t, n) {
          e.audioMixing.sounds[t] || (e.audioMixing.sounds[t] = {
            soundId: t,
            state: "IDLE",
            muted: e.userMuteAudio,
            filePath: n,
            volume: e.audioMixing.defaultVolume,
            startAt: null,
            startOffset: null,
            pauseAt: null,
            pauseOffset: null,
            resumeAt: null,
            resumeOffset: null,
            stopAt: null,
            options: null,
            source: null
          });
        }, e._initSoundIfNotExists(-1), e.loadAudioBuffer = function (t, n, i) {
          var r = a.b.reportApiInvoke(e.sid, {
            callback: i,
            name: "Stream.loadAudioBuffer",
            options: arguments,
            tag: "tracer"
          });
          Q(n, "url", 1, 1024, !1), Q(t, "id", 1, 1024, !1);
          var s = new XMLHttpRequest();
          s.open("GET", n, !0), s.responseType = "arraybuffer", s.onload = function () {
            if (s.status > 400) {
              var n = s.statusText;
              return o.default.error("[".concat(e.streamId, "] loadAudioBuffer Failed: ") + n), r(n);
            }

            var i = s.response;
            e.audioMixing.audioContextInited || e._initAudioContext(), e.audioMixing.ctx.decodeAudioData(i, function (n) {
              e.audioMixing.buffer[t] = n, r(null);
            }, function (t) {
              o.default.error("[".concat(e.streamId, "] decodeAudioData Failed: "), t), r(t);
            });
          }, s.send();
        }, e.createAudioBufferSource = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            name: "Stream.createAudioBufferSource",
            options: arguments,
            tag: "tracer"
          });

          if (e.audioMixing.buffer[t.id]) {
            var i = e.audioMixing.buffer[t.id],
                r = e.audioMixing.ctx.createBufferSource();
            r.buffer = i;
            var s = e.audioMixing.ctx.createGain();
            if (r.connect(s), s.connect(e.audioMixing.mediaStreamDest), r.gainNode = s, t.loop) r.loop = !0, r.start(0, t.playTime / 1e3);else if (t.cycle > 1) {
              if (Object(p.isChrome)()) {
                r.loop = !0;
                var d = t.cycle * i.duration * 1e3 - (t.playTime || 0);
                r.start(0, t.playTime / 1e3, d / 1e3);
              } else o.default.warning("[".concat(e.streamId, "] Cycle Param is ignored by current browser")), r.start(0, t.playTime / 1e3);
            } else r.start(0, t.playTime / 1e3);
            var c = e.audioMixing.sounds[t.soundId];
            return c.source = r, e._flushAudioMixingMuteStatus(), r.addEventListener("ended", function () {
              r === c.source && e.dispatchEvent({
                type: "audioSourceEnded",
                soundId: t.soundId,
                source: r,
                sound: c
              });
            }), n(), r;
          }

          return o.default.error("[".concat(e.streamId, "] "), "AUDIOBUFFER_NOT_FOUND", t.id), n(!1), !1;
        }, e.on("audioSourceEnded", function (t) {
          t.source;
          var n = t.sound;
          n && n.state === e.audioMixing.states.BUSY && !n.pauseAt && (n.state = e.audioMixing.states.IDLE, n.startAt = null, n.startOffset = null, n.resumeAt = null, n.resumeOffset = null, e.audioMixing.mediaStreamSource.connect(e.audioMixing.mediaStreamDest));
        }), e.clearAudioBufferSource = function () {
          e.audioBufferSource.forEach(function (e) {
            e.stop();
          });
        }, e._isSoundExists = function (t) {
          return !!e.audioMixing.sounds[t.soundId] || (o.default.error("SoundId not exists. #".concat(t.soundId)), !1);
        }, e._initAudioContext = function () {
          if (e.audioMixing.audioContextInited) throw new Error("Failed to init audio context. Already inited");
          if (!e.stream) throw new Error("Failed to init audio context. Local Stream not initialized");
          e.audioMixing.ctx = Object(z.a)(), e.audioMixing.mediaStreamSource = e.audioMixing.ctx.createMediaStreamSource(e.stream), e.audioMixing.mediaStreamDest = e.audioMixing.ctx.createMediaStreamDestination(), e.audioMixing.mediaStreamSource.connect(e.audioMixing.mediaStreamDest);
          var t = e.stream.getVideoTracks()[0];

          if (t && e.audioMixing.mediaStreamDest.stream.addTrack(t), e._isAudioMuted() ? (e._unmuteAudio(), e.stream = e.audioMixing.mediaStreamDest.stream, e._muteAudio()) : e.stream = e.audioMixing.mediaStreamDest.stream, e.audioLevelHelper = null, e.pc && e.pc.peerConnection && e.pc.peerConnection) {
            var n = (e.pc.peerConnection && e.pc.peerConnection.getSenders()).find(function (e) {
              return e && e.track && "audio" == e.track.kind;
            }),
                i = e.audioMixing.mediaStreamDest.stream.getAudioTracks()[0];
            n && n.replaceTrack && i && n.replaceTrack(i);
          }

          e.audioMixing.audioContextInited = !0;
        }, e._reloadInEarMonitoringMode = function (t) {
          if (t) {
            if (!e.audioMixing.inEarMonitoringModes[t]) return o.default.error("[".concat(e.streamId, "] Invalid InEarMonitoringMode ").concat(t));
            e.audioMixing.inEarMonitoring = t;
          }

          switch (e.audioMixing.audioContextInited || e._initAudioContext(), e.audioMixing.inEarMonitoring) {
            case e.audioMixing.inEarMonitoringModes.FILE:
              e.audioMixing.mediaStreamSource.connectedToDestination && (e.audioMixing.mediaStreamSource.disconnect(e.audioMixing.ctx.destination), e.audioMixing.mediaStreamSource.connectedToDestination = !1);

            case e.audioMixing.inEarMonitoringModes.ALL:
              for (var n in e.audioMixing.sounds) {
                var i = e.audioMixing.sounds[n];
                i && i.source && !i.source.connectedToDestination && (i.source.gainNode.connect(e.audioMixing.ctx.destination), i.source.connectedToDestination = !0);
              }

          }

          switch (e.audioMixing.inEarMonitoring) {
            case e.audioMixing.inEarMonitoringModes.MICROPHONE:
              e.audioMixing.source.forEach(function (t) {
                t.connectedToDestination && (t.gainNode.disconnect(e.audioMixing.ctx.destination), t.connectedToDestination = !1);
              });

            case e.audioMixing.inEarMonitoringModes.ALL:
              e.audioMixing.mediaStreamSource.connectedToDestination || (e.audioMixing.mediaStreamSource.connect(e.audioMixing.ctx.destination), e.audioMixing.mediaStreamSource.connectedToDestination = !0);
          }
        }, e._startAudioMixingBufferSource = function (t) {
          e.audioMixing.audioContextInited || e._initAudioContext();
          var n = {
            soundId: t.soundId,
            id: t.filePath,
            loop: t.loop,
            cycle: t.cycle,
            playTime: t.playTime || 0
          },
              i = t.replace,
              o = e.createAudioBufferSource(n);
          return o.sound = e.audioMixing.sounds[t.soundId], o ? (o.addEventListener("ended", e._audioMixingFinishedListener, {
            once: !0
          }), e._reloadInEarMonitoringMode(), i && e.audioMixing.mediaStreamSource.disconnect(e.audioMixing.mediaStreamDest), o) : null;
        }, e._stopAudioMixingBufferSource = function (t) {
          var n = e.audioMixing.sounds[t.soundId].source;
          return n ? (n.removeEventListener("ended", e._audioMixingFinishedListener), e.audioMixing.mediaStreamSource.connect(e.audioMixing.mediaStreamDest), n.stop(), n) : null;
        }, e._flushAudioMixingMuteStatus = function (t) {
          for (var n in e.audioMixing.sounds) {
            var i = e.audioMixing.sounds[n];
            i && (void 0 !== t && (i.muted = !!t), i.source && (i.muted ? i.source.gainNode.gain.value = 0 : i.source.gainNode.gain.value = i.volume / 100));
          }
        }, e._handleAudioMixingInvalidStateError = function (t, n, i) {
          var a = e.audioMixing.sounds[n.soundId],
              r = -1 === n.soundId ? "INVALID_AUDIO_MIXING_STATE" : "INVALID_PLAY_EFFECT_STATE";
          o.default.error("[".concat(e.streamId, "] Cannot ").concat(t, ": ").concat(r, ", state is ").concat(a.state)), i && i(r);
        }, e._handleAudioMixingNoSourceError = function (t, n, i) {
          e.audioMixing.sounds[n.soundId].state = e.audioMixing.states.IDLE;
          var a = -1 === n.soundId ? "NO_AUDIO_MIXING_SOURCE" : "NO_EFFECT_SOURCE";
          o.default.error("[".concat(e.streamId, "] Cannot ").concat(t, ": ").concat(a)), i && i(a);
        }, e._getOneEffectStates = function (t) {
          var n = e.audioMixing.sounds[t.soundId];
          return function () {
            return n ? {
              state: n.state,
              startAt: n.startAt,
              resumeAt: n.resumeAt,
              pauseOffset: n.pauseOffset,
              pauseAt: n.pauseAt,
              resumeOffset: n.resumeOffset,
              stopAt: n.stopAt,
              duration: e._getOneEffectDuration(t),
              position: e._getOneEffectCurrentPosition(t)
            } : {};
          };
        }, e._audioMixingFinishedListener = function () {
          var t = this.sound;
          t.state === e.audioMixing.states.IDLE && e.audioMixing.buffer[t.options.filePath] && !t.options.cacheResource && (o.default.debug("Recycled buffer ".concat(t.options.filePath)), delete e.audioMixing.buffer[t.options.filePath]), -1 === t.soundId && e.dispatchEvent({
            type: "audioMixingFinished"
          });
        }, e._playOneEffect = function (t, n) {
          q(t, "options");
          var i = t.soundId,
              a = (t.filePath, t.cacheResource);

          if (t.cycle, t.loop, t.playTime, t.replace, Object(p.isSafari)() && Object(p.getBrowserVersion)() < 12) {
            var r = "BROWSER_NOT_SUPPORT";
            return o.default.error("[".concat(e.streamId, "] Cannot _playOneEffect: "), r), n(r);
          }

          e.audioMixing.audioContextInited || e._initAudioContext(), e._initSoundIfNotExists(i);
          var s = e.audioMixing.sounds[i];

          if (s.state === e.audioMixing.states.IDLE) {
            if (void 0 !== t.cycle && !t.cycle > 0) return r = "Invalid Parmeter cycle: " + t.cycle, o.default.error("[".concat(e.streamId, "] ").concat(i), r), n(r);

            if (re(a) && (t.cacheResource = !0), s.state = e.audioMixing.states.STARTING, s.options = t, e.audioMixing.buffer[t.filePath]) {
              var d = e._startAudioMixingBufferSource(t);

              if (d) return s.source = d, s.startAt = Date.now(), s.resumeAt = null, s.pauseOffset = null, s.pauseAt = null, s.resumeOffset = null, s.stopAt = null, s.startOffset = t.playTime || 0, s.state = e.audioMixing.states.BUSY, e._flushAudioMixingMuteStatus(), n(null);
              s.state = e.audioMixing.states.IDLE;
              var c = "CREATE_BUFFERSOURCE_FAILED";
              if (n) return n(c);
              o.default.error("[".concat(e.streamId, "] "), c);
            } else e.loadAudioBuffer(t.filePath, t.filePath, function (i) {
              if (i) s.state = e.audioMixing.states.IDLE, n ? n(i) : o.default.error("[".concat(e.streamId, "] "), i);else {
                var a = e._startAudioMixingBufferSource(t);

                if (a) return s.source = a, s.startAt = Date.now(), s.resumeAt = null, s.pauseOffset = null, s.pauseAt = null, s.resumeOffset = null, s.stopAt = null, s.startOffset = t.playTime || 0, s.state = e.audioMixing.states.BUSY, e._flushAudioMixingMuteStatus(), n(null);
                if (s.state = e.audioMixing.states.IDLE, i = "CREATE_BUFFERSOURCE_FAILED", n) return n(i);
                o.default.error("[".concat(e.streamId, "] "), i);
              }
            });
          } else e._handleAudioMixingInvalidStateError("_playEffect", t, n);
        }, e._stopOneEffect = function (t, n) {
          var i = e.audioMixing.sounds[t.soundId];
          return e._isSoundExists(t) ? i.state === e.audioMixing.states.BUSY || i.state === e.audioMixing.states.PAUSED ? (e._stopAudioMixingBufferSource(t), i.stopAt = Date.now(), i.state = e.audioMixing.states.IDLE, e.audioMixing.buffer[i.options.filePath] && !i.options.cacheResource && (o.default.debug("Recycled buffer ".concat(i.options.filePath)), delete e.audioMixing.buffer[i.options.filePath]), void (n && n(null))) : void e._handleAudioMixingInvalidStateError("_stopOneEffect", t, n) : n("SOUND_NOT_EXISTS");
        }, e._pauseOneEffect = function (t, n) {
          var i = e.audioMixing.sounds[t.soundId];
          if (i.state === e.audioMixing.states.BUSY) return e._stopAudioMixingBufferSource(t) ? (i.pauseAt = Date.now(), i.state = e.audioMixing.states.PAUSED, i.resumeAt ? i.pauseOffset = i.pauseAt - i.resumeAt + i.resumeOffset : i.pauseOffset = i.pauseAt - i.startAt + i.startOffset, n && n(null)) : void e._handleAudioMixingNoSourceError("_pauseOneEffect", t, n);

          e._handleAudioMixingInvalidStateError("_pauseOneEffect", t, n);
        }, e._resumeOneEffect = function (t, n) {
          var i = e.audioMixing.sounds[t.soundId];

          if (i.state === e.audioMixing.states.PAUSED) {
            var a = {
              soundId: t.soundId,
              filePath: i.options.filePath,
              cycle: i.options.cycle,
              loop: i.options.loop,
              playTime: i.pauseOffset,
              replace: i.options.replace
            },
                r = e._startAudioMixingBufferSource(a);

            if (!r) {
              var s = "CREATE_BUFFERSOURCE_FAILED";
              return n(s), void o.default.error("[".concat(e.streamId, "] "), s);
            }

            i.source = r, i.resumeAt = Date.now(), i.resumeOffset = i.pauseOffset, i.state = e.audioMixing.states.BUSY, i.pauseAt = null, i.pauseOffset = null, n(null);
          } else e._handleAudioMixingInvalidStateError("_resumeOneEffect", t, n);
        }, e._getOneEffectDuration = function (t) {
          var n = e.audioMixing.sounds[t.soundId];
          return n.options && n.options.filePath && e.audioMixing.buffer[n.options.filePath] ? 1e3 * e.audioMixing.buffer[n.options.filePath].duration : null;
        }, e._getOneEffectCurrentPosition = function (t, n) {
          var i = e.audioMixing.sounds[t.soundId];
          return i.state === e.audioMixing.states.PAUSED ? i.pauseOffset % e._getOneEffectDuration(t) : i.state === e.audioMixing.states.BUSY ? (Date.now() - i.startAt + i.startOffset) % e._getOneEffectDuration(t) : void (n && e._handleAudioMixingInvalidStateError("_getOneEffectCurrentPosition", t));
        }, e._setOneEffectPosition = function (t, n, i) {
          var a = e.audioMixing.sounds[t.soundId];

          if (a.state === e.audioMixing.states.BUSY) {
            if (!e._stopAudioMixingBufferSource(t)) return void e._handleAudioMixingNoSourceError("_setOneEffectPosition", t, i);

            var r = {
              soundId: t.soundId,
              filePath: a.options.filePath,
              loop: a.options.loop,
              cycle: a.options.cycle,
              playTime: n
            },
                s = e._startAudioMixingBufferSource(r);

            if (!s) {
              var d = "CREATE_BUFFERSOURCE_FAILED";
              return i && i(d), void o.default.error("[".concat(e.streamId, "] "), d);
            }

            a.source = s, a.startAt = Date.now(), a.startOffset = n, a.resumeAt = null, a.resumeOffset = null, a.pauseOffset = null, a.pauseAt = null;
          } else {
            if (a.state !== e.audioMixing.states.PAUSED) return void e._handleAudioMixingInvalidStateError("_setOneEffectPosition", t, i);
            a.pauseOffset = n;
          }

          i && i(null);
        }, e.startAudioMixing = function (t, n) {
          var o = a.b.reportApiInvoke(e.sid, {
            callback: function callback(t) {
              if (t) return n && n(t);
              e.dispatchEvent({
                type: "audioMixingPlayed"
              }), n && n(null);
            },
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.startAudioMixing",
            options: t
          });
          q(t, "options");
          var r = t.filePath,
              s = t.cacheResource,
              d = t.cycle,
              c = t.loop,
              u = t.playTime,
              l = t.replace;
          Q(r, "filePath", 1, Object(i.getParameter)("FILEPATH_LENMAX"), !1), X(u, "playTime", 0, 1e8), !re(d) && X(d, "cycle"), !re(c) && $(c, "loop"), !re(l) && $(l, "replace"), !re(s) && $(s, "cacheResource");
          var p = I()({
            soundId: -1
          }, t);

          e._playOneEffect(p, o);
        }, e.stopAudioMixing = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.stopAudioMixing"
          });

          e._stopOneEffect({
            soundId: -1
          }, n);
        }, e.pauseAudioMixing = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.pauseAudioMixing"
          });
          return e._pauseOneEffect({
            soundId: -1
          }, n);
        }, e.resumeAudioMixing = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: function callback(n, i) {
              if (n) return t && t(n);
              e.dispatchEvent({
                type: "audioMixingPlayed"
              }), t && t(null);
            },
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.resumeAudioMixing"
          });

          e._resumeOneEffect({
            soundId: -1
          }, n);
        }, e.adjustAudioMixingVolume = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.adjustAudioMixingVolume",
            options: arguments,
            tag: "tracer"
          });
          X(t, "volume", 0, 100), e.audioMixing.sounds[-1].volume = t, e._flushAudioMixingMuteStatus(), n();
        }, e.getAudioMixingDuration = function () {
          var t = a.b.reportApiInvoke(e.sid, {
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.getAudioMixingDuration"
          }),
              n = e._getOneEffectDuration({
            soundId: -1
          });

          return t(null, n), n;
        }, e.getAudioMixingCurrentPosition = function () {
          var t = a.b.reportApiInvoke(e.sid, {
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.getAudioMixingCurrentPosition"
          }),
              n = e._getOneEffectCurrentPosition({
            soundId: -1
          }, !0);

          return t(null, n), n;
        }, e.setAudioMixingPosition = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            options: arguments,
            tag: "tracer",
            getStates: e._getOneEffectStates({
              soundId: -1
            }),
            name: "Stream.setAudioMixingPosition"
          });
          X(t, "position", 0, 1e8), e._setOneEffectPosition({
            soundId: -1
          }, t, i);
        }, e.playEffect = function (t, n) {
          var o = a.b.reportApiInvoke(e.sid, {
            callback: function callback(t) {
              if (t) return n && n(t);
              e.dispatchEvent({
                type: "effectPlayed"
              }), n && n(null);
            },
            name: "Stream.playEffect",
            options: t
          });
          q(t, "options");
          var r = t.soundId,
              s = t.filePath,
              d = t.cycle;
          X(r, "soundId", 1, 1e4), Q(s, "filePath", 0, Object(i.getParameter)("FILEPATH_LENMAX"), !1), !re(d) && X(d, "cycle"), e._playOneEffect(t, o);
        }, e.stopEffect = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            getStates: e._getOneEffectStates({
              soundId: t
            }),
            name: "Stream.stopEffect"
          });
          X(t, "soundId", 1, 1e4), e._stopOneEffect({
            soundId: t
          }, i);
        }, e.stopAllEffects = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            name: "Stream.stopAllEffect"
          }),
              i = !1,
              o = 0,
              r = 0,
              s = function s(e) {
            i || (e ? (n(e), i = !0) : o += 1, o === r && (n(null), i = !0));
          };

          for (var d in e.audioMixing.sounds) {
            var c = e.audioMixing.sounds[d];
            -1 !== c.soundId && (c.state !== e.audioMixing.states.BUSY && c.state !== e.audioMixing.states.PAUSED || (r++, e._stopOneEffect({
              soundId: d
            }, s)));
          }

          r || n(null);
        }, e.preloadEffect = function (t, n, o) {
          var r = a.b.reportApiInvoke(e.sid, {
            callback: o,
            options: arguments,
            tag: "tracer",
            name: "Stream.preloadEffect"
          });
          X(t, "soundId", 1, 1e4), Q(n, "filePath", 1, Object(i.getParameter)("FILEPATH_LENMAX"), !1), e._initSoundIfNotExists(t, n), e.audioMixing.buffer[n] ? r(null) : e.loadAudioBuffer(n, n, r);
        }, e.unloadEffect = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            options: arguments,
            tag: "tracer",
            name: "Stream.unloadEffect"
          });
          X(t, "soundId", 1, 1e4);
          var r = e.audioMixing.sounds[t];

          if (!r) {
            var s = "SOUND_NOT_EXISTS";
            return o.default.error(s, t), void i(s);
          }

          var d = r.options ? r.options.filePath : r.filePath;
          if (d) delete e.audioMixing.buffer[d], delete e.audioMixing.sounds[t], i(null);else {
            var c = "SOUND_BUFFER_NOT_FOUND";
            o.default.error(c, t), i(c);
          }
        }, e.pauseEffect = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            options: arguments,
            tag: "tracer",
            name: "Stream.pauseEffect"
          });
          return e._pauseOneEffect({
            soundId: t
          }, i);
        }, e.pauseAllEffects = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            name: "Stream.pauseAllEffects"
          }),
              i = !1,
              o = 0,
              r = 0,
              s = function s(e) {
            i || (e ? (n(e), i = !0) : o += 1, o === r && (n(null), i = !0));
          };

          for (var d in e.audioMixing.sounds) {
            "-1" !== d && e.audioMixing.sounds[d].state === e.audioMixing.states.BUSY && (r++, e._pauseOneEffect({
              soundId: d
            }, s));
          }

          r || n(null);
        }, e.resumeEffect = function (t, n) {
          X(t, "soundId", 1, 1e4);
          var i = a.b.reportApiInvoke(e.sid, {
            callback: n,
            options: arguments,
            tag: "tracer",
            name: "Stream.resumeEffect"
          });
          return e._resumeOneEffect({
            soundId: t
          }, i);
        }, e.resumeAllEffects = function (t) {
          var n = a.b.reportApiInvoke(e.sid, {
            callback: t,
            name: "Stream.resumeAllEffects"
          }),
              i = !1,
              o = 0,
              r = 0,
              s = function s(e) {
            i || (e ? (n(e), i = !0) : o += 1, o === r && (n(null), i = !0));
          };

          for (var d in e.audioMixing.sounds) {
            "-1" !== d && e.audioMixing.sounds[d].state === e.audioMixing.states.PAUSED && (r++, e._resumeOneEffect({
              soundId: d
            }, s));
          }

          r || n(null);
        }, e.getEffectsVolume = function () {
          var t = [];

          for (var n in e.audioMixing.sounds) {
            var i = e.audioMixing.sounds[n];
            i && "-1" !== n && t.push({
              soundId: parseInt(n),
              volume: i.volume
            });
          }

          return t;
        }, e.setEffectsVolume = function (t, n) {
          var i = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setEffectsVolume",
            options: arguments,
            tag: "tracer",
            callback: n
          });

          for (var o in X(t, "volume", 0, 100), e.audioMixing.defaultVolume = t, e.audioMixing.sounds) {
            var r = e.audioMixing.sounds[o];
            "-1" !== o && (r.volume = t);
          }

          e._flushAudioMixingMuteStatus(), i(null);
        }, e.setVolumeOfEffect = function (t, n, i) {
          var o = a.b.reportApiInvoke(e.sid, {
            name: "Stream.setVolumeOfEffect",
            options: arguments,
            tag: "tracer",
            callback: i
          });
          X(t, "soundId", 0, 1e4), X(n, "volume", 0, 100), e._initSoundIfNotExists(t), e.audioMixing.sounds[t].volume = n, e._flushAudioMixingMuteStatus(), o(null);
        };
      }(t), t.on("collectStats", function (e) {
        e.promises.push(t._getPCStats()), e.promises.push(new Promise(function (e) {
          var n = {};
          t.pc && t.pc.isSubscriber ? null !== window.navigator.userAgent.match("Firefox") && (J(n, "videoReceiveResolutionHeight", t.videoHeight), J(n, "videoReceiveResolutionWidth", t.videoWidth)) : t.pc && !t.pc.isSubscriber && ((Object(p.isSafari)() || Object(p.isFireFox)()) && (J(n, "videoSendResolutionHeight", t.videoHeight), J(n, "videoSendResolutionWidth", t.videoWidth)), (Object(p.isSafari)() || Object(p.isFireFox)()) && t.uplinkStats && J(n, "videoSendPacketsLost", t.uplinkStats.uplink_cumulative_lost)), e(n);
        })), e.promises.push(new Promise(function (e) {
          var n = {};
          return t.traffic_stats && t.pc && t.pc.isSubscriber ? (J(n, "accessDelay", t.traffic_stats.access_delay), J(n, "endToEndDelay", t.traffic_stats.e2e_delay), J(n, "videoReceiveDelay", t.traffic_stats.video_delay), J(n, "audioReceiveDelay", t.traffic_stats.audio_delay)) : t.traffic_stats && t.pc && !t.pc.isSubscriber && J(n, "accessDelay", t.traffic_stats.access_delay), e(n);
        }));
      });
      var s = {
        true: !0,
        unspecified: !0,
        "90p_1": n(160, 90),
        "120p_1": n(160, 120),
        "120p_3": n(120, 120),
        "120p_4": n(212, 120),
        "180p_1": n(320, 180),
        "180p_3": n(180, 180),
        "180p_4": n(240, 180),
        "240p_1": n(320, 240),
        "240p_3": n(240, 240),
        "240p_4": n(424, 240),
        "360p_1": n(640, 360),
        "360p_3": n(360, 360),
        "360p_4": n(640, 360),
        "360p_6": n(360, 360),
        "360p_7": n(480, 360),
        "360p_8": n(480, 360),
        "360p_9": n(640, 360),
        "360p_10": n(640, 360),
        "360p_11": n(640, 360),
        "480p_1": n(640, 480),
        "480p_2": n(640, 480),
        "480p_3": n(480, 480),
        "480p_4": n(640, 480),
        "480p_6": n(480, 480),
        "480p_8": n(848, 480),
        "480p_9": n(848, 480),
        "480p_10": n(640, 480),
        "720p_1": n(1280, 720),
        "720p_2": n(1280, 720),
        "720p_3": n(1280, 720),
        "720p_5": n(960, 720),
        "720p_6": n(960, 720),
        "1080p_1": n(1920, 1080),
        "1080p_2": n(1920, 1080),
        "1080p_3": n(1920, 1080),
        "1080p_5": n(1920, 1080),
        "1440p_1": n(2560, 1440),
        "1440p_2": n(2560, 1440),
        "4k_1": n(3840, 2160),
        "4k_3": n(3840, 2160)
      };
      return t.setVideoResolution = function (n) {
        var i = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setVideoResolution",
          options: arguments,
          tag: "tracer"
        });
        return void 0 !== s[n += ""] ? (e.video = s[n], e.attributes = e.attributes || {}, e.attributes.resolution = n, i(), !0) : (i(), !1);
      }, t.setVideoFrameRate = function (n) {
        var i = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setVideoFrameRate",
          options: arguments,
          tag: "tracer"
        });
        return Object(p.isFireFox)() ? (i(), !1) : "object" === v()(n) && n instanceof Array && n.length > 1 ? (e.attributes = e.attributes || {}, e.attributes.minFrameRate = n[0], e.attributes.maxFrameRate = n[1], i(), !0) : (i(), !1);
      }, t.setVideoBitRate = function (n) {
        var i = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setVideoBitRate",
          options: arguments,
          tag: "tracer"
        });
        return "object" === v()(n) && n instanceof Array && n.length > 1 ? (e.attributes = e.attributes || {}, e.attributes.minVideoBW = n[0], e.attributes.maxVideoBW = n[1], t.connectionSpec && (t.connectionSpec.minVideoBW = n[0], t.connectionSpec.maxVideoBW = n[1]), i(), !0) : (i(), !1);
      }, t.setScreenBitRate = function (n) {
        var i = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setScreenBitRate",
          options: arguments,
          tag: "tracer"
        });
        return "object" === v()(n) && n instanceof Array && n.length > 1 ? (e.screenAttributes = e.screenAttributes || {}, e.screenAttributes.minVideoBW = n[0], e.screenAttributes.maxVideoBW = n[1], i(), !0) : (i(), !1);
      }, t.setScreenProfile = function (e) {
        var n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setScreenProfile",
          options: arguments,
          tag: "tracer"
        });

        if (Y(e, "profile", ["480p_1", "480p_2", "720p_1", "720p_2", "1080p_1", "1080p_2"]), "string" == typeof e && t.screen) {
          switch (e) {
            case "480p_1":
              t.screenAttributes.width = 640, t.screenAttributes.height = 480, t.screenAttributes.maxFr = 5, t.screenAttributes.minFr = 1;
              break;

            case "480p_2":
              t.screenAttributes.width = 640, t.screenAttributes.height = 480, t.screenAttributes.maxFr = 30, t.screenAttributes.minFr = 25;
              break;

            case "720p_1":
              t.screenAttributes.width = 1280, t.screenAttributes.height = 720, t.screenAttributes.maxFr = 5, t.screenAttributes.minFr = 1;
              break;

            case "720p_2":
              t.screenAttributes.width = 1280, t.screenAttributes.height = 720, t.screenAttributes.maxFr = 30, t.screenAttributes.minFr = 25;
              break;

            case "1080p_1":
              t.screenAttributes.width = 1920, t.screenAttributes.height = 1080, t.screenAttributes.maxFr = 5, t.screenAttributes.minFr = 1;
              break;

            case "1080p_2":
              t.screenAttributes.width = 1920, t.screenAttributes.height = 1080, t.screenAttributes.maxFr = 30, t.screenAttributes.minFr = 25;
          }

          return n(), !0;
        }

        return n(), !1;
      }, t.setVideoProfileCustom = function (e) {
        var n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setVideoProfileCustom",
          options: arguments,
          tag: "tracer"
        });
        t.setVideoResolution(e[0]), t.setVideoFrameRate([e[1], e[1]]), t.setVideoBitRate([e[2], e[2]]), n();
      }, t.setVideoProfileCustomPlus = function (i) {
        var o = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setVideoProfileCustom",
          options: arguments,
          tag: "tracer"
        });
        e.video = n(i.width, i.height), e.attributes = e.attributes || {}, e.attributes.resolution = "".concat(i.width, "x").concat(i.height), t.setVideoFrameRate([i.framerate, i.framerate]), t.setVideoBitRate([i.bitrate, i.bitrate]), o();
      }, t.setVideoProfile = function (e) {
        var n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setVideoProfile",
          options: arguments,
          tag: "tracer"
        });

        if (Y(e, "profile", ["480p_1", "480p_2", "720p_1", "720p_2", "1080p_1", "1080p_2", "120p", "120P", "120p_1", "120P_1", "120p_3", "120P_3", "180p", "180P", "180p_1", "180P_1", "180p_3", "180P_3", "180p_4", "180P_4", "240p", "240P", "240p_1", "240P_1", "240p_3", "240P_3", "240p_4", "240P_4", "360p", "360P", "360p_1", "360P_1", "360p_3", "360P_3", "360p_4", "360P_4", "360p_6", "360P_6", "360p_7", "360P_7", "360p_8", "360P_8", "360p_9", "360P_9", "360p_10", "360P_10", "360p_11", "360P_11", "480p", "480P", "480p_1", "480P_1", "480p_2", "480P_2", "480p_3", "480P_3", "480p_4", "480P_4", "480p_6", "480P_6", "480p_8", "480P_8", "480p_9", "480P_9", "480p_10", "480P_10", "720p", "720P", "720p_1", "720P_1", "720p_2", "720P_2", "720p_3", "720P_3", "720p_5", "720P_5", "720p_6", "720P_6", "1080p", "1080P", "1080p_1", "1080P_1", "1080p_2", "1080P_2", "1080p_3", "1080P_3", "1080p_5", "1080P_5", "1440p", "1440P", "1440p_1", "1440P_1", "1440p_2", "1440P_2", "4k", "4K", "4k_1", "4K_1", "4k_3", "4K_3"]), t.profile = e, "string" == typeof e && t.video) {
          switch (e) {
            case "120p":
            case "120P":
            case "120p_1":
            case "120P_1":
              t.setVideoResolution("120p_1"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([30, 65]);
              break;

            case "120p_3":
            case "120P_3":
              t.setVideoResolution("120p_3"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([30, 50]);
              break;

            case "180p":
            case "180P":
            case "180p_1":
            case "180P_1":
              t.setVideoResolution("180p_1"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([30, 140]);
              break;

            case "180p_3":
            case "180P_3":
              t.setVideoResolution("180p_3"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([30, 100]);
              break;

            case "180p_4":
            case "180P_4":
              t.setVideoResolution("180p_4"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([30, 120]);
              break;

            case "240p":
            case "240P":
            case "240p_1":
            case "240P_1":
              t.setVideoResolution("240p_1"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([40, 200]);
              break;

            case "240p_3":
            case "240P_3":
              t.setVideoResolution("240p_3"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([40, 140]);
              break;

            case "240p_4":
            case "240P_4":
              t.setVideoResolution("240p_4"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([40, 220]);
              break;

            case "360p":
            case "360P":
            case "360p_1":
            case "360P_1":
              t.setVideoResolution("360p_1"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([80, 400]);
              break;

            case "360p_3":
            case "360P_3":
              t.setVideoResolution("360p_3"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([80, 260]);
              break;

            case "360p_4":
            case "360P_4":
              t.setVideoResolution("360p_4"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([80, 600]);
              break;

            case "360p_6":
            case "360P_6":
              t.setVideoResolution("360p_6"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([80, 400]);
              break;

            case "360p_7":
            case "360P_7":
              t.setVideoResolution("360p_7"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([80, 320]);
              break;

            case "360p_8":
            case "360P_8":
              t.setVideoResolution("360p_8"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([80, 490]);
              break;

            case "360p_9":
            case "360P_9":
              t.setVideoResolution("360p_9"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([80, 800]);
              break;

            case "360p_10":
            case "360P_10":
              t.setVideoResolution("360p_10"), t.setVideoFrameRate([24, 24]), t.setVideoBitRate([80, 800]);
              break;

            case "360p_11":
            case "360P_11":
              t.setVideoResolution("360p_11"), t.setVideoFrameRate([24, 24]), t.setVideoBitRate([80, 1e3]);
              break;

            case "480p":
            case "480P":
            case "480p_1":
            case "480P_1":
              t.setVideoResolution("480p_1"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([20, 500]);
              break;

            case "480p_2":
            case "480P_2":
              t.setVideoResolution("480p_2"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([100, 1e3]);
              break;

            case "480p_3":
            case "480P_3":
              t.setVideoResolution("480p_3"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([100, 400]);
              break;

            case "480p_4":
            case "480P_4":
              t.setVideoResolution("480p_4"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([100, 750]);
              break;

            case "480p_6":
            case "480P_6":
              t.setVideoResolution("480p_6"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([100, 600]);
              break;

            case "480p_8":
            case "480P_8":
              t.setVideoResolution("480p_8"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([100, 610]);
              break;

            case "480p_9":
            case "480P_9":
              t.setVideoResolution("480p_9"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([100, 930]);
              break;

            case "480p_10":
            case "480P_10":
              t.setVideoResolution("480p_10"), t.setVideoFrameRate([10, 10]), t.setVideoBitRate([100, 400]);
              break;

            case "720p":
            case "720P":
            case "720p_1":
            case "720P_1":
              t.setVideoResolution("720p_1"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([120, 1130]);
              break;

            case "720p_2":
            case "720P_2":
              t.setVideoResolution("720p_2"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([120, 2e3]);
              break;

            case "720p_3":
            case "720P_3":
              t.setVideoResolution("720p_3"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([120, 1710]);
              break;

            case "720p_5":
            case "720P_5":
              t.setVideoResolution("720p_5"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([120, 910]);
              break;

            case "720p_6":
            case "720P_6":
              t.setVideoResolution("720p_6"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([120, 1380]);
              break;

            case "1080p":
            case "1080P":
            case "1080p_1":
            case "1080P_1":
              t.setVideoResolution("1080p_1"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([120, 2080]);
              break;

            case "1080p_2":
            case "1080P_2":
              t.setVideoResolution("1080p_2"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([120, 3e3]);
              break;

            case "1080p_3":
            case "1080P_3":
              t.setVideoResolution("1080p_3"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([120, 3150]);
              break;

            case "1080p_5":
            case "1080P_5":
              t.setVideoResolution("1080p_5"), t.setVideoFrameRate([60, 60]), t.setVideoBitRate([120, 4780]);
              break;

            case "1440p":
            case "1440P":
            case "1440p_1":
            case "1440P_1":
              t.setVideoResolution("1440p_1"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([120, 4850]);
              break;

            case "1440p_2":
            case "1440P_2":
              t.setVideoResolution("1440p_2"), t.setVideoFrameRate([60, 60]), t.setVideoBitRate([120, 7350]);
              break;

            case "4k":
            case "4K":
            case "4k_1":
            case "4K_1":
              t.setVideoResolution("4k_1"), t.setVideoFrameRate([30, 30]), t.setVideoBitRate([120, 8910]);
              break;

            case "4k_3":
            case "4K_3":
              t.setVideoResolution("4k_3"), t.setVideoFrameRate([60, 60]), t.setVideoBitRate([120, 13500]);
              break;

            default:
              t.setVideoResolution("480p_1"), t.setVideoFrameRate([15, 15]), t.setVideoBitRate([100, 500]);
          }

          return n(), !0;
        }

        return n(), !1;
      }, t.setAudioProfile = function (e) {
        var n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setAudioProfile",
          options: arguments,
          tag: "tracer"
        });

        if (Y(e, "profile", ["speech_low_quality", "speech_standard", "music_standard", "standard_stereo", "high_quality", "high_quality_stereo"]), t.audioProfile = e, "string" == typeof e && t.audio) {
          switch (e) {
            case "speech_low_quality":
              t.highQuality = !1, t.stereo = !1, t.speech = !0, t.lowQuality = !0;
              break;

            case "speech_standard":
              t.highQuality = !1, t.stereo = !1, t.speech = !0, t.lowQuality = !1;
              break;

            case "music_standard":
              t.highQuality = !1, t.stereo = !1, t.speech = !1, t.lowQuality = !1;
              break;

            case "standard_stereo":
              t.highQuality = !1, t.stereo = !0, t.speech = !1, t.lowQuality = !1;
              break;

            case "high_quality":
              t.highQuality = !0, t.stereo = !1, t.speech = !1, t.lowQuality = !1;
              break;

            case "high_quality_stereo":
              t.highQuality = !0, t.stereo = !0, t.speech = !1, t.lowQuality = !1;
              break;

            default:
              t.highQuality = !1, t.stereo = !1, t.speech = !1, t.lowQuality = !1;
          }

          return n(), !0;
        }

        return n(), !1;
      }, t.getId = function () {
        return t.streamId;
      }, t.getUserId = function () {
        return t.userId;
      }, t.setUserId = function (e) {
        var n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setUserId",
          options: arguments,
          tag: "tracer"
        });
        t.userId && o.default.warning("[".concat(t.streamId, "] Stream.userId ").concat(t.userId, " => ").concat(e)), t.userId = e, n();
      }, t.getAttributes = function () {
        return e.screen ? t.screenAttributes : e.attributes;
      }, t.hasAudio = function () {
        return t.audio;
      }, t.hasVideo = function () {
        return t.video;
      }, t.hasScreen = function () {
        return t.screen;
      }, t.isVideoOn = function () {
        return (t.hasVideo() || t.hasScreen()) && !t.userMuteVideo;
      }, t.isAudioOn = function () {
        return t.hasAudio() && !t.userMuteAudio;
      }, t.init = function (n, i) {
        var r = a.b.reportApiInvoke(t.sid, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Stream.init",
          options: arguments,
          tag: "tracer"
        }),
            s = (new Date().getTime(), arguments[2]);
        if (void 0 === s && (s = 2), !0 === t.initialized) return r({
          type: "warning",
          msg: "STREAM_ALREADY_INITIALIZED"
        });
        if (!0 !== t.local) return r({
          type: "warning",
          msg: "STREAM_NOT_LOCAL"
        });

        if (t.videoSource ? t.videoName = "videoSource" : t.video && (t.videoName = K.searchDeviceNameById(e.cameraId) || "default"), t.audioSource ? t.audioName = "audioSource" : t.audio && (t.audioName = K.searchDeviceNameById(e.microphoneId) || "default"), t.screen && (t.screenName = e.extensionId || "default"), t.videoSource || t.audioSource) {
          var d = new MediaStream();
          return t.videoSource && (o.default.debug("[".concat(t.streamId, "] Added videoSource")), d.addTrack(t.videoSource), t.video = !0), t.audioSource && (o.default.debug("[".concat(t.streamId, "] Added audioSource")), d.addTrack(t.audioSource), t.audio = !0), t.hasVideo() ? Object(G.h)(d, function (e, n) {
            o.default.info("[".concat(t.streamId, "] Video Source width ").concat(e, " height ").concat(n)), t.stream = d, t.initialized = !0, r();
          }, function (e) {
            o.default.warning("[".concat(t.streamId, "] Failed to get width & height from video source"), e), t.stream = d, t.initialized = !0, r();
          }) : (t.stream = d, t.initialized = !0, r());
        }

        try {
          if ((e.audio || e.video || e.screen) && void 0 === e.url) {
            o.default.debug("[".concat(t.streamId, "] Requested access to local media"));
            var c = e.video;
            if (e.screen) var u = {
              video: c,
              audio: !1,
              screen: !0,
              data: !0,
              extensionId: e.extensionId,
              attributes: t.screenAttributes,
              fake: e.fake,
              mediaSource: e.mediaSource,
              sourceId: e.sourceId,
              streamId: t.streamId
            };else {
              u = {
                video: c,
                audio: e.audio,
                fake: e.fake,
                streamId: t.streamId
              };

              if (!(null !== window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./) && window.navigator.appVersion.match(/Chrome\/([\w\W]*?)\./)[1] <= 35)) {
                var l = 30,
                    f = 30;

                if (void 0 !== e.attributes.minFrameRate && (l = e.attributes.minFrameRate), void 0 !== e.attributes.maxFrameRate && (f = e.attributes.maxFrameRate), !0 === u.audio) {
                  u.audio = !e.microphoneId || {
                    deviceId: {
                      exact: e.microphoneId
                    }
                  };
                  var m = {};
                  t.audioProcessing && (void 0 !== t.audioProcessing.AGC && (Object(p.isFireFox)() ? m.autoGainControl = t.audioProcessing.AGC : Object(p.isChrome)() && (m.googAutoGainControl = t.audioProcessing.AGC, m.googAutoGainControl2 = t.audioProcessing.AGC)), void 0 !== t.audioProcessing.AEC && (m.echoCancellation = t.audioProcessing.AEC), void 0 !== t.audioProcessing.ANS && (Object(p.isFireFox)() ? m.noiseSuppression = t.audioProcessing.ANS : Object(p.isChrome)() && (m.googNoiseSuppression = t.audioProcessing.ANS))), t.stereo && Object(p.isChrome)() && (m.googAutoGainControl = !1, m.googAutoGainControl2 = !1, m.echoCancellation = !1, m.googNoiseSuppression = !1), 0 !== Object.keys(m).length && (!0 === u.audio ? u.audio = {
                    mandatory: m
                  } : u.audio = I()(u.audio, m));
                }

                !0 === u.video ? (u.video = {
                  width: {
                    ideal: t.videoSize[0]
                  },
                  height: {
                    ideal: t.videoSize[1]
                  },
                  frameRate: {
                    ideal: l,
                    max: f
                  }
                }, t.setVideoBitRate([500, 500]), u.video.deviceId = e.cameraId ? {
                  exact: e.cameraId
                } : void 0) : "object" === v()(u.video) && (u.video.frameRate = {
                  ideal: l,
                  max: f
                }, u.video.deviceId = e.cameraId ? {
                  exact: e.cameraId
                } : void 0);
              }
            }
            o.default.debug("[".concat(t.streamId, "] "), u);
            var g = I()({}, u);

            if (t.constraints = u, H(g, function (n) {
              t.screenAudioTrack && n.addTrack(t.screenAudioTrack);
              var i = n.getVideoTracks().length > 0,
                  a = n.getAudioTracks().length > 0;
              return g.video && !i && g.audio && !a ? (o.default.error("[".concat(t.streamId, "] Media access: NO_CAMERA_MIC_PERMISSION")), r("NO_CAMERA_MIC_PERMISSION")) : g.video && !i ? (o.default.error("[".concat(t.streamId, "] Media access: NO_CAMERA_PERMISSION")), r("NO_CAMERA_PERMISSION")) : g.screen && !i ? (o.default.error("[".concat(t.streamId, "] Media access: NO_SCREEN_PERMISSION")), r("NO_SCREEN_PERMISSION")) : g.audio && !a ? (o.default.error("[".concat(t.streamId, "] Media access: NO_MIC_PERMISSION")), r("NO_MIC_PERMISSION")) : (o.default.debug("[".concat(t.streamId, "] User has granted access to local media")), t.dispatchEvent({
                type: "accessAllowed"
              }), t.stream = n, t.initialized = !0, e.screen && e.audio && !t.screenAudioTrack || r(), t.hasVideo() && Object(G.h)(n, function (e, n) {
                t.videoWidth = e, t.videoHeight = n;
              }, function (e) {
                o.default.warning("[".concat(t.streamId, "] vsResHack failed: "), e);
              }), void (e.screen && Object(p.isChrome)() && t.stream && t.stream.getVideoTracks()[0] && (t.stream.getVideoTracks()[0].onended = function () {
                t.dispatchEvent({
                  type: "stopScreenSharing"
                });
              })));
            }, function (e) {
              var n = {
                type: "error",
                msg: e.name || e.code || e,
                info: null
              };

              switch (e && (e.message && (n.info = e.message), e.code && (n.info ? n.info += ". " + e.code : n.info = " " + e.code), e.constraint && (n.info ? n.info += ". Constraint: " + e.constraint : n.info = "constraint: " + e.constraint)), n.msg) {
                case "Starting video failed":
                case "TrackStartError":
                  if (t.videoSize = void 0, s > 0) return void setTimeout(function () {
                    t.init(function (e) {
                      return r(e);
                    }, r, s - 1);
                  }, 1);
                  n.msg = "MEDIA_OPTION_INVALID";
                  break;

                case "DevicesNotFoundError":
                  n.msg = "DEVICES_NOT_FOUND";
                  break;

                case "NotSupportedError":
                  n.msg = "NOT_SUPPORTED";
                  break;

                case "PermissionDeniedError":
                  n.msg = "PERMISSION_DENIED", t.dispatchEvent({
                    type: "accessDenied"
                  });
                  break;

                case "PERMISSION_DENIED":
                  t.dispatchEvent({
                    type: "accessDenied"
                  });
                  break;

                case "InvalidStateError":
                  n.msg = "PERMISSION_DENIED", t.dispatchEvent({
                    type: "accessDenied"
                  });
                  break;

                case "NotAllowedError":
                  t.dispatchEvent({
                    type: "accessDenied"
                  });
                  break;

                case "ConstraintNotSatisfiedError":
                  n.msg = "CONSTRAINT_NOT_SATISFIED";
                  break;

                default:
                  n.msg || (n.msg = "UNDEFINED");
              }

              var i = "Media access ".concat(n.msg).concat(n.info ? ": " + n.info : "");
              o.default.error("[".concat(t.streamId, "] "), i), r(n);
            }), e.screen && e.audio) {
              var S = !e.microphoneId || {
                deviceId: {
                  exact: e.microphoneId
                }
              };
              m = {};
              t.audioProcessing && (void 0 !== t.audioProcessing.AGC && (Object(p.isFireFox)() ? m.autoGainControl = t.audioProcessing.AGC : Object(p.isChrome)() && (m.googAutoGainControl = t.audioProcessing.AGC, m.googAutoGainControl2 = t.audioProcessing.AGC)), void 0 !== t.audioProcessing.AEC && (m.echoCancellation = t.audioProcessing.AEC), void 0 !== t.audioProcessing.ANS && (Object(p.isFireFox)() ? m.noiseSuppression = t.audioProcessing.ANS : Object(p.isChrome)() && (m.googNoiseSuppression = t.audioProcessing.ANS))), t.stereo && Object(p.isChrome)() && (m.googAutoGainControl = !1, m.googAutoGainControl2 = !1, m.echoCancellation = !1, m.googNoiseSuppression = !1), 0 !== Object.keys(m).length && (S = !0 === S ? {
                mandatory: m
              } : I()(S, m));
              var _ = {
                video: !1,
                audio: S
              };
              o.default.debug("[".concat(t.streamId, "] "), _), H(_, function (e) {
                o.default.info("[".concat(t.streamId, "] User has granted access to auxiliary local media.")), t.dispatchEvent({
                  type: "accessAllowed"
                });
                var n = e.getAudioTracks()[0];
                t.stream ? (t.stream.addTrack(n), r()) : t.screenAudioTrack = n;
              }, function (e) {
                var n = {
                  type: "error",
                  msg: e.name || e.code || e,
                  info: null
                };

                switch (e && (e.message && (n.info = e.message), e.code && (n.info ? n.info += ". " + e.code : n.info = " " + e.code), e.constraint && (n.info ? n.info += ". Constraint: " + e.constraint : n.info = "constraint: " + e.constraint)), n.msg) {
                  case "Starting video failed":
                  case "TrackStartError":
                    if (t.videoSize = void 0, s > 0) return void setTimeout(function () {
                      t.init(function (e) {
                        return r(e);
                      }, r, s - 1);
                    }, 1);
                    n.msg = "MEDIA_OPTION_INVALID";
                    break;

                  case "DevicesNotFoundError":
                    n.msg = "DEVICES_NOT_FOUND";
                    break;

                  case "NotSupportedError":
                    n.msg = "NOT_SUPPORTED";
                    break;

                  case "PermissionDeniedError":
                  case "InvalidStateError":
                    n.msg = "PERMISSION_DENIED", t.dispatchEvent({
                      type: "accessDenied"
                    });
                    break;

                  case "PERMISSION_DENIED":
                  case "NotAllowedError":
                    t.dispatchEvent({
                      type: "accessDenied"
                    });
                    break;

                  case "ConstraintNotSatisfiedError":
                    n.msg = "CONSTRAINT_NOT_SATISFIED";
                    break;

                  default:
                    n.msg || (n.msg = "UNDEFINED");
                }

                var i = "Media access ".concat(n.msg).concat(n.info ? ": " + n.info : "");
                o.default.error("[".concat(t.streamId, "] "), i), r(n);
              });
            }
          } else r({
            type: "warning",
            msg: "STREAM_HAS_NO_MEDIA_ATTRIBUTES"
          });
        } catch (e) {
          o.default.error("[".concat(t.streamId, "] Stream init: "), e), r({
            type: "error",
            msg: e.message || e
          });
        }
      }, t.close = function () {
        var e = a.b.reportApiInvoke(null, {
          name: "Stream.close",
          options: arguments,
          tag: "tracer"
        });

        if (o.default.debug("[".concat(t.streamId, "] Close stream with id"), t.streamId), void 0 !== t.stream) {
          var n = t.stream.getTracks();

          for (var i in n) {
            n.hasOwnProperty(i) && n[i].stop();
          }

          t.stream = void 0;
        }

        Object(p.isSafari)() && t.pc && t.pc.peerConnection && t.pc.peerConnection.removeTrack && t.pc.peerConnection.getSenders && t.pc.peerConnection.getSenders().forEach(function (e) {
          e && (o.default.debug("[".concat(t.streamId, "] Remove Track"), e), t.pc.peerConnection.removeTrack(e));
        });
        t.initialized = !1, t._onAudioMute = void 0, t._onAudioUnmute = void 0, t._onVideoMute = void 0, t._onVideoUnmute = void 0, t.lowStream && t.lowStream.close(), e();
      }, t.enableAudio = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.enableAudio",
          options: arguments,
          tag: "tracer"
        });
        o.default.deprecate("[".concat(t.streamId, "] Stream.enableAudio is deprecated and will be removed in the future. Use Stream.unmuteAudio instead"));

        var n = t._unmuteAudio();

        return n && (t.userMuteAudio = !1), e(null, n), n;
      }, t.disableAudio = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.disableAudio",
          options: arguments,
          tag: "tracer"
        });
        o.default.deprecate("[".concat(t.streamId, "] Stream.disableAudio is deprecated and will be removed in the future. Use Stream.muteAudio instead"));

        var n = t._muteAudio();

        return n && (t.userMuteAudio = !0), e(null, n), n;
      }, t.enableVideo = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.enableVideo",
          options: arguments,
          tag: "tracer"
        });
        o.default.deprecate("[".concat(t.streamId, "] Stream.enableVideo is deprecated and will be removed in the future. Use Stream.unmuteVideo instead"));

        var n = t._unmuteVideo();

        return n && (t.userMuteVideo = !1, t.lowStream && (t.lowStream.userMuteVideo = !1)), e(null, n), n;
      }, t.disableVideo = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.disableVideo",
          options: arguments,
          tag: "tracer"
        });
        o.default.deprecate("[".concat(t.streamId, "] Stream.disableVideo is deprecated and will be removed in the future. Use Stream.muteVideo instead"));

        var n = t._muteVideo();

        return n && (t.userMuteVideo = !0, t.lowStream && (t.lowStream.userMuteVideo = !0)), e(null, n), n;
      }, t.unmuteAudio = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.unmuteAudio",
          options: arguments,
          tag: "tracer"
        }),
            n = t._unmuteAudio();

        return n && (t.userMuteAudio = !1), e(null, n), n;
      }, t.muteAudio = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.muteAudio",
          options: arguments,
          tag: "tracer"
        }),
            n = t._muteAudio();

        return n && (t.userMuteAudio = !0), e(null, n), n;
      }, t.unmuteVideo = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.unmuteVideo",
          options: arguments,
          tag: "tracer"
        }),
            n = t._unmuteVideo();

        return n && (t.userMuteVideo = !1, t.lowStream && (t.lowStream.userMuteVideo = !1)), e(null, n), n;
      }, t.muteVideo = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.muteVideo",
          options: arguments,
          tag: "tracer"
        }),
            n = t._muteVideo();

        return n && (t.userMuteVideo = !0, t.lowStream && (t.lowStream.userMuteVideo = !0)), e(null, n), n;
      }, t._unmuteAudio = function () {
        return o.default.debug("[".concat(t.streamId, "] Unmuted audio stream with id "), t.streamId), t._flushAudioMixingMuteStatus(!1), !(!t.hasAudio() || !t.initialized || void 0 === t.stream || !0 === t.stream.getAudioTracks()[0].enabled) && (t._onAudioUnmute && t._onAudioUnmute(), t.pc && (t.pc.isAudioMute = !1), t.stream.getAudioTracks()[0].enabled = !0, !0);
      }, t._isAudioMuted = function () {
        if (t.stream && t.hasAudio()) {
          var e = t.stream.getAudioTracks();
          return e.length > 0 && !e[0].enabled;
        }

        return !1;
      }, t._muteAudio = function () {
        return o.default.debug("[".concat(t.streamId, "] Muted audio stream with id "), t.streamId), t._flushAudioMixingMuteStatus(!0), !!(t.hasAudio() && t.initialized && void 0 !== t.stream && t.stream.getAudioTracks()[0].enabled) && (t._onAudioMute && t._onAudioMute(), t.pc && (t.pc.isAudioMute = !0), t.stream.getAudioTracks()[0].enabled = !1, t.sid && a.b.audioSendingStopped(t.sid, {
          succ: !0,
          reason: "muteAudio"
        }), !0);
      }, t._unmuteVideo = function () {
        return o.default.debug("[".concat(t.streamId, "] Unmuted video stream with id"), t.streamId), !(!t.initialized || void 0 === t.stream || !t.stream.getVideoTracks().length || !0 === t.stream.getVideoTracks()[0].enabled) && (t._onVideoUnmute && t._onVideoUnmute(), t.pc && (t.pc.isVideoMute = !1), t.stream.getVideoTracks()[0].enabled = !0, t.lowStream && t.lowStream._unmuteVideo(), !0);
      }, t._muteVideo = function () {
        return o.default.debug("[".concat(t.streamId, "] Muted video stream with id"), t.streamId), !!(t.initialized && void 0 !== t.stream && t.stream.getVideoTracks().length && t.stream.getVideoTracks()[0].enabled) && (t._onVideoMute && t._onVideoMute(), t.pc && (t.pc.isVideoMute = !0), t.stream.getVideoTracks()[0].enabled = !1, t.lowStream && t.lowStream._muteVideo(), t.sid && a.b.videoSendingStopped(t.sid, {
          succ: !0,
          reason: "muteVideo"
        }), !0);
      }, t.addTrack = function (n) {
        var i = a.b.reportApiInvoke(t.sid, {
          name: "Stream.addTrack",
          options: arguments,
          tag: "tracer"
        });

        if (t.pc && t.pc.addTrack(n, t.stream), "audio" == n.kind) {
          var o = new MediaStream();
          t.userMuteAudio && (n.enabled = !1), o.addTrack(n);
          var r = t.stream.getVideoTracks()[0];
          r && (o.addTrack(r), t.audio = !0, e.audio = !0), t.stream = o, t.audioLevelHelper = null, t.player && t.player.video && (t.player.video.srcObject = t.stream);
        } else t.userMuteVideo && (n.enabled = !1), t.stream.addTrack(n), t.video = !0, e.video = !0;

        i();
      }, t.removeTrack = function (n) {
        var i = a.b.reportApiInvoke(t.sid, {
          name: "Stream.removeTrack",
          options: arguments,
          tag: "tracer"
        });
        t.pc && t.pc.removeTrack(n, t.stream), t.stream.removeTrack(n), "audio" === n.kind ? (t.audio = !1, e.audio = !1) : (t.video = !1, e.video = !1), t.audioLevelHelper = null, "live" == n.readyState && (n.stop(), o.default.debug("[".concat(t.streamId, "] Track ").concat(n.kind, " Stopped"))), i();
      }, t.setAudioOutput = function (e, n, i) {
        var r = a.b.reportApiInvoke(t.sid, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Stream.setAudioOutput",
          options: arguments,
          tag: "tracer"
        });
        return Z(e, 1, 255) ? (t.audioOutput = e, t.player ? void t.player.setAudioOutput(e, function () {
          return r();
        }, r) : r()) : (o.default.error("[".concat(t.streamId, "] setAudioOutput Invalid Parameter"), e), r(A.INVALID_PARAMETER));
      }, t.play = function (e, n) {
        var i = a.b.reportApiInvoke(t.sid, {
          name: "Stream.play",
          options: arguments,
          tag: "tracer"
        });
        Q(e, "elementID"), re(n) || (re(n.fit) || Y(n.fit, "fit", ["cover", "contain"]), re(n.muted) || $(n.muted, "muted")), t.elementID = e, t.playOptions = n, t.isPlaying() ? o.default.error("[".concat(t.streamId, "] Stream.play(): Stream is already playing")) : !t.local || t.video || t.screen ? void 0 !== e && (t.player = new T({
          id: t.getId(),
          stream: t,
          elementID: e,
          options: n
        })) : t.hasAudio() && (t.player = new T({
          id: t.getId(),
          stream: t,
          elementID: e,
          options: n
        })), t.audioOutput && t.player.setAudioOutput(t.audioOutput), void 0 !== t.audioLevel && t.player.setAudioVolume(t.audioLevel), t._flushAudioMixingMuteStatus(!1), i();
      }, t.stop = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.stop",
          options: arguments,
          tag: "tracer"
        });
        o.default.debug("[".concat(t.streamId, "] Stop stream player with id "), t.streamId), t.player ? (t.player.destroy(), delete t.player) : o.default.error("[".concat(t.streamId, "] Stream.stop(): Stream is not playing")), t._flushAudioMixingMuteStatus(!0), e();
      }, t.isPlaying = function () {
        return !!t.player;
      }, t.isPaused = function () {
        return !!t.player && (!(!t.player.video || !t.player.video.paused) || !(!t.player.audio || !t.player.audio.paused));
      }, t.resume = function () {
        var e = !1;
        return t.player && (t.player.video && t.player.video.play && (t.player.video.play(), e = !0), t.player.audio && t.player.audio.play && (t.player.audio.play(), e = !0)), e;
      }, t.getVideoTrack = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.getVideoTrack",
          options: arguments,
          tag: "tracer"
        });

        if (t.stream && t.stream.getVideoTracks) {
          var n = t.stream.getVideoTracks()[0];
          if (n) return o.default.info("[".concat(t.streamId, "] getVideoTrack"), n), e(), n;
        }

        o.default.info("[".concat(t.streamId, "] getVideoTrack None")), e(null, "getVideoTrack None");
      }, t.getAudioTrack = function () {
        var e = a.b.reportApiInvoke(t.sid, {
          name: "Stream.getAudioTrack",
          options: arguments,
          tag: "tracer"
        });

        if (t.stream && t.stream.getAudioTracks) {
          var n = t.stream.getAudioTracks()[0];
          if (n) return o.default.info("[".concat(t.streamId, "] getAudioTracks"), n), e(), n;
        }

        o.default.info("[".concat(t.streamId, "] getAudioTracks None")), e(null, "getAudioTracks None");
      }, t._replaceMediaStreamTrack = function (e, n, i) {
        if (t.stream) {
          if ("video" == e.kind) {
            if (r = t.stream.getVideoTracks()[0]) return t.userMuteVideo && (e.enabled = !1), t.stream.removeTrack(r), t.stream.addTrack(e), o.default.debug("[".concat(t.streamId, "] _replaceMediaStreamTrack ").concat(e.kind, " SUCCESS")), "live" == r.readyState && (r.stop(), o.default.debug("[".concat(t.streamId, "] Track ").concat(r.kind, " Stopped"))), n && n();
            var a = "MEDIASTREAM_TRACK_NOT_FOUND";
            return o.default.error("[".concat(t.streamId, "] MEDIASTREAM_TRACK_NOT_FOUND ").concat(e.kind)), i(a);
          }

          if ("audio" == e.kind) {
            var r;

            if (r = t.stream.getAudioTracks()[0]) {
              t.userMuteAudio && (e.enabled = !1);
              var s = new MediaStream();
              s.addTrack(e);
              var d = t.stream && t.stream.getVideoTracks()[0];
              return d && s.addTrack(d), t.stream = s, t.audioLevelHelper = null, t.player && t.player.video && (t.player.video.srcObject = t.stream), o.default.debug("[".concat(t.streamId, "] _replaceMediaStreamTrack SUCCESS")), "live" == r.readyState && (r.stop(), o.default.debug("[".concat(t.streamId, "] Track ").concat(r.kind, " Stopped"))), n && n();
            }

            a = "MEDIASTREAM_TRACK_NOT_FOUND";
            return o.default.error("[".concat(t.streamId, "] MEDIASTREAM_TRACK_NOT_FOUND ").concat(e.kind)), i(a);
          }

          a = "INVALID_TRACK_TYPE";
          return o.default.error("[".concat(t.streamId, "] _replaceMediaStreamTrack ").concat(a, " ").concat(e.kind)), i && i(a);
        }

        a = "NO_STREAM_FOUND";
        return o.default.error("[".concat(t.streamId, "] _replaceMediaStreamTrack ").concat(a)), i && i(a);
      }, t.replaceTrack = function (e, n, i) {
        var r = a.b.reportApiInvoke(t.sid, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Stream.replaceTrack",
          options: arguments,
          tag: "tracer"
        });
        return e && e.kind ? t.pc && t.pc.hasSender && t.pc.hasSender(e.kind) ? void t.pc.replaceTrack(e, function () {
          return o.default.debug("[".concat(t.streamId, "] PeerConnection.replaceTrack ").concat(e.kind, " SUCCESS")), t._replaceMediaStreamTrack(e, function (e) {
            return r(null, e);
          }, r);
        }, function (n) {
          return o.default.error("[".concat(t.streamId, "] PeerConnection.replaceTrack ").concat(e.kind, " Failed ").concat(n)), r(n);
        }) : t._replaceMediaStreamTrack(e, function (e) {
          return r(null, e);
        }, r) : r("INVALID_TRACK");
      }, t.setAudioVolume = function (e) {
        var n = a.b.reportApiInvoke(t.sid, {
          name: "Stream.setAudioVolume",
          options: arguments,
          tag: "tracer"
        });
        X(e, "level", 0, 100), t.audioLevel = e, t.player && t.player.setAudioVolume(e), n();
      }, t.getStats = function (e, n) {
        var i = {
          type: "collectStats",
          promises: []
        };
        t.dispatchEvent(i), Promise.all(i.promises).then(function (n) {
          for (var i = {}, o = n.length - 1; o >= 0; o--) {
            var a = n[o];
            I()(i, a);
          }

          e && setTimeout(e.bind(t, i), 0);
        }).catch(function (e) {
          n && setTimeout(n.bind(t, e), 0);
        });
      }, t._getPCStats = function () {
        return new Promise(function (e, n) {
          if (!t.pc || "established" !== t.pc.state || !t.pc.getStats) {
            return n("PEER_CONNECTION_NOT_ESTABLISHED");
          }

          t.pc.getStats(function (i) {
            if (!t.pc || "established" !== t.pc.state || !t.pc.getStats) {
              return n("PEER_CONNECTION_STATE_CHANGE");
            }

            var o = t.pc.isSubscriber ? function (e) {
              var t = {};
              return e.forEach(function (e) {
                e.id && (-1 === e.id.indexOf("recv") && -1 === e.id.indexOf("inbound_rtp") && -1 === e.id.indexOf("inbound-rtp") && -1 === e.id.indexOf("InboundRTP") || ("audio" === e.mediaType ? (J(t, "audioReceiveBytes", e.bytesReceived), J(t, "audioReceivePackets", e.packetsReceived), J(t, "audioReceivePacketsLost", e.packetsLost)) : (J(t, "videoReceiveBytes", e.bytesReceived), J(t, "videoReceivePacketsLost", e.packetsLost), J(t, "videoReceivePackets", e.packetsReceived), J(t, "videoReceiveFrameRate", e.googFrameRateReceived), J(t, "videoReceiveDecodeFrameRate", e.googFrameRateDecoded), J(t, "videoReceiveResolutionWidth", e.googFrameWidthReceived), J(t, "videoReceiveResolutionHeight", e.googFrameHeightReceived))));
              }), t;
            }(i) : function (e) {
              var t = {};
              return e.forEach(function (e) {
                e.id && (-1 === e.id.indexOf("send") && -1 === e.id.indexOf("outbound_rtp") && -1 === e.id.indexOf("OutboundRTP") || ("audio" === e.mediaType ? (J(t, "audioSendBytes", e.bytesSent), J(t, "audioSendPackets", e.packetsSent), J(t, "audioSendPacketsLost", e.packetsLost)) : (J(t, "videoSendBytes", e.bytesSent), J(t, "videoSendPackets", e.packetsSent), J(t, "videoSendPacketsLost", e.packetsLost), J(t, "videoSendFrameRate", e.googFrameRateSent), J(t, "videoSendResolutionWidth", e.googFrameWidthSent), J(t, "videoSendResolutionHeight", e.googFrameHeightSent))));
              }), t;
            }(i);
            return e(o);
          });
        }).then(function (e) {
          return t.pc.isSubscriber ? (Object(p.isFireFox)() || Object(p.isSafari)()) && (J(e, "videoReceiveResolutionHeight", t.videoHeight), J(e, "videoReceiveResolutionWidth", t.videoWidth)) : ((Object(p.isSafari)() || Object(p.isFireFox)()) && (J(e, "videoSendResolutionHeight", t.videoHeight), J(e, "videoSendResolutionWidth", t.videoWidth)), (Object(p.isSafari)() || Object(p.isFireFox)()) && t.uplinkStats && J(e, "videoSendPacketsLost", t.uplinkStats.uplink_cumulative_lost)), Promise.resolve(e);
        });
      }, t.getAudioLevel = function () {
        return t.audioLevelHelper ? t.audioLevelHelper.getAudioLevel() : t.stream ? 0 !== t.stream.getAudioTracks().length ? (t.audioLevelHelper = new G.a(t.stream), t.audioLevelHelper.getAudioLevel()) : void o.default.warning("[".concat(t.streamId, "] can't get audioLevel beacuse no audio trace in stream")) : (o.default.warning("[".concat(t.streamId, "] can't get audioLevel beacuse no stream exist")), 0);
      }, t.setVideoProfile("480P"), t._switchVideoDevice = function (e, n, i) {
        if (e === t.cameraId) return n && n();
        t.constraints.video.deviceId = {
          exact: e
        };
        var a = I()({}, t.constraints);
        a.audio = !1, o.default.debug("[".concat(t.streamId, "] ").concat(a)), H(a, function (o) {
          try {
            Object(p.isSafari)() ? t.replaceTrack(o.getVideoTracks()[0], function () {
              t.userMuteVideo && (t.stream.getVideoTracks()[0].enabled = !1), n && n();
            }, i) : (t.removeTrack(t.stream.getVideoTracks()[0]), t.addTrack(o.getVideoTracks()[0]), t.isPlaying() && (t.stop(), t.elementID && t.play(t.elementID)), t.cameraId = e, t.userMuteVideo && (t.stream.getVideoTracks()[0].enabled = !1), n && n());
          } catch (e) {
            return i && i(e);
          }
        }, function (e) {
          return i && i(e);
        });
      }, t._switchAudioDevice = function (e, n, i) {
        if (e === t.microphoneId) return n && n();
        !0 === t.constraints.audio ? t.constraints.audio = {
          deviceId: {
            exact: e
          }
        } : t.constraints.audio.deviceId = {
          exact: e
        };
        var a = I()({}, t.constraints);
        a.video = !1, o.default.debug("[".concat(t.streamId, "] "), a), H(a, function (o) {
          try {
            Object(p.isSafari)() ? t.replaceTrack(o.getAudioTracks()[0], n, i) : (t.removeTrack(t.stream.getAudioTracks()[0]), t.addTrack(o.getAudioTracks()[0]), t.audioMixing.audioContextInited && (t.audioMixing.ctx.close(), t.audioMixing.audioContextInited = !1), t.userMuteAudio && (t.stream.getAudioTracks()[0].enabled = !1), t.isPlaying() && (t.stop(), t.elementID && t.play(t.elementID)), t.microphoneId = e, n && n());
          } catch (e) {
            return i && i(e);
          }
        }, function (e) {
          return i && i(e);
        });
      }, t.switchDevice = function (e, n, i, r) {
        var s = a.b.reportApiInvoke(t.sid, {
          callback: function callback(e, t) {
            if (e) return r && r(e);
            i && i(t);
          },
          name: "Stream.switchDevice",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "deviceId");

        var d = function d() {
          return t.inSwitchDevice = !1, s();
        },
            c = function c(e) {
          t.inSwitchDevice = !1, o.default.error("[".concat(t.streamId, "] "), e), s(e);
        };

        if (t.inSwitchDevice) return s("Device switch is in process.");
        if (t.inSwitchDevice = !0, !t.local) return c("Only the local stream can switch the device.");
        if (t.screen && "video" === e) return c("The device cannot be switched during screen-sharing.");
        if (t.videoSource || t.audioSource) return c("The device cannot be switched when using videoSource or audioSource.");
        if (t.lowStream) return c("The device cannot be switched when using lowstream.");
        var u = !1;

        for (var l in t.audioMixing.sounds) {
          if (t.audioMixing.sounds[l].state !== t.audioMixing.states.IDLE) {
            u = !0;
            break;
          }
        }

        if (t.audioMixing.audioContextInited && u) return c("The device cannot be switched when using audio Mixing.");
        K.getDeviceById(n, function () {
          if ("video" === e) t._switchVideoDevice(n, d, c);else {
            if ("audio" !== e) return c("Invalid type.");

            t._switchAudioDevice(n, d, c);
          }
        }, function () {
          return c("The device does not exist.");
        });
      }, t;
    },
        de = n(12),
        ce = ["live", "rtc", "web", "interop", "h264_interop", "web-only"],
        ue = ["vp8", "h264"],
        le = ["aes-128-xts", "aes-256-xts", "aes-128-ecb"],
        pe = function pe(e) {
      e && e.apply(this, [].slice.call(arguments, 1));
    },
        fe = n(5),
        me = function me(e) {
      var t = r();
      return t.needReconnect = !0, t.isTimeout = !1, t.isInit = !0, t.sendbytes = 0, t.recvbytes = 0, t.startTime = Date.now(), t.clientId = e.clientId, t.hostIndex = 0, t.requestID = 0, e.host instanceof Array ? t.host = e.host : t.host = [e.host], t.getSendBytes = function () {
        return t.sendbytes;
      }, t.getRecvBytes = function () {
        return t.recvbytes;
      }, t.getDuration = function () {
        return Math.ceil((Date.now() - t.startTime) / 1e3);
      }, t.getURL = function () {
        return t.connection.url;
      }, t.reconnect = function () {
        t.isInit = !0, t.creatConnection();
      }, t.connectNext = function () {
        t.isInit = !0, ++t.hostIndex, o.default.debug("[" + t.clientId + "] Gateway length:" + t.host.length + " current index:" + t.hostIndex), t.hostIndex >= t.host.length ? t.dispatchEvent(u({
          type: "recover"
        })) : t.creatConnection();
      }, t.replaceHost = function (e) {
        t.host = e || t.host, t.hostIndex = 0, t.creatConnection();
      }, t.creatConnection = function () {
        o.default.debug("[" + t.clientId + "] start connect:" + t.host[t.hostIndex]), t.lts = new Date().getTime(), t.connection = new WebSocket("wss://" + t.host[t.hostIndex]), t.connection.onopen = function (e) {
          o.default.debug("[" + t.clientId + "] websockect opened: " + t.host[t.hostIndex]), t.needReconnect = !0, t.isTimeout = !1, t.isInit = !1, t.sendbytes = 0, t.recvbytes = 0, t.startTime = Date.now(), Object(fe.d)(), clearTimeout(t.timeoutCheck), t.dispatchEvent(u({
            type: "onopen",
            event: e,
            socket: t
          }));
        }, t.connection.onmessage = function (e) {
          t.recvbytes += Object(G.e)(e.data);
          var n = JSON.parse(e.data);
          n.hasOwnProperty("_id") ? t.dispatchEvent(u({
            type: n._id,
            msg: n
          })) : n.hasOwnProperty("_type") && t.dispatchSocketEvent(u({
            type: n._type,
            msg: n.message
          }));
        }, t.connection.onclose = function (n) {
          t.needReconnect ? t.isTimeout || t.isInit ? (o.default.debug("[" + t.clientId + "] websockect connect timeout"), a.b.joinGateway(e.sid, {
            lts: t.lts,
            succ: !1,
            ec: "timeout",
            addr: t.connection.url
          }), t.connectNext()) : t.dispatchEvent(u({
            type: "disconnect",
            event: n
          })) : (o.default.debug("[" + t.clientId + "] websockect closeed"), pe(e.onFailure, n), clearTimeout(t.timeoutCheck), t.dispatchEvent(u({
            type: "close",
            event: n
          })), t.connection.onopen = void 0, t.connection.onclose = void 0, t.connection.onerror = void 0, t.connection.onmessage = void 0, t.connection = void 0);
        }, t.connection.onerror = function (e) {}, setTimeout(function () {
          t.connection && t.connection.readyState != WebSocket.OPEN && (t.isTimeout = !0, t.connection.close());
        }, 5e3);
      }, t.creatConnection(), t.sendMessage = function (e, n) {
        if (t.connection && t.connection.readyState == WebSocket.OPEN) {
          var i = JSON.stringify(e);
          t.sendbytes += Object(G.e)(i), t.connection.send(i);
        } else n({
          error: "Gateway not connected"
        });
      }, t.disconnect = function () {
        t.needReconnect = !0, t.connection.close();
      }, t.close = function () {
        t.needReconnect = !1, t.connection.onclose = void 0, t.connection.close();
      }, t.sendSignalCommand = function (e, n) {
        e._id = "_request_" + t.requestID, t.requestID += 1, "publish_stats" !== e._type && "subscribe_stats" !== e._type && "publish_stats_low" !== e._type && t.on(e._id, function (i) {
          i.msg && n && n(i.msg._result, i.msg.message), delete t.dispatcher.eventListeners[e._id];
        }), t.sendMessage(e, function (e) {
          e.reason = "NOT_CONNECTED", n && n(e.reason, e);
        });
      }, t;
    },
        ge = function ge(e, t) {
      var n = {
        connect: function connect() {
          t.host = e, n.signal = me(t), n.on = n.signal.on, n.dispatchEvent = n.signal.dispatchEvent, n.signal.on("onopen", function (e) {
            n.signal.onEvent = function (e) {
              n.dispatchEvent(u({
                type: e.event,
                msg: e
              }));
            }, n.dispatchEvent(u({
              type: "connect",
              msg: e
            }));
          }), n.signal.on("onError", function (e) {
            var t = e.msg;
            onError(t.code, "error");
          });
        },
        getSendBytes: function getSendBytes() {
          return n.signal.getSendBytes();
        },
        getRecvBytes: function getRecvBytes() {
          return n.signal.getRecvBytes();
        },
        getDuration: function getDuration() {
          return n.signal.getDuration();
        },
        disconnect: function disconnect() {
          n.signal.disconnect();
        },
        close: function close() {
          n.signal.close();
        },
        getURL: function getURL() {
          return n.signal.getURL();
        },
        reconnect: function reconnect() {
          n.signal.reconnect();
        },
        connectNext: function connectNext() {
          n.signal.connectNext();
        },
        replaceHost: function replaceHost(e) {
          n.signal.replaceHost(e);
        },
        emitSimpleMessage: function emitSimpleMessage(e, t) {
          n.signal.sendSignalCommand(e, t);
        }
      };
      return n.connect(), n;
    },
        ve = function ve(e, t) {
      var n = !1,
          r = 0,
          s = {
        command: "convergeAllocateEdge",
        sid: e.sid,
        appId: e.appId,
        token: e.token,
        uid: e.uid,
        cname: e.cname,
        ts: Math.floor(Date.now() / 1e3),
        version: i.VERSION,
        seq: 0,
        requestId: 1
      };
      Object(i.getParameter)("PROXY_CS").map(function (d) {
        var c = new Date().getTime();
        Se("https://" + d + "/api/v1", s, function (s, u) {
          if (s) return o.default.debug("[" + e.clientId + "] Request proxy server failed: ", s), r++, a.b.requestProxyAppCenter(e.sid, {
            lts: c,
            succ: !1,
            APAddr: d,
            workerManagerList: null,
            ec: JSON.stringify(s),
            response: JSON.stringify({
              err: s,
              res: u
            })
          }), void (r >= Object(i.getParameter)("PROXY_CS").length && t && t("Get proxy server failed: request all failed"));
          if (!n) if ((u = JSON.parse(u)).json_body) {
            var l = JSON.parse(u.json_body);

            if (o.default.debug("[" + e.clientId + "] App return:", l.servers), 200 !== l.code) {
              s = "Get proxy server failed: response code [" + l.code + "], reason [ " + l.reason + "]";
              o.default.debug("[" + e.clientId + "] " + s), a.b.requestProxyAppCenter(e.sid, {
                lts: c,
                succ: !1,
                APAddr: d,
                workerManagerList: null,
                ec: s,
                response: JSON.stringify({
                  err: s,
                  res: u
                })
              });
            } else {
              n = !0;

              var p = _e(l.servers);

              a.b.requestProxyAppCenter(e.sid, {
                lts: c,
                succ: !0,
                APAddr: d,
                workerManagerList: JSON.stringify(p),
                ec: null,
                response: JSON.stringify({
                  res: u
                })
              }), t && t(null, p);
            }
          } else o.default.debug("[" + e.clientId + "] Get proxy server failed: no json_body"), a.b.requestProxyAppCenter(e.sid, {
            lts: c,
            succ: !1,
            APAddr: d,
            workerManagerList: null,
            ec: "Get proxy server failed: no json_body",
            response: JSON.stringify({
              res: u
            })
          });
        });
      });
    },
        Se = function Se(e, t, n) {
      var i = {
        service_name: "webrtc_proxy",
        json_body: JSON.stringify(t)
      };
      Object(fe.c)(e, i, function (e) {
        n && n(null, e);
      }, function (e) {
        n && n(e);
      }, {
        "X-Packet-Service-Type": 0,
        "X-Packet-URI": 61
      });
    },
        Ie = function Ie(e, t, n) {
      var i = !1,
          r = 0,
          s = {
        command: "request",
        gatewayType: "http",
        appId: e.appId,
        cname: e.cname,
        uid: e.uid + "",
        sdkVersion: "2.3.1",
        sid: e.sid,
        seq: 1,
        ts: +new Date(),
        requestId: 3,
        clientRequest: {
          appId: e.appId,
          cname: e.cname,
          uid: e.uid + "",
          sid: e.sid
        }
      };
      t.map(function (d) {
        var c = new Date().getTime();
        !function (e, t, n) {
          Object(fe.c)(e, t, function (e) {
            n && n(null, e);
          }, function (e) {
            n && n(e);
          });
        }("https://" + d + ":4000/v2/machine", s, function (s, u) {
          if (s) return o.default.debug("[" + e.clientId + "] Request worker manager failed: ", s), r++, a.b.requestProxyWorkerManager(e.sid, {
            lts: c,
            succ: !1,
            workerManagerAddr: d,
            ec: JSON.stringify(s),
            response: JSON.stringify({
              res: u
            })
          }), void (r >= t.length && n && n("requeet worker manager server failed: request failed"));

          if (!i) {
            if (!(u = JSON.parse(u)).serverResponse) return n && n("requeet worker manager server failed: serverResponse is undefined");
            i = !0, a.b.requestProxyWorkerManager(e.sid, {
              lts: c,
              succ: !0,
              workerManagerAddr: d,
              ec: JSON.stringify(s),
              response: JSON.stringify({
                res: u
              })
            }), n && n(null, {
              address: d,
              serverResponse: u.serverResponse
            });
          }
        });
      });
    },
        _e = function _e(e) {
      if (!e || [] instanceof Array == !1) return [];
      var t = [];
      return e.forEach(function (e) {
        var n;
        e.address && e.tcp ? (e.address.match(/^[\.\:\d]+$/) ? n = "".concat(e.address.replace(/[^\d]/g, "-"), ".edge.agora.io") : (o.default.info("[" + joinInfo.clientId + "] " + "Cannot recognized as IP address ".concat(e.address, ". Used As Host instead")), n = "".concat(e.address, ":").concat(e.tcp)), t.push(n)) : o.default.error("[" + joinInfo.clientId + "] Invalid address format ", e);
      }), t;
    },
        he = function he(e, t) {
      var n = I()({}, e),
          o = Object(i.getParameter)("WEBCS_DOMAIN").concat(Object(i.getParameter)("WEBCS_DOMAIN_BACKUP_LIST")),
          a = [],
          r = !1;
      (o = o.map(function (e) {
        return n.proxyServer ? "https://".concat(n.proxyServer, "/ap/?url=").concat(e + "/api/v1") : "https://".concat(e, "/api/v1");
      })).map(function (e) {
        !function (e, t, n) {
          var i = {
            flag: 64,
            cipher_method: 0,
            timeout: 1e3,
            features: t
          };
          Object(fe.c)(e, i, function (e) {
            try {
              var t = JSON.parse(e);
              n && n(null, t);
            } catch (e) {
              n && n(e);
            }

            n && n(null, e);
          }, function (e) {
            n && n(e);
          }, {
            "X-Packet-Service-Type": 0,
            "X-Packet-URI": 54
          });
        }(e, n, function (e, n) {
          r || (e ? (a.push(e), a.length >= o.length && t && t("ALL_REQUEST_FAILED")) : (r = !0, t && t(null, n)));
        });
      });
    },
        ye = function ye(e, t, n, i) {
      var r = new Date().getTime(),
          s = "";
      t.multiIP && t.multiIP.gateway_ip && (s = {
        vocs_ip: [t.multiIP.uni_lbs_ip],
        vos_ip: [t.multiIP.gateway_ip]
      });
      var d = {
        flag: 4,
        ts: +new Date(),
        key: t.appId,
        cname: t.cname,
        detail: {},
        uid: t.uid || 0
      };
      s && (d.detail[5] = JSON.stringify(s)), Object(fe.c)(e, d, function (s) {
        try {
          var d = JSON.parse(s).res,
              c = d.code;
        } catch (e) {
          var u = "requestChooseServer failed with unexpected body " + s;
          return o.default.error("[" + joinInfo.clientId + "]", u), i(u);
        }

        if (c) {
          var l = y[d.code] || c;
          return a.b.joinChooseServer(t.sid, {
            lts: r,
            succ: !1,
            csAddr: e,
            serverList: null,
            ec: l
          }), i("Get server node failed [" + l + "]", e, l);
        }

        var p = [],
            f = [".agora.io", ".agoraio.cn"],
            m = 0;

        if (e.indexOf(f[1]) > -1 && (m = 1), d.addresses.forEach(function (e) {
          var t;
          e.ip && e.port ? (e.ip.match(/^[\.\:\d]+$/) ? t = "webrtc-".concat(e.ip.replace(/[^\d]/g, "-")).concat(f[m++ % f.length], ":").concat(e.port) : (o.default.info("[" + joinInfo.clientId + "] " + "Cannot recognized as IP address ".concat(e.ip, ". Used As Host instead")), t = "".concat(e.ip, ":").concat(e.port)), p.push(t)) : o.default.error("[" + joinInfo.clientId + "] Invalid address format ", e);
        }), !p.length) {
          o.default.error("[" + joinInfo.clientId + "] Empty Address response", d);
          l = "EMPTY_ADDRESS_RESPONSE";
          return a.b.joinChooseServer(t.sid, {
            lts: r,
            succ: !1,
            csAddr: e,
            serverList: null,
            ec: l
          }), i("Get server node failed [" + l + "]", e, l);
        }

        var g = {
          gateway_addr: p,
          uid: d.uid,
          cid: d.cid,
          uni_lbs_ip: d.detail
        };
        return n(g, e);
      }, function (e, n) {
        "timeout" === e.type ? (a.b.joinChooseServer(t.sid, {
          lts: r,
          succ: !1,
          csAddr: n,
          serverList: null,
          ec: "timeout"
        }), i("Connect choose server timeout", n)) : a.b.joinChooseServer(t.sid, {
          lts: r,
          succ: !1,
          csAddr: n,
          serverList: null,
          ec: "server_wrong"
        });
      }, {
        "X-Packet-Service-Type": 0,
        "X-Packet-URI": 44
      });
    },
        be = function be(e, t, n) {
      var r = !1,
          s = null,
          d = 1,
          c = 1,
          u = null,
          l = function t(n, c) {
        if (!r) {
          var l = !1,
              f = !1,
              m = [],
              g = p.getBrowserInfo() || {};
          he({
            device: g.name,
            system: g.os,
            vendor: e.appId,
            version: i.VERSION,
            cname: e.cname,
            sid: e.sid,
            session_id: Object(a.a)(),
            detail: "",
            proxyServer: n
          }, function (t, n) {
            f = !0;

            try {
              var i = Object.keys(n.test_tags)[0],
                  o = JSON.parse(n.test_tags[i]);
              u = o[1];
            } catch (e) {
              u = null;
            }

            a.b.reportApiInvoke(e.sid, {
              name: "_config-distribute-request",
              options: {
                err: t,
                res: n
              }
            })(), l && c && c(m, u);
          }), function (e, t, n) {
            for (var r = new Date().getTime(), s = !1, d = !0, c = function c(n, i) {
              if (s) a.b.joinChooseServer(e.sid, {
                lts: r,
                succ: !0,
                csAddr: i,
                serverList: n.gateway_addr,
                cid: n.cid + "",
                uid: n.uid + "",
                ec: null
              }, !1);else {
                if (clearTimeout(g), s = !0, o.default.debug("[" + e.clientId + "] Get gateway address:", n.gateway_addr), e.proxyServer) {
                  for (var d = n.gateway_addr, c = 0; c < d.length; c++) {
                    var u = d[c].split(":");
                    n.gateway_addr[c] = e.proxyServer + "/ws/?h=" + u[0] + "&p=" + u[1];
                  }

                  o.default.debug("[" + e.clientId + "] Get gateway address:", n.gateway_addr);
                }

                t(n), a.b.joinChooseServer(e.sid, {
                  lts: r,
                  succ: !0,
                  csAddr: i,
                  serverList: n.gateway_addr,
                  cid: n.cid + "",
                  uid: n.uid + "",
                  ec: null
                }, !0);
              }
            }, u = function u(t, i, a) {
              d && (o.default.error("[" + e.clientId + "]", t, i, a), a && !E.includes(a) && (d = !1, n(a)));
            }, l = Object(i.getParameter)("WEBCS_DOMAIN"), p = 0; p < l.length; ++p) {
              var f;

              if ("string" == typeof l[p]) {
                var m = l[p];
                f = e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(m + "/api/v1") : "https://".concat(m, "/api/v1"), o.default.debug("[" + e.clientId + "] " + "Connect to choose_server: ".concat(f)), ye(f, e, c, u);
              } else o.default.error("[" + e.clientId + "] Invalid Host", l[p]);
            }

            var g = setTimeout(function () {
              if (!s) for (var t = Object(i.getParameter)("WEBCS_DOMAIN_BACKUP_LIST"), n = 0; n < t.length; ++n) {
                if ("string" == typeof t[n]) {
                  var a = t[n];
                  f = e.proxyServer ? "https://".concat(e.proxyServer, "/ap/?url=").concat(a + "/api/v1") : "https://".concat(a, "/api/v1"), o.default.debug("[" + e.clientId + "] " + "Connect to backup_choose_server: ".concat(f)), ye(f, e, c, u);
                } else o.default.error("[" + e.clientId + "] Invalid Host", t[n]);
              }
            }, 1e3);
            setTimeout(function () {
              !s && d && n();
            }, Object(i.getParameter)("WEBCS_BACKUP_CONNECT_TIMEOUT"));
          }(e, function (e) {
            r = !0, l = !0, m = e, clearTimeout(s), f && c && c(m, u);
          }, function (i) {
            i ? o.default.info("[" + e.clientId + "] Join failed: " + i) : (o.default.debug("[" + e.clientId + "] Request gateway list will be restart in " + d + "s"), s = setTimeout(function () {
              t(n, c);
            }, 1e3 * d), d = d >= 3600 ? 3600 : 2 * d);
          });
        }
      };

      e.useProxyServer ? function n() {
        !function (e, t) {
          ve(e, function (n, i) {
            if (n) return t && t(n);
            o.default.debug("[" + e.clientId + "] getProxyServerList: ", i), Ie(e, i, t);
          });
        }(e, function (i, r) {
          if (i) return o.default.debug("[" + e.clientId + "]", i), o.default.debug("[" + e.clientId + "] Request proxy will be restart in " + c + "s"), s = setTimeout(function () {
            n();
          }, 1e3 * c), void (c = c >= 3600 ? 3600 : 2 * c);
          clearTimeout(s);
          var d = r.address;
          e.proxyServer = d, e.turnServer = {
            url: r.address,
            tcpport: r.serverResponse.tcpport || "3433",
            udpport: r.serverResponse.udpport || "3478",
            username: r.serverResponse.username || "test",
            credential: r.serverResponse.password || "111111",
            forceturn: !0
          }, e.turnServer.tcpport += "", e.turnServer.udpport += "", a.b.setProxyServer(d), o.default.setProxyServer(d), l(d, t);
        });
      }() : l(null, t);
    },
        Ee = {
      ERR_NO_VOCS_AVAILABLE: "tryNext",
      ERR_NO_VOS_AVAILABLE: "tryNext",
      ERR_JOIN_CHANNEL_TIMEOUT: "tryNext",
      WARN_REPEAT_JOIN: "quit",
      ERR_JOIN_BY_MULTI_IP: "recover",
      WARN_LOOKUP_CHANNEL_TIMEOUT: "tryNext",
      WARN_OPEN_CHANNEL_TIMEOUT: "tryNext",
      ERR_VOM_SERVICE_UNAVAILABLE: "tryNext",
      ERR_TOO_MANY_USERS: "tryNext",
      ERR_MASTER_VOCS_UNAVAILABLE: "tryNext",
      ERR_INTERNAL_ERROR: "tryNext",
      notification_test_recover: "recover",
      notification_test_tryNext: "tryNext",
      notification_test_retry: "retry"
    },
        Re = {
      googResidualEchoLikelihood: "A_rel",
      googResidualEchoLikelihoodRecentMax: "A_rem",
      googTypingNoiseState: "A_tns",
      totalSamplesDuration: "A_sd",
      googAdaptationChanges: "A_ac",
      googBandwidthLimitedResolution: "A_blr",
      googCpuLimitedResolution: "A_clr",
      googEncodeUsagePercent: "A_eup",
      googHasEnteredLowResolution: "A_helr",
      googActualEncBitrate: "A_aeb",
      googAvailableReceiveBandwidth: "A_arb",
      googAvailableSendBandwidth: "A_asb",
      googRetransmitBitrate: "A_rb",
      googTargetEncBitrate: "A_teb",
      googCaptureStartNtpTimeMs: "A_csnt",
      googPreemptiveExpandRate: "A_per",
      googPreferredJitterBufferMs: "A_pjbm",
      googSecondaryDecodedRate: "A_sder",
      googSecondaryDiscardedRate: "A_sdir",
      googSpeechExpandRate: "A_ser",
      googFrameHeightReceived: "A_fhr",
      googInterframeDelayMax: "A_ifdm",
      googMinPlayoutDelayMs: "A_mpdm",
      aecDivergentFilterFraction: "A_dff",
      codecImplementationName: "A_cin",
      googEchoCancellationReturnLoss: "A_ecl",
      googEchoCancellationReturnLossEnhancement: "A_ece"
    },
        Ae = {};

    for (var Te in Re) {
      var Oe = Re[Te];
      Re[Oe] && console.error("Key Conflict: ".concat(Te)), Ae[Oe] = Te;
    }

    var Ce = function Ce(e) {
      return Re[e] || e;
    },
        Ne = function e(t) {
      var n = !1,
          s = function s(e) {
        return {
          _type: "control",
          message: e
        };
      },
          u = function u(e) {
        var t = {};
        return Object.keys(e).forEach(function (n) {
          t[Ce(n)] = e[n];
        }), {
          _type: "subscribe_related_stats",
          options: t
        };
      },
          f = function f(e, t, n) {
        return {
          _type: "publish",
          options: e,
          sdp: t,
          p2pid: n
        };
      },
          m = e.DISCONNECTED,
          g = e.CONNECTING,
          S = e.CONNECTED,
          _ = e.DISCONNECTING,
          h = m,
          y = r();

      Object.defineProperty(y, "state", {
        set: function set(t) {
          var n = h;
          h = t, n !== t && y.dispatchEvent({
            type: "connection-state-change",
            prevState: e.connetionStateMap[n],
            curState: e.connetionStateMap[t]
          });
        },
        get: function get() {
          return h;
        }
      }), y.socket = void 0, y.state = m, y.mode = t.mode, y.role = t.role, y.codec = t.codec, y.config = {}, y.timers = {}, y.timer_counter = {}, y.localStreams = {}, y.remoteStreams = {}, y.attemps = 1, y.p2p_attemps = 1, y.audioLevel = {}, y.activeSpeaker = void 0, y.reconnectMode = "retry", y.rejoinAttempt = 0, y.hasChangeBGPAddress = !1, y.traffic_stats = {}, y.clientId = t.clientId, y.p2ps = new Map(), y.firstFrameTimer = new Map(), y.firstAudioDecodeTimer = new Map(), y.liveStreams = new Map(), y.injectLiveStreams = new Map(), y.remoteStreamsInChannel = new Set(), y.inChannelInfo = {
        joinAt: null,
        duration: 0
      };
      var E = pe;
      y.p2pCounter = Object(G.g)(1e5), y.generateP2PId = function () {
        return ++y.p2pCounter;
      }, y.audioVolumeIndication = {
        enabled: !1,
        sortedAudioVolumes: [],
        smooth: 3,
        interval: 2e3
      }, y.remoteVideoStreamTypes = {
        REMOTE_VIDEO_STREAM_HIGH: 0,
        REMOTE_VIDEO_STREAM_LOW: 1,
        REMOTE_VIDEO_STREAM_MEDIUM: 2
      }, y.streamFallbackTypes = {
        STREAM_FALLBACK_OPTION_DISABLED: 0,
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW: 1,
        STREAM_FALLBACK_OPTION_AUDIO_ONLY: 2
      }, y.configPublisher = function (e) {
        y.config = e;
      }, y.getGatewayInfo = function (e, t) {
        N({
          _type: "gateway_info"
        }, e, t);
      }, y.setClientRole = function (e, t) {
        o.default.debug("[".concat(y.clientId, "] setClientRole to ").concat(e));
        var n = a.b.reportApiInvoke(y.joinInfo.sid, {
          name: "_setClientRole",
          callback: t
        });
        N(function (e) {
          return {
            _type: "set_client_role",
            message: e
          };
        }(e), function () {
          y.role = e, y.dispatchEvent({
            type: "client-role-changed",
            role: e
          }), n && n(null, {
            role: e
          });
        }, function (t) {
          var i = t && t.code ? t.code : 0,
              a = R[i];
          if ("ERR_ALREADY_IN_USE" === a) return n && n(null);
          a || (a = "UNKNOW_ERROR_".concat(i)), o.default.error("set Client role error to " + e + ": " + a), n && n(a);
        });
      }, y.join = function (e, n, r, s) {
        e.useProxyServer && (y.hasChangeBGPAddress = !0);
        var d = new Date().getTime(),
            c = e.uid;
        if (y.inChannelInfo.joinAt && (y.inChannelInfo.duration += d - y.inChannelInfo.joinAt), y.inChannelInfo.joinAt = d, y.state !== g) return o.default.error("[".concat(y.clientId, "] GatewayClient.join Failed: state "), y.state), s && s(A.INVALID_OPERATION), void a.b.joinGateway(e.sid, {
          lts: d,
          succ: !1,
          ec: A.INVALID_OPERATION,
          addr: null
        });
        if (null != c && parseInt(c) !== c) return o.default.error("[".concat(y.clientId, "] Input uid is invalid")), y.state = m, s && s(A.INVALID_PARAMETER), void a.b.joinGateway(e.sid, {
          lts: d,
          succ: !1,
          ec: A.INVALID_PARAMETER,
          addr: null
        });
        var u = we.register(y, {
          uid: c,
          cname: e && e.cname
        });
        if (u) return y.state = m, s && s(u), void a.b.joinGateway(e.sid, {
          lts: d,
          succ: !1,
          ec: u,
          addr: null
        });
        y.joinInfo = I()({}, e), y.uid = c, y.key = n, C(e, function (n) {
          var c, u, l;
          y.state = S, o.default.debug("[".concat(y.clientId, "] Connected to gateway server")), y.pingTimer = setInterval(function () {
            var e = Date.now();
            N({
              _type: "ping"
            }, function () {
              var t = Date.now() - e;
              N({
                _type: "signal_stats",
                message: {
                  pingpongElapse: t
                }
              }, function () {}, function (e) {});
            }, function (e) {});
          }, 3e3), N((c = {
            role: y.role
          }, u = c.role, l = {
            appId: t.appId,
            key: y.key,
            channel: y.joinInfo.cname,
            uid: y.uid,
            version: i.VERSION,
            browser: navigator.userAgent,
            mode: y.mode,
            codec: y.codec,
            role: u,
            config: y.config,
            processId: Object(a.a)()
          }, y.joinInfo.hasOwnProperty("stringUid") && (l.stringUid = y.joinInfo.stringUid), {
            _type: "join1",
            message: l
          }), function (t) {
            if (a.b.joinGateway(e.sid, {
              lts: d,
              succ: !0,
              ec: null,
              vid: t.vid,
              addr: y.socket.getURL()
            }), y.rejoinAttempt = 0, r && r(t.uid), y.dispatchEvent({
              type: "join"
            }), y.leaveOnConnected) {
              o.default.info("[".concat(y.clientId, "] Calling Leave() once joined"));
              var n = y.leaveOnConnected;
              y.leaveOnConnected = null, y.leave(n.onSuccess, n.onFailure);
            }
          }, function (t) {
            if (o.default.error("[".concat(y.clientId, "] User join failed [").concat(t, "]")), Ee[t] && y.rejoinAttempt < 4) {
              if (y._doWithAction(Ee[t], r, s), y.leaveOnConnected) {
                o.default.error("[".concat(y.clientId, "] Calling Leave() once joined: Join Failed"));
                var n = y.leaveOnConnected;
                y.leaveOnConnected = null, n.onFailure(A.JOIN_CHANNEL_FAILED);
              }
            } else s && s(t);

            a.b.joinGateway(e.sid, {
              lts: d,
              succ: !1,
              ec: t,
              addr: y.socket.getURL()
            });
          });
        }, function (t) {
          o.default.error("[".concat(y.clientId, "] User join failed [").concat(t, "]")), s && s(t), a.b.joinGateway(e.sid, {
            lts: d,
            succ: !1,
            ec: t,
            addr: y.socket.getURL()
          });
        }), clearInterval(y.timers.trafficStats), y.timers.trafficStats = setInterval(function () {
          N({
            _type: "traffic_stats"
          }, function (e) {
            y.traffic_stats = e;
            var t = y.joinInfo.stringUid,
                n = y.localStreams[c] || y.localStreams[t];
            n && (n.traffic_stats = {
              access_delay: e.access_delay
            }), e.peer_delay && e.peer_delay.forEach(function (t) {
              var n = y.remoteStreams[t.peer_uid];
              n && (n.traffic_stats = {
                access_delay: e.access_delay,
                e2e_delay: t.e2e_delay,
                audio_delay: t.audio_delay,
                video_delay: t.video_delay
              });
            });
          });
        }, 3e3), y.resetAudioVolumeIndication();
      }, y.leave = function (e, t) {
        switch (y.state) {
          case m:
            return o.default.debug("[".concat(y.clientId, "] Client Already in DISCONNECTED status")), void E(e);

          case _:
            return o.default.error("[".concat(y.clientId, "] Client Already in DISCONNECTING status")), void E(t, A.INVALID_OPERATION);

          case g:
            return y.leaveOnConnected ? (o.default.error("[".concat(y.clientId, "] Client.leave() already called")), void E(t, A.INVALID_OPERATION)) : (o.default.debug("[".concat(y.clientId, "] Client connecting. Waiting for Client Fully Connected(And leave)")), void (y.leaveOnConnected = {
              onSuccess: e,
              onFailure: t
            }));
        }

        var n = we.unregister(y);
        if (n) o.default.error("[".concat(y.clientId, "] "), n);else {
          for (var i in y.state = _, clearInterval(y.pingTimer), y.timers) {
            y.timers.hasOwnProperty(i) && clearInterval(y.timers[i]);
          }

          for (var i in y.inChannelInfo.joinAt && (y.inChannelInfo.duration += Date.now() - y.inChannelInfo.joinAt, y.inChannelInfo.joinAt = null), N({
            _type: "leave"
          }, function (t) {
            y.socket.close(), y.socket = void 0, o.default.info("[".concat(y.clientId, "] Leave channel success")), y.state = m, e && e(t);
          }, function (e) {
            o.default.error("[".concat(y.clientId, "] Leave Channel Failed"), e), y.state = S, t && t(e);
          }), y.localStreams) {
            if (y.localStreams.hasOwnProperty(i)) {
              var a = y.localStreams[i];
              delete y.localStreams[i], void 0 !== a.pc && (a.pc.close(), a.pc = void 0);
            }
          }

          k();
        }
      }, y.publish = function (e, t, n, i) {
        var r = new Date().getTime(),
            d = !1;
        if (e.publishLTS = r, "object" !== v()(e) || null === e) return o.default.error("[".concat(y.clientId, "] Invalid local stream")), i && i(A.INVALID_LOCAL_STREAM), void a.b.publish(y.joinInfo.sid, {
          lts: r,
          succ: !1,
          audioName: e.hasAudio() && e.audioName,
          videoName: e.hasVideo() && e.videoName,
          screenName: e.hasScreen() && e.screenName,
          ec: A.INVALID_LOCAL_STREAM
        });
        if (null === e.stream && void 0 === e.url) return o.default.error("[".concat(y.clientId, "] Invalid local media stream")), i && i(A.INVALID_LOCAL_STREAM), void a.b.publish(y.joinInfo.sid, {
          lts: r,
          succ: !1,
          audioName: e.hasAudio() && e.audioName,
          videoName: e.hasVideo() && e.videoName,
          screenName: e.hasScreen() && e.screenName,
          ec: A.INVALID_LOCAL_STREAM
        });
        if (y.state !== S) return o.default.error("[".concat(y.clientId, "] User is not in the session")), i && i(A.INVALID_OPERATION), void a.b.publish(y.joinInfo.sid, {
          lts: r,
          succ: !1,
          audioName: e.hasAudio() && e.audioName,
          videoName: e.hasVideo() && e.videoName,
          screenName: e.hasScreen() && e.screenName,
          ec: A.INVALID_OPERATION
        });
        var u = e.getAttributes() || {};

        if (e.local && void 0 === y.localStreams[e.getId()] && (e.hasAudio() || e.hasVideo() || e.hasScreen())) {
          var l = y.generateP2PId();
          if (y.p2ps.set(l, e), e.p2pId = l, void 0 !== e.url) w(f({
            state: "url",
            audio: e.hasAudio(),
            video: e.hasVideo(),
            attributes: e.getAttributes(),
            mode: y.mode
          }, e.url), function (t, n) {
            "success" === t ? (e.getUserId() !== n && e.setUserId(n), y.localStreams[n] = e, e.onClose = function () {
              y.unpublish(e);
            }) : o.default.error("[".concat(y.clientId, "] Publish local stream failed"), t);
          });else {
            y.localStreams[e.getId()] = e, e.connectionSpec = {
              callback: function callback(u) {
                o.default.debug("[".concat(y.clientId, "] SDP exchange in publish : send offer --  "), JSON.parse(u)), w(f({
                  state: "offer",
                  id: e.getId(),
                  audio: e.hasAudio(),
                  video: e.hasVideo() || e.hasScreen(),
                  attributes: e.getAttributes(),
                  streamType: t.streamType,
                  dtx: e.DTX,
                  hq: e.highQuality,
                  lq: e.lowQuality,
                  stereo: e.stereo,
                  speech: e.speech,
                  mode: y.mode,
                  codec: y.codec,
                  p2pid: l,
                  turnip: y.joinInfo.turnServer.url,
                  turnport: Number(y.joinInfo.turnServer.udpport),
                  turnusername: y.joinInfo.turnServer.username,
                  turnpassword: y.joinInfo.turnServer.credential
                }, u), function (p, m) {
                  if ("error" === p) return o.default.error("[".concat(y.clientId, "] Publish local stream failed")), i && i(A.PUBLISH_STREAM_FAILED), void a.b.publish(y.joinInfo.sid, {
                    lts: r,
                    succ: !1,
                    audioName: e.hasAudio() && e.audioName,
                    videoName: e.hasVideo() && e.videoName,
                    screenName: e.hasScreen() && e.screenName,
                    localSDP: u,
                    ec: A.PUBLISH_STREAM_FAILED
                  });
                  e.pc.onsignalingmessage = function (n) {
                    e.pc.onsignalingmessage = function () {}, w(f({
                      state: "ok",
                      id: e.getId(),
                      audio: e.hasAudio(),
                      video: e.hasVideo(),
                      screen: e.hasScreen(),
                      streamType: t.streamType,
                      attributes: e.getAttributes(),
                      mode: y.mode
                    }, n)), e.getUserId() !== m.id && e.setUserId(m.id), o.default.info("[".concat(y.clientId, "] Local stream published with uid"), m.id), e.onClose = function () {
                      y.unpublish(e);
                    }, e._onAudioUnmute = function () {
                      N(s({
                        action: "audio-out-on",
                        streamId: e.getId()
                      }), function () {}, function () {});
                    }, e._onVideoUnmute = function () {
                      N(s({
                        action: "video-out-on",
                        streamId: e.getId()
                      }), function () {}, function () {});
                    }, e._onAudioMute = function () {
                      N(s({
                        action: "audio-out-off",
                        streamId: e.getId()
                      }), function () {}, function () {});
                    }, e._onVideoMute = function () {
                      N(s({
                        action: "video-out-off",
                        streamId: e.getId()
                      }), function () {}, function () {});
                    }, e.getId() === e.getUserId() && (e.isAudioOn() || e.hasAudio() && (o.default.debug("[".concat(y.clientId, "] local stream audio mute")), e._onAudioMute()), e.isVideoOn() || (e.hasVideo() || e.hasScreen()) && (o.default.debug("[".concat(y.clientId, "] local stream video mute")), e._onVideoMute()));
                  }, e.pc.oniceconnectionstatechange = function (t) {
                    if ("failed" === t) {
                      if (null != y.timers[e.getId()] && (clearInterval(y.timers[e.getId()]), clearInterval(y.timers[e.getId()] + "_RelatedStats")), o.default.error("[".concat(y.clientId, "] Publisher connection is lost -- streamId: ").concat(e.getId(), ", p2pId: ").concat(l)), y.p2ps.delete(l), o.default.debug("[".concat(y.clientId, "] publish p2p failed: "), y.p2ps), !d) return d = !0, a.b.publish(y.joinInfo.sid, {
                        lts: r,
                        succ: !1,
                        audioName: e.hasAudio() && e.audioName,
                        videoName: e.hasVideo() && e.videoName,
                        screenName: e.hasScreen() && e.screenName,
                        ec: A.PEERCONNECTION_FAILED
                      }), y.dispatchEvent(c({
                        type: "pubP2PLost",
                        stream: e
                      })), i && i(A.PEERCONNECTION_FAILED);
                      y.dispatchEvent(c({
                        type: "pubP2PLost",
                        stream: e
                      }));
                    } else if ("connected" === t && (o.default.debug("[".concat(y.clientId, "] publish p2p connected: "), y.p2ps), !d)) return d = !0, a.b.publish(y.joinInfo.sid, {
                      lts: r,
                      succ: !0,
                      audioName: e.hasAudio() && e.audioName,
                      videoName: e.hasVideo() && e.videoName,
                      screenName: e.hasScreen() && e.screenName,
                      ec: null
                    }), n && n();
                  }, o.default.debug("[".concat(y.clientId, "] SDP exchange in publish : receive answer --  "), JSON.parse(p)), e.pc.processSignalingMessage(p);
                });
              },
              audio: e.hasAudio(),
              video: e.hasVideo(),
              screen: e.hasScreen(),
              isSubscriber: !1,
              stunServerUrl: y.stunServerUrl,
              turnServer: y.joinInfo.turnServer,
              maxAudioBW: u.maxAudioBW,
              minVideoBW: u.minVideoBW,
              maxVideoBW: u.maxVideoBW,
              mode: y.mode,
              codec: y.codec,
              isVideoMute: e.userMuteVideo || e.peerMuteVideo,
              isAudioMute: e.userMuteAudio || e.peerMuteAudio,
              maxFrameRate: e.attributes.maxFrameRate,
              clientId: y.clientId
            }, e.pc = W(e.connectionSpec), e.pc.addStream(e.stream), o.default.debug("[".concat(y.clientId, "] PeerConnection add stream :"), e.stream), e.pc.onnegotiationneeded = function (t) {
              w(f({
                state: "negotiation",
                p2pid: l
              }, t), function (t, n) {
                e.pc.processSignalingMessage(t);
              });
            }, y.timers[e.getId()] = setInterval(function () {
              var t = 0;
              e && e.pc && e.pc.getStats && e.pc.getStatsRate(function (n) {
                n.forEach(function (n) {
                  if (n && n.id && !/_recv$/.test(n.id) && !/^time$/.test(n.id) && e.getUserId()) if (-1 === n.id.indexOf("outbound_rtp") && -1 === n.id.indexOf("OutboundRTP") || "video" !== n.mediaType || (n.googFrameWidthSent = e.videoWidth + "", n.googFrameHeightSent = e.videoHeight + ""), e.getId() == e.getUserId()) {
                    var i = 200 * t;
                    t++, setTimeout(function () {
                      var e, t;
                      N((e = n, t = {}, Object.keys(e).forEach(function (n) {
                        t[Ce(n)] = e[n];
                      }), {
                        _type: "publish_stats",
                        options: {
                          stats: t
                        },
                        sdp: null
                      }), null, null);
                    }, i);
                  } else {
                    i = 200 * t;
                    t++, setTimeout(function () {
                      var e, t;
                      N((e = n, t = {}, Object.keys(e).forEach(function (n) {
                        t[Ce(n)] = e[n];
                      }), {
                        _type: "publish_stats_low",
                        options: {
                          stats: t
                        },
                        sdp: null
                      }), null, null);
                    }, i);
                  }
                });
              });
            }, 3e3);

            var p = function p() {
              e && e.pc && e.pc.getVideoRelatedStats && e.pc.getVideoRelatedStats(function (t) {
                var n, i;
                e.getId() === e.getUserId() ? N((n = t, i = {}, Object.keys(n).forEach(function (e) {
                  i[Ce(e)] = n[e];
                }), {
                  _type: "publish_related_stats",
                  options: i
                }), null, null) : N(function (e) {
                  var t = {};
                  return Object.keys(e).forEach(function (n) {
                    t[Ce(n)] = e[n];
                  }), {
                    _type: "publish_related_stats_low",
                    options: t
                  };
                }(t), null, null);
              });
            };

            p(), y.timers[e.getId() + "_RelatedStats"] = setInterval(p, 1e3);
          }
        }
      }, y.unpublish = function (e, t, n, i) {
        return "object" !== v()(e) || null === e ? (o.default.error("[".concat(y.clientId, "] Invalid local stream")), void E(i, A.INVALID_LOCAL_STREAM)) : y.state !== S ? (o.default.error("[".concat(y.clientId, "] User not in the session")), void E(i, A.INVALID_OPERATION)) : (null != y.timers[e.getId()] && (clearInterval(y.timers[e.getId()]), clearInterval(y.timers[e.getId() + "_RelatedStats"])), void (void 0 !== y.socket ? e.local && void 0 !== y.localStreams[e.getId()] ? (delete y.localStreams[e.getId()], N((a = e.getUserId(), r = t.streamType, {
          _type: "unpublish",
          message: a,
          streamType: r
        })), (e.hasAudio() || e.hasVideo() || e.hasScreen()) && void 0 === e.url && void 0 !== e.pc && (e.pc.close(), e.pc = void 0), e.onClose = void 0, e._onAudioMute = void 0, e._onAudioUnute = void 0, e._onVideoMute = void 0, e._onVideoUnmute = void 0, y.p2ps.delete(e.p2pId), n && n()) : (o.default.error("[".concat(y.clientId, "] Invalid local stream")), E(i, A.INVALID_LOCAL_STREAM)) : (o.default.error("[".concat(y.clientId, "] User not in the session")), E(i, A.INVALID_OPERATION))));
        var a, r;
      }, y.subscribe = function (e, t, n) {
        var i = new Date().getTime();
        e.subscribeLTS = i;
        var r = !1;
        if (o.default.info("[".concat(y.clientId, "] Gatewayclient ").concat(y.uid, " Subscribe ").concat(e.getId(), ": ").concat(JSON.stringify(e.subscribeOptions))), "object" !== v()(e) || null === e) return o.default.error("[".concat(y.clientId, "] Invalid remote stream")), n && n(A.INVALID_REMOTE_STREAM), void a.b.subscribe(y.joinInfo.sid, {
          lts: i,
          succ: !1,
          video: e.subscribeOptions && e.subscribeOptions.video,
          audio: e.subscribeOptions && e.subscribeOptions.audio,
          peerid: e.getId(),
          ec: A.INVALID_REMOTE_STREAM
        });
        if (y.state !== S && (o.default.error("[".concat(y.clientId, "] User is not in the session")), !r)) return r = !0, a.b.subscribe(y.joinInfo.sid, {
          lts: i,
          succ: !1,
          video: e.subscribeOptions && e.subscribeOptions.video,
          audio: e.subscribeOptions && e.subscribeOptions.audio,
          peerid: e.getId(),
          ec: A.INVALID_OPERATION
        }), n && n(A.INVALID_OPERATION);
        if (!e.local && y.remoteStreams.hasOwnProperty(e.getId())) {
          if (e.hasAudio() || e.hasVideo() || e.hasScreen()) {
            var l = y.generateP2PId();
            y.p2ps.set(l, e), e.p2pId = l, e.pc = W({
              callback: function callback(t) {
                o.default.debug("[".concat(y.clientId, "] SDP exchange in subscribe : send offer --  "), JSON.parse(t));
                var r,
                    s = I()({
                  streamId: e.getId(),
                  video: !0,
                  audio: !0,
                  mode: y.mode,
                  codec: y.codec,
                  p2pid: l,
                  turnip: y.joinInfo.turnServer.url,
                  turnport: Number(y.joinInfo.turnServer.udpport),
                  turnusername: y.joinInfo.turnServer.username,
                  turnpassword: y.joinInfo.turnServer.credential
                }, e.subscribeOptions);
                w({
                  _type: "subscribe",
                  options: s,
                  sdp: t,
                  p2pid: r
                }, function (t) {
                  if ("error" === t) return o.default.error("[".concat(y.clientId, "] Subscribe remote stream failed, closing stream "), e.getId()), e.close(), n && n(A.SUBSCRIBE_STREAM_FAILED), void a.b.subscribe(y.joinInfo.sid, {
                    lts: i,
                    succ: !1,
                    video: e.subscribeOptions && e.subscribeOptions.video,
                    audio: e.subscribeOptions && e.subscribeOptions.audio,
                    peerid: e.getId(),
                    ec: A.SUBSCRIBE_STREAM_FAILED
                  });
                  o.default.debug("[".concat(y.clientId, "] SDP exchange in subscribe : receive answer --  "), JSON.parse(t)), e.pc.processSignalingMessage(t);
                });
              },
              nop2p: !0,
              audio: !0,
              video: !0,
              screen: e.hasScreen(),
              isSubscriber: !0,
              stunServerUrl: y.stunServerUrl,
              turnServer: y.joinInfo.turnServer,
              isVideoMute: e.userMuteVideo,
              isAudioMute: e.userMuteAudio,
              uid: e.getId(),
              clientId: y.clientId
            }), e.pc.onaddstream = function (t, n) {
              if (e._onAudioUnmute = function () {
                N(s({
                  action: "audio-in-on",
                  streamId: e.getId()
                }), function () {}, function () {});
              }, e._onAudioMute = function () {
                N(s({
                  action: "audio-in-off",
                  streamId: e.getId()
                }), function () {}, function () {});
              }, e._onVideoUnmute = function () {
                N(s({
                  action: "video-in-on",
                  streamId: e.getId()
                }), function () {}, function () {});
              }, e._onVideoMute = function () {
                N(s({
                  action: "video-in-off",
                  streamId: e.getId()
                }), function () {}, function () {});
              }, "ontrack" === n && "video" === t.track.kind || "onaddstream" === n) {
                o.default.info("[".concat(y.clientId, "] Remote stream subscribed with uid "), e.getId());
                var i = y.remoteStreams[e.getId()];

                if (y.remoteStreams[e.getId()].stream = "onaddstream" === n ? t.stream : t.streams[0], y.remoteStreams[e.getId()].hasVideo()) {
                  if (Object(p.isFireFox)() || Object(p.isSafari)()) {
                    var a = y.remoteStreams[e.getId()].stream;
                    Object(G.h)(a, function (t, n) {
                      e.videoWidth = t, e.videoHeight = n;
                    }, function (e) {
                      return o.default.warning("[".concat(y.clientId, "] vsResHack failed: ") + e);
                    });
                  }
                } else {
                  var r = y.remoteStreams[e.getId()];
                  r.peerMuteVideo = !0, y._adjustPCMuteStatus(r);
                }

                i && i.isPlaying() && i.elementID && (o.default.debug("[".concat(y.clientId, "] Reload Player ").concat(i.elementID, " StreamId ").concat(i.getId())), e.audioOutput = i.audioOutput, i.stop(), e.play(i.elementID, i.playOptions));
                var c = d({
                  type: "stream-subscribed",
                  stream: y.remoteStreams[e.getId()]
                });
                y.dispatchEvent(c);
              }
            }, y.timers[e.getId()] = setInterval(function () {
              var t = 0;
              e && e.pc && e.pc.getStats && e.pc.getStatsRate(function (n) {
                n.forEach(function (n) {
                  if (n && n.id) {
                    if (/_send$/.test(n.id) || /^time$/.test(n.id) || /^bweforvideo$/.test(n.id)) return;
                    -1 === n.id.indexOf("inbound_rtp") && -1 === n.id.indexOf("inbound-rtp") || "video" !== n.mediaType || (n.googFrameWidthReceived = e.videoWidth + "", n.googFrameHeightReceived = e.videoHeight + "");
                    var i = 200 * t;
                    t++;
                    var o = e.getId();
                    setTimeout(function () {
                      var e, t, i;
                      w((e = o, t = n, i = {}, Object.keys(t).forEach(function (e) {
                        i[Ce(e)] = t[e];
                      }), {
                        _type: "subscribe_stats",
                        options: {
                          id: e,
                          stats: i
                        },
                        sdp: null
                      }), null, null);
                    }, i);
                  } else ;
                });
              });
            }, 3e3), y.timers[e.getId() + "_RelatedStats"] = setInterval(function () {
              e && e.pc && (e.pc.getVideoRelatedStats && e.pc.getVideoRelatedStats(function (e) {
                N(u(e), null, null);
              }), e.pc.getAudioRelatedStats && e.pc.getAudioRelatedStats(function (e) {
                N(u(e), null, null);
              }));
            }, 1e3), y.audioLevel[e.getId()] = 0, y.timers[e.getId() + "audio"] = setInterval(function () {
              y.hasListeners("active-speaker") && e && e.pc && "established" === e.pc.state && e.pc.getStats && e.pc.getStats(function (t) {
                t.forEach(function (t) {
                  if ("audio" === t.mediaType) {
                    if (t.audioOutputLevel > 5e3) for (var n in y.audioLevel[e.getId()] < 20 && (y.audioLevel[e.getId()] += 1), y.audioLevel) {
                      n !== "" + e.getId() && y.audioLevel[n] > 0 && (y.audioLevel[n] -= 1);
                    }
                    var i = Object.keys(y.audioLevel).sort(function (e, t) {
                      return y.audioLevel[t] - y.audioLevel[e];
                    });

                    if (y.activeSpeaker !== i[0]) {
                      var a = c({
                        type: "active-speaker",
                        uid: i[0]
                      });
                      y.dispatchEvent(a), y.activeSpeaker = i[0], o.default.debug("[".concat(y.clientId, "] Update active speaker: ").concat(y.activeSpeaker));
                    }
                  }
                });
              });
            }, 50), e.pc.oniceconnectionstatechange = function (s) {
              if ("failed" === s) null != y.timers[e.getId()] && (clearInterval(y.timers[e.getId()]), clearInterval(y.timers[e.getId()] + "audio")), o.default.error("[".concat(y.clientId, "] Subscriber connection is lost -- streamId: ").concat(e.getId(), ", p2pId: ").concat(l)), o.default.debug("[".concat(y.clientId, "] subscribe p2p failed: "), y.p2ps), r || (r = !0, n && n(A.PEERCONNECTION_FAILED), a.b.subscribe(y.joinInfo.sid, {
                lts: i,
                succ: !1,
                video: e.subscribeOptions && e.subscribeOptions.video,
                audio: e.subscribeOptions && e.subscribeOptions.audio,
                peerid: e.getId(),
                ec: A.PEERCONNECTION_FAILED
              })), y.remoteStreams[e.getId()] && y.p2ps.has(l) && (y.p2ps.delete(l), y.dispatchEvent(c({
                type: "subP2PLost",
                stream: e
              })));else if ("connected" === s && (o.default.debug("[".concat(y.clientId, "] subscribe p2p connected: "), y.p2ps), !r)) return r = !0, a.b.subscribe(y.joinInfo.sid, {
                lts: i,
                succ: !0,
                video: e.subscribeOptions && e.subscribeOptions.video,
                audio: e.subscribeOptions && e.subscribeOptions.audio,
                peerid: e.getId(),
                ec: null
              }), y._adjustPCMuteStatus(e), y.firstAudioDecodeTimer.set(e.getId(), setInterval(function () {
                e.pc ? e.pc.getStats(function (t) {
                  t.forEach(function (t) {
                    -1 !== t.id.indexOf("recv") && "audio" === t.mediaType && parseInt(t.googDecodingNormal) > 0 && (clearInterval(y.firstAudioDecodeTimer.get(e.getId())), y.firstAudioDecodeTimer.delete(e.getId()), a.b.reportApiInvoke(y.joinInfo.sid, {
                      name: "firstAudioDecode"
                    })(null, {
                      elapse: Date.now() - e.subscribeLTS
                    }));
                  });
                }) : (clearInterval(y.firstAudioDecodeTimer.get(e.getId())), y.firstAudioDecodeTimer.delete(e.getId()));
              }, 100)), y.firstFrameTimer.set(e.getId(), setInterval(function () {
                e.pc ? e.pc.getStats(function (t) {
                  t.forEach(function (t) {
                    -1 === t.id.indexOf("recv") && -1 === t.id.indexOf("inbound_rtp") && -1 === t.id.indexOf("inbound-rtp") && -1 === t.id.indexOf("InboundRTP") || "video" === t.mediaType && (t.framesDecoded > 0 || t.googFramesDecoded > 0) && (clearInterval(y.firstFrameTimer.get(e.getId())), y.firstFrameTimer.delete(e.getId()), e.firstFrameTime = new Date().getTime() - e.subscribeLTS, a.b.firstRemoteFrame(y.joinInfo.sid, {
                      lts: new Date().getTime(),
                      peerid: e.getId(),
                      succ: !0,
                      width: +t.googFrameWidthReceived,
                      height: +t.googFrameHeightReceived
                    }));
                  });
                }) : (clearInterval(y.firstFrameTimer.get(e.getId())), y.firstFrameTimer.delete(e.getId()));
              }, 100)), e.sid = y.joinInfo.sid, t && t();
            };
          } else o.default.error("[".concat(y.clientId, "] Invalid remote stream")), r || (r = !0, n && n(A.INVALID_REMOTE_STREAM), a.b.subscribe(y.joinInfo.sid, {
            lts: i,
            succ: !1,
            video: e.subscribeOptions && e.subscribeOptions.video,
            audio: e.subscribeOptions && e.subscribeOptions.audio,
            peerid: e.getId(),
            ec: A.INVALID_REMOTE_STREAM
          }));
        } else o.default.error("[".concat(y.clientId, "] No such remote stream")), r || (r = !0, n && n(A.NO_SUCH_REMOTE_STREAM), a.b.subscribe(y.joinInfo.sid, {
          lts: i,
          succ: !1,
          video: e.subscribeOptions && e.subscribeOptions.video,
          audio: e.subscribeOptions && e.subscribeOptions.audio,
          peerid: e.getId(),
          ec: A.NO_SUCH_REMOTE_STREAM
        }));
      }, y.subscribeChange = function (e, t, n) {
        var i,
            r,
            s = Date.now();
        o.default.info("[".concat(y.clientId, "] Gatewayclient ").concat(y.uid, " SubscribeChange ").concat(e.getId(), ": ").concat(JSON.stringify(e.subscribeOptions))), y._adjustPCMuteStatus(e), N((i = e.getId(), r = e.subscribeOptions, {
          _type: "subscribe_change",
          options: I()({
            streamId: i
          }, r)
        }), function (i) {
          if ("error" === i) return o.default.error("[".concat(y.clientId, "] Subscribe Change Failed ").concat(e.getId())), void E(n, "SUBSCRIBE_CHANGE_FAILED");
          var r = d({
            type: "stream-subscribe-changed",
            stream: y.remoteStreams[e.getId()]
          });
          a.b.subscribe(y.joinInfo.sid, {
            lts: s,
            succ: !0,
            video: e.subscribeOptions && e.subscribeOptions.video,
            audio: e.subscribeOptions && e.subscribeOptions.audio,
            peerid: e.getId(),
            ec: null
          }), y.dispatchEvent(r), t && t();
        }, n);
      }, y._adjustPCMuteStatus = function (e) {
        !e.local && e.pc && e.pc.peerConnection.getReceivers && e.pc.peerConnection.getReceivers().forEach(function (t) {
          if (t && t.track && "audio" === t.track.kind) {
            var n = !e.userMuteAudio && !e.peerMuteAudio;
            e.subscribeOptions && !e.subscribeOptions.audio && (n = !1), t.track.enabled = !!n;
          } else if (t && t.track && "video" === t.track.kind) {
            var i = !e.userMuteVideo && !e.peerMuteVideo;
            e.subscribeOptions && !e.subscribeOptions.video && (i = !1), t.track.enabled = !!i;
          }
        });
      }, y.unsubscribe = function (e, t, n) {
        if ("object" !== v()(e) || null === e) return o.default.error("[".concat(y.clientId, "] Invalid remote stream")), void E(n, A.INVALID_REMOTE_STREAM);
        if (y.state !== S) return o.default.error("[".concat(y.clientId, "] User is not in the session")), void E(n, A.INVALID_OPERATION);

        if (null != y.timers[e.getId()] && (clearInterval(y.timers[e.getId()]), clearInterval(y.timers[e.getId()] + "audio")), null != y.audioLevel[e.getId()] && delete y.audioLevel[e.getId()], null != y.timer_counter[e.getId()] && delete y.timer_counter[e.getId()], y.remoteStreams.hasOwnProperty(e.getId())) {
          if (!y.socket) return o.default.error("[".concat(y.clientId, "] User is not in the session")), void E(n, A.INVALID_OPERATION);
          if (e.local) return o.default.error("[".concat(y.clientId, "] Invalid remote stream")), void E(n, A.INVALID_REMOTE_STREAM);
          e.close(), N({
            _type: "unsubscribe",
            message: e.getId()
          }, function (i) {
            if ("error" === i) return o.default.error("[".concat(y.clientId, "] Unsubscribe remote stream failed ").concat(e.getId())), void E(n, A.UNSUBSCRIBE_STREAM_FAILED);
            void 0 !== e.pc && (e.pc.close(), e.pc = void 0), e.onClose = void 0, e._onAudioMute = void 0, e._onAudioUnute = void 0, e._onVideoMute = void 0, e._onVideoUnmute = void 0, delete e.subscribeOptions, y.p2ps.delete(e.p2pId), o.default.info("[".concat(y.clientId, "] Unsubscribe stream success")), t && t();
          }, n);
        } else E(n, A.NO_SUCH_REMOTE_STREAM);
      }, y.setRemoteVideoStreamType = function (e, t) {
        if (o.default.debug("[".concat(y.clientId, "] Switching remote video stream ").concat(e.getId(), " to ").concat(t)), "object" === v()(e) && null !== e) {
          if (y.state === S) {
            if (!e.local) {
              switch (t) {
                case y.remoteVideoStreamTypes.REMOTE_VIDEO_STREAM_HIGH:
                case y.remoteVideoStreamTypes.REMOTE_VIDEO_STREAM_LOW:
                case y.remoteVideoStreamTypes.REMOTE_VIDEO_STREAM_MEDIUM:
                  break;

                default:
                  return;
              }

              N(function (e, t) {
                return {
                  _type: "switchVideoStream",
                  message: {
                    id: e,
                    type: t
                  }
                };
              }(e.getId(), t), null, null);
            }
          } else o.default.error("[".concat(y.clientId, "] User is not in the session"));
        } else o.default.error("[".concat(y.clientId, "] Invalid remote stream"));
      }, y.renewToken = function (e, t, n) {
        e ? y.key ? y.state !== S ? (o.default.debug("[".concat(y.clientId, "] Client is not connected. Trying to rejoin")), y.key = e, y.rejoin(), t && t()) : (o.default.debug("[".concat(y.clientId, "] renewToken from ").concat(y.key, " to ").concat(e)), N(function (e) {
          return {
            _type: "renew_token",
            message: {
              token: e
            }
          };
        }(e), t, n)) : (o.default.error("[".concat(y.clientId, "] Client is previously joined without token")), n && n(A.INVALID_PARAMETER)) : (o.default.error("[".concat(y.clientId, "] Invalid Token ").concat(e)), n && n(A.INVALID_PARAMETER));
      }, y.setStreamFallbackOption = function (e, t) {
        if (o.default.debug("[".concat(y.clientId, "] Set stream fallback option ").concat(e.getId(), " to ").concat(t)), "object" === v()(e) && null !== e) {
          if (y.state === S) {
            if (!e.local) {
              switch (t) {
                case y.streamFallbackTypes.STREAM_FALLBACK_OPTION_DISABLED:
                case y.streamFallbackTypes.STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW:
                case y.streamFallbackTypes.STREAM_FALLBACK_OPTION_AUDIO_ONLY:
                  break;

                default:
                  return;
              }

              N(function (e, t) {
                return {
                  _type: "setFallbackOption",
                  message: {
                    id: e,
                    type: t
                  }
                };
              }(e.getId(), t), null, null);
            }
          } else o.default.error("[".concat(y.clientId, "] User is not in the session"));
        } else o.default.error("[".concat(y.clientId, "] Invalid remote stream"));
      }, y.startLiveStreaming = function (e, t) {
        y.liveStreams.set(e, t), o.default.debug("[".concat(y.clientId, "] Start live streaming ").concat(e, " ").concat(t, " ").concat(t)), y.state === S ? N(function (e, t) {
          return {
            _type: "start_live_streaming",
            message: {
              url: e,
              transcodingEnabled: t
            }
          };
        }(e, t), null, null) : o.default.error("[".concat(y.clientId, "] User is not in the session"));
      }, y.stopLiveStreaming = function (e) {
        o.default.debug("[".concat(y.clientId, "] Stop live streaming ").concat(e)), y.state === S ? (y.liveStreams.delete(e), N(function (e) {
          return {
            _type: "stop_live_streaming",
            message: {
              url: e
            }
          };
        }(e), null, null)) : o.default.error("[".concat(y.clientId, "] User is not in the session"));
      }, y.setLiveTranscoding = function (e) {
        Object(G.d)(e) && (y.transcoding = e, o.default.debug("[".concat(y.clientId, "] Set live transcoding "), e), y.state === S ? N(function (e) {
          return {
            _type: "set_live_transcoding",
            message: {
              transcoding: e
            }
          };
        }(e), null, null) : o.default.error("[".concat(y.clientId, "] User is not in the session")));
      }, y.addInjectStreamUrl = function (e, t) {
        y.injectLiveStreams.set(e, t), o.default.debug("[".concat(y.clientId, "] Add inject stream url ").concat(e, " config "), t), y.state === S ? N(function (e, t) {
          return {
            _type: "add_inject_stream_url",
            message: {
              url: e,
              config: t
            }
          };
        }(e, t), null, null) : o.default.error("[".concat(y.clientId, "] User is not in the session"));
      }, y.removeInjectStreamUrl = function (e) {
        o.default.debug("[".concat(y.clientId, "] Remove inject stream url ").concat(e)), y.state === S ? (y.injectLiveStreams.delete(e), N(function (e) {
          return {
            _type: "remove_inject_stream_url",
            message: {
              url: e
            }
          };
        }(e), null, null)) : o.default.error("[".concat(y.clientId, "] User is not in the session"));
      }, y.enableAudioVolumeIndicator = function (e, t) {
        y.audioVolumeIndication.enabled = !0, y.audioVolumeIndication.interval = e, y.audioVolumeIndication.smooth = t, y.resetAudioVolumeIndication();
      }, y.resetAudioVolumeIndication = function () {
        if (clearInterval(y.timers.audioVolumeIndication), clearInterval(y.timers.audioVolumeSampling), y.audioVolumeIndication.enabled && y.audioVolumeIndication.interval) {
          var e = Math.floor(1e3 * y.audioVolumeIndication.smooth / 100);
          y.timers.audioVolumeSampling = setInterval(function () {
            y.audioVolumeSampling || (y.audioVolumeSampling = {});
            var t = {};

            for (var n in y.remoteStreams) {
              var i = y.remoteStreams[n];

              if (i.stream && i.hasAudio()) {
                var o = i.getAudioLevel();
                o > 0 && o < 1 && (o *= 100);
                var a = y.audioVolumeSampling[n] || [];

                for (a.push(o); a.length > e;) {
                  a.shift();
                }

                t[n] = a;
              }
            }

            y.audioVolumeSampling = t;
          }, 100), y.timers.audioVolumeIndication = setInterval(function () {
            var e = [];

            for (var t in y.remoteStreams) {
              if (y.audioVolumeSampling && y.audioVolumeSampling[t]) {
                var n = y.audioVolumeSampling[t],
                    i = 0;
                n.forEach(function (e) {
                  i += e;
                });
                var a = {
                  uid: t,
                  level: Math.floor(i / n.length)
                };
                a.level && e.push(a);
              }
            }

            var r = e.sort(function (e, t) {
              return e.level - t.level;
            });
            o.default.debug("[".concat(y.clientId, "] volume-indicator "), JSON.stringify(r)), y.audioVolumeIndication.sortedAudioVolumes = r;
            var s = c({
              type: "volume-indicator",
              attr: r
            });
            y.dispatchEvent(s);
          }, y.audioVolumeIndication.interval);
        }
      }, y.closeGateway = function () {
        o.default.debug("[".concat(y.clientId, "] close gateway")), y.state = m, y.socket.close(), T();
      };

      var T = function T() {
        for (var e in y.timers) {
          y.timers.hasOwnProperty(e) && clearInterval(y.timers[e]);
        }

        for (var e in y.remoteStreams) {
          if (y.remoteStreams.hasOwnProperty(e)) {
            var t = y.remoteStreams[e],
                n = c({
              type: "stream-removed",
              uid: t.getId(),
              stream: t
            });
            y.dispatchEvent(n);
          }
        }

        y.p2ps.clear(), k(), D(), clearInterval(y.pingTimer);
      };

      y.rejoin = function () {
        y.socket && (clearInterval(y.pingTimer), y.socket.close(), y.socket = void 0), y.state = g, O();
      };

      var O = function O(e, t) {
        y.dispatchEvent(c({
          type: "rejoin-start"
        })), e = e || function (e) {
          o.default.info("[".concat(y.clientId, "] User ").concat(e, " is re-joined to ").concat(y.joinInfo.cname)), y.dispatchEvent(c({
            type: "rejoin"
          })), y.liveStreams && y.liveStreams.size && y.liveStreams.forEach(function (e, t) {
            e && y.setLiveTranscoding(y.transcoding), y.startLiveStreaming(t, e);
          }), y.injectLiveStreams && y.injectLiveStreams.size && y.injectLiveStreams.forEach(function (e, t) {
            y.addInjectStreamUrl(t, e);
          });
        }, t = t || function (e) {
          o.default.error("[".concat(y.clientId, "] Re-join to channel failed "), e), y.dispatchEvent(d({
            type: "error",
            reason: e
          }));
        }, y.key ? (++y.rejoinAttempt, y.join(y.joinInfo, y.key, e, t)) : o.default.error("[".concat(y.clientId, "] Connection recover failed [Invalid channel key]"));
      },
          C = function C(e, t, i) {
        var r;
        y.onConnect = t, void 0 !== y.socket ? (y.dispatchEvent({
          type: "reconnect"
        }), "retry" === y.reconnectMode ? (o.default.debug("[".concat(y.clientId, "] Retry current gateway")), y.socket.reconnect()) : "tryNext" === y.reconnectMode ? (o.default.debug("[".concat(y.clientId, "] Try next gateway")), y.socket.connectNext()) : "recover" === y.reconnectMode && (o.default.debug("[".concat(y.clientId, "] Recover gateway")), o.default.debug("[".concat(y.clientId, "] Try to reconnect choose server and get gateway list again ")), be(y.joinInfo, function (e) {
          y.socket.replaceHost(e.gateway_addr);
        }))) : (r = e.gatewayAddr, y.socket = ge(r, {
          sid: y.joinInfo.sid,
          clientId: y.clientId
        }), y.socket.on("onUplinkStats", function (e) {
          y.OutgoingAvailableBandwidth = e.uplink_available_bandwidth, y.localStreams[y.uid] && (y.localStreams[y.uid].uplinkStats = e);
        }), y.socket.on("connect", function () {
          y.dispatchEvent({
            type: "connected"
          }), y.attemps = 1, N(function (e) {
            var t = e;
            return e.uni_lbs_ip && (t = I()(e, {
              wanip: e.uni_lbs_ip,
              hasChange: y.hasChangeBGPAddress
            })), {
              _type: "token",
              message: t
            };
          }(e), y.onConnect, i);
        }), y.socket.on("recover", function () {
          y.state = g, o.default.debug("[".concat(y.clientId, "] Try to reconnect choose server and get gateway list again ")), be(y.joinInfo, function (e) {
            y.socket.replaceHost(e.gateway_addr);
          });
        }), y.socket.on("disconnect", function (e) {
          if (y.state !== m) {
            y.state = m;
            var t = d({
              type: "error",
              reason: A.SOCKET_DISCONNECTED
            });

            if (y.dispatchEvent(t), 0 === y.p2ps.size ? y.reconnectMode = "tryNext" : y.reconnectMode = "retry", T(), 1 != n) {
              var i,
                  a = (i = y.attemps, 1e3 * Math.min(30, Math.pow(2, i) - 1));
              o.default.error("[".concat(y.clientId, "] Disconnect from server [").concat(e, "], attempt to recover [#").concat(y.attemps, "] after ").concat(a / 1e3, " seconds"));
              setTimeout(function () {
                y.attemps++, y.state = g, O();
              }, a);
            }
          }
        }), y.socket.on("onAddAudioStream", function (e) {
          if (o.default.info("[".concat(y.clientId, "] Newly added audio stream with uid ").concat(e.id)), y.remoteStreamsInChannel.has(e.id) || y.remoteStreamsInChannel.add(e.id), void 0 === y.remoteStreams[e.id]) {
            var t = se({
              streamID: e.id,
              local: !1,
              audio: e.audio,
              video: e.video,
              screen: e.screen,
              attributes: e.attributes
            });
            y.remoteStreams[e.id] = t;
            var n = d({
              type: "stream-added",
              stream: t
            });
            y.dispatchEvent(n);
          }
        }), y.socket.on("onUpdateStream", function (e) {
          var t = y.remoteStreams[e.id];

          if (t) {
            delete e.id, t.audio = e.audio, t.video = e.video, t.screen = e.screen, t.pc && y._adjustPCMuteStatus(t);
            var n = d({
              type: "stream-updated",
              stream: t
            });
            y.dispatchEvent(n);
          } else o.default.debug("[".concat(y.clientId, "] Ignoring onUpdateStream event before onAddStream for uid ").concat(e.id));
        }), y.socket.on("onAddVideoStream", function (e) {
          if (o.default.info("[".concat(y.clientId, "] Newly added remote stream with uid ").concat(e.id, ".")), y.remoteStreamsInChannel.has(e.id) || y.remoteStreamsInChannel.add(e.id), void 0 === y.remoteStreams[e.id]) {
            var t = se({
              streamID: e.id,
              local: !1,
              audio: e.audio,
              video: e.video,
              screen: e.screen,
              attributes: e.attributes
            });
            y.remoteStreams[e.id] = t;
            var n = d({
              type: "stream-added",
              stream: t
            });
            y.dispatchEvent(n);
          } else {
            var i = y.remoteStreams[e.id];

            if (void 0 !== i.stream) {
              if ((t = y.remoteStreams[e.id]).video = !0, t._unmuteVideo(), o.default.info("[".concat(y.clientId, "] Stream changed: enable video ").concat(e.id)), t.isPlaying()) {
                var a = t.player.elementID;
                t.stop(), t.play(a);
              }
            } else if (i.p2pId) y.remoteStreams[e.id].video = !0;else {
              t = se({
                streamID: e.id,
                local: !1,
                audio: !0,
                video: !0,
                screen: !1,
                attributes: e.attributes
              });
              y.remoteStreams[e.id] = t, o.default.info("[".concat(y.clientId, "] Stream changed: modify video ").concat(e.id));
            }
          }
        }), y.socket.on("onRemoveStream", function (e) {
          y.remoteStreamsInChannel.has(e.id) && y.remoteStreamsInChannel.delete(e.id);
          var t = y.remoteStreams[e.id];

          if (t) {
            delete y.remoteStreams[e.id];
            var n = d({
              type: "stream-removed",
              stream: t
            });
            y.dispatchEvent(n), t.close(), void 0 !== t.pc && (t.pc.close(), t.pc = void 0, y.p2ps.delete(t.p2pId));
          } else console.log("ERROR stream ", e.id, " not found onRemoveStream ", e);
        }), y.socket.on("onPublishStream", function (e) {
          var t = y.localStreams[e.id],
              n = d({
            type: "streamPublished",
            stream: t
          });
          y.dispatchEvent(n);
        }), y.socket.on("mute_audio", function (e) {
          o.default.info("[".concat(y.clientId, "] rcv peer mute audio: ").concat(e.peerid));
          var t = c({
            type: "mute-audio",
            uid: e.peerid
          }),
              n = y.remoteStreams[e.peerid];
          n && (n.peerMuteAudio = !0), n.pc && y._adjustPCMuteStatus(n), y.dispatchEvent(t);
        }), y.socket.on("unmute_audio", function (e) {
          o.default.info("[".concat(y.clientId, "] rcv peer unmute audio: ").concat(e.peerid));
          var t = c({
            type: "unmute-audio",
            uid: e.peerid
          }),
              n = y.remoteStreams[e.peerid];
          n && (n.peerMuteAudio = !1), n.pc && y._adjustPCMuteStatus(n), y.dispatchEvent(t);
        }), y.socket.on("mute_video", function (e) {
          o.default.info("[".concat(y.clientId, "] rcv peer mute video: ").concat(e.peerid));
          var t = c({
            type: "mute-video",
            uid: e.peerid
          }),
              n = y.remoteStreams[e.peerid];
          n && (n.peerMuteVideo = !0), n.pc && y._adjustPCMuteStatus(n), y.dispatchEvent(t);
        }), y.socket.on("unmute_video", function (e) {
          o.default.info("[".concat(y.clientId, "] rcv peer unmute video: ").concat(e.peerid));
          var t = c({
            type: "unmute-video",
            uid: e.peerid
          }),
              n = y.remoteStreams[e.peerid];
          n && (n.peerMuteVideo = !1), n.pc && y._adjustPCMuteStatus(n), y.dispatchEvent(t);
        }), y.socket.on("user_banned", function (e) {
          o.default.info("[".concat(y.clientId, "] user banned uid: ").concat(e.id, " error: ").concat(e.errcode));
          var t = c({
            type: "client-banned",
            uid: e.id,
            attr: e.errcode
          });
          y.dispatchEvent(t), n = !0, leave();
        }), y.socket.on("stream_fallback", function (e) {
          o.default.info("[".concat(y.clientId, "] stream fallback uid: ").concat(e.id, " peerId: ").concat(e.peerid, " type: ").concat(e.type));
          var t = c({
            type: "stream-fallback",
            uid: e.id,
            stream: e.peerid,
            attr: e.type
          });
          y.dispatchEvent(t);
        }), y.socket.on("stream_recover", function (e) {
          o.default.info("[".concat(y.clientId, "] stream recover uid: ").concat(e.id, " peerId: ").concat(e.peerid, " type: ").concat(e.type));
          var t = c({
            type: "stream-recover",
            uid: e.id,
            stream: e.peerid,
            attr: e.type
          });
          y.dispatchEvent(t);
        }), y.socket.on("onP2PLost", function (e) {
          if (o.default.debug("[".concat(y.clientId, "] p2plost: "), e, "p2ps:", y.p2ps), "publish" === e.event) {
            var t = y.localStreams[e.uid];
            t && a.b.publish(y.joinInfo.sid, {
              lts: t.publishLTS,
              succ: !1,
              audioName: t.hasAudio() && t.audioName,
              videoName: t.hasVideo() && t.videoName,
              screenName: t.hasScreen() && t.screenName,
              ec: "DTLS failed"
            });
          }

          if ("subscribe" === e.event) {
            var n = y.remoteStreams[e.uid];
            n && a.b.subscribe(y.joinInfo.sid, {
              lts: n.subscribeLTS,
              succ: !1,
              video: n.subscribeOptions && n.subscribeOptions.video,
              audio: n.subscribeOptions && n.subscribeOptions.audio,
              peerid: e.uid + "",
              ec: "DTLS failed"
            });
          }

          o.default.debug("[".concat(y.clientId, "] p2plost:"), e.p2pid);
          var i = y.p2ps.get(e.p2pid);
          i && (y.p2ps.delete(e.p2pid), i.local ? y.dispatchEvent(c({
            type: "pubP2PLost",
            stream: i
          })) : y.remoteStreams[i.getId()] && y.dispatchEvent(c({
            type: "subP2PLost",
            stream: i
          })));
        }), y.socket.on("onTokenPrivilegeWillExpire", function (e) {
          o.default.debug("[".concat(y.clientId, "] Received Message onTokenPrivilegeWillExpire")), y.dispatchEvent(c({
            type: "onTokenPrivilegeWillExpire"
          }));
        }), y.socket.on("onTokenPrivilegeDidExpire", function () {
          o.default.warning("[".concat(y.clientId, "] Received Message onTokenPrivilegeDidExpire, please get new token and join again")), y.closeGateway(), y.dispatchEvent(c({
            type: "onTokenPrivilegeDidExpire"
          }));
        }), y._doWithAction = function (e, t, n) {
          "tryNext" === e ? function (e, t) {
            o.default.debug("[".concat(y.clientId, "] Connect next gateway")), y.state = m, y.socket.close(), T(), y.reconnectMode = "tryNext", O(e, t);
          }(t, n) : "retry" === e ? function (e, t) {
            o.default.debug("[".concat(y.clientId, "] Reconnect gateway")), y.state = m, y.socket.close(), T(), y.reconnectMode = "retry", O(e, t);
          }(t, n) : "quit" === e ? (o.default.debug("[".concat(y.clientId, "] quit gateway")), y.state = m, y.socket.close(), T()) : "recover" === e && (o.default.debug("[".concat(y.clientId, "] Reconnect gateway")), y.state = m, y.socket.close(), T(), y.reconnectMode = "recover", O());
        }, y.socket.on("notification", function (e) {
          if (o.default.debug("[".concat(y.clientId, "] Receive notification: "), e), "ERR_JOIN_BY_MULTI_IP" === b[e.code]) return y.dispatchEvent({
            type: "onMultiIP",
            arg: e
          });
          e.detail ? y._doWithAction(Ee[b[e.code]]) : e.action && y._doWithAction(e.action);
        }), y.socket.on("onPeerLeave", function (e) {
          var t = c({
            type: "peer-leave",
            uid: e.id
          });

          if (y.remoteStreamsInChannel.has(e.id) && y.remoteStreamsInChannel.delete(e.id), y.remoteStreams.hasOwnProperty(e.id) && (t.stream = y.remoteStreams[e.id]), y.dispatchEvent(t), y.remoteStreams.hasOwnProperty(e.id)) {
            o.default.info("[".concat(y.clientId, "] closing stream on peer leave"), e.id);
            var n = y.remoteStreams[e.id];
            n.close(), delete y.remoteStreams[e.id], void 0 !== n.pc && (n.pc.close(), n.pc = void 0, y.p2ps.delete(n.p2pId));
          }

          y.timers.hasOwnProperty(e.id) && (clearInterval(y.timers[e.id]), clearInterval(y.timers[e.id] + "_RelatedStats"), delete y.timers[e.id]), null != y.audioLevel[e.id] && delete y.audioLevel[e.id], null != y.timer_counter[e.id] && delete y.timer_counter[e.id];
        }), y.socket.on("onUplinkStats", function (e) {}), y.socket.on("liveStreamingStarted", function (e) {
          var t = l({
            type: "liveStreamingStarted",
            url: e.url
          });
          y.dispatchEvent(t);
        }), y.socket.on("liveStreamingFailed", function (e) {
          var t = l({
            type: "liveStreamingFailed",
            url: e.url
          });
          y.dispatchEvent(t);
        }), y.socket.on("liveStreamingStopped", function (e) {
          var t = l({
            type: "liveStreamingStopped",
            url: e.url
          });
          y.dispatchEvent(t);
        }), y.socket.on("liveTranscodingUpdated", function (e) {
          var t = l({
            type: "liveTranscodingUpdated",
            reason: e.reason
          });
          y.dispatchEvent(t);
        }), y.socket.on("streamInjectedStatus", function (e) {
          var t = l({
            type: "streamInjectedStatus",
            url: e.url,
            uid: e.uid,
            status: e.status
          });
          y.dispatchEvent(t);
        }), y.socket.on("onUserOnline", function (e) {
          y.dispatchEvent({
            type: "peer-online",
            uid: e.id
          });
        }));
      },
          N = function N(e, t, n) {
        if (void 0 === y.socket) return o.default.error("[".concat(y.clientId, "] No socket available")), void E(n, A.INVALID_OPERATION);

        try {
          y.socket.emitSimpleMessage(e, function (e, i) {
            "success" === e ? "function" == typeof t && t(i) : "function" == typeof n && n(b[i] || i);
          });
        } catch (t) {
          o.default.error("[".concat(y.clientId, "] Socket emit message failed ").concat(JSON.stringify(e))), o.default.error("[".concat(y.clientId, "] "), t), E(n, A.SOCKET_ERROR);
        }
      },
          w = function w(e, t) {
        if (void 0 !== y.socket) try {
          y.socket.emitSimpleMessage(e, function (e, n) {
            t && t(e, n);
          });
        } catch (e) {
          o.default.error("[".concat(y.clientId, "] Error in sendSimpleSdp [").concat(e, "]"));
        } else o.default.error("[".concat(y.clientId, "] Error in sendSimpleSdp [socket not ready]"));
      },
          D = function D() {
        for (var e in y.localStreams) {
          if (void 0 !== y.localStreams[e]) {
            var t = y.localStreams[e];
            delete y.localStreams[e], void 0 !== t.pc && (t.pc.close(), t.pc = void 0);
          }
        }
      },
          k = function k() {
        for (var e in y.remoteStreamsInChannel.clear(), y.remoteStreams) {
          if (y.remoteStreams.hasOwnProperty(e)) {
            var t = y.remoteStreams[e];
            t.isPlaying() && t.stop(), t.close(), delete y.remoteStreams[e], void 0 !== t.pc && (t.pc.close(), t.pc = void 0);
          }
        }
      };

      return y;
    },
        we = {
      _gatewayClients: {},
      register: function register(e, t) {
        if (!t.uid) {
          var n = "NO_UID_PROVIDED";
          return o.default.error("[".concat(e.clientId, "] "), n, t), n;
        }

        if (t.cname) {
          if (this._gatewayClients[t.cname] && this._gatewayClients[t.cname][t.uid] && this._gatewayClients[t.cname][t.uid] !== e) {
            n = "UID_CONFLICT";
            return o.default.error("[".concat(e.clientId, "] "), n, t), n;
          }

          return o.default.debug("[".concat(e.clientId, "] register client Channel"), t.cname, "Uid", t.uid), this._gatewayClients[t.cname] || (this._gatewayClients[t.cname] = {}), this._gatewayClients[t.cname][t.uid] = e, null;
        }

        var n = "NO_CHANNEL_PROVIDED";
        return o.default.error("[".concat(e.clientId, "] "), n, t), n;
      },
      unregister: function unregister(e) {
        var t = e && e.uid,
            n = e.joinInfo && e.joinInfo.cname;

        if (!t || !n) {
          var i = "INVALID_GATEWAYCLIENT";
          return o.default.error("[".concat(e.clientId, "] "), i), i;
        }

        if (this._gatewayClients[n] && this._gatewayClients[n][t]) {
          if (this._gatewayClients[n][t] !== e) {
            i = "GATEWAYCLIENT_UID_CONFLICT";
            return o.default.error("[".concat(e.clientId, "] "), i), i;
          }

          return o.default.debug("[".concat(e.clientId, "] unregister client "), e.uid), delete this._gatewayClients[n][t], null;
        }

        var i = "GATEWEAY_CLIENT_UNREGISTERED";
        o.default.error("[".concat(e.clientId, "] "), i);
      }
    };

    Ne.DISCONNECTED = 0, Ne.CONNECTING = 1, Ne.CONNECTED = 2, Ne.DISCONNECTING = 3, Ne.connetionStateMap = {
      0: "DISCONNECTED",
      1: "CONNECTING",
      2: "CONNECTED",
      3: "DISCONNECTING"
    };

    var De = Ne,
        ke = function ke(e) {
      var t;

      switch (e) {
        case "120p":
        case "120p_1":
          t = ["120p_1", "120p_1", "120p_1"];
          break;

        case "120p_3":
          t = ["120p_3", "120p_3", "120p_3"];
          break;

        case "180p":
        case "180p_1":
          t = ["90p_1", "90p_1", "180p_1"];
          break;

        case "180p_3":
          t = ["120p_3", "120p_3", "180p_3"];
          break;

        case "180p_4":
          t = ["120p_1", "120p_1", "180p_4"];
          break;

        case "240p":
        case "240p_1":
          t = ["120p_1", "120p_1", "240p_1"];
          break;

        case "240p_3":
          t = ["120p_3", "120p_3", "240p_3"];
          break;

        case "240p_4":
          t = ["120p_4", "120p_4", "240p_4"];
          break;

        case "360p":
        case "360p_1":
        case "360p_4":
        case "360p_9":
        case "360p_10":
        case "360p_11":
          t = ["90p_1", "90p_1", "360p_1"];
          break;

        case "360p_3":
        case "360p_6":
          t = ["120p_3", "120p_3", "360p_3"];
          break;

        case "360p_7":
        case "360p_8":
          t = ["120p_1", "120p_1", "360p_7"];
          break;

        case "480p":
        case "480p_1":
        case "480p_2":
        case "480p_4":
        case "480p_10":
          t = ["120p_1", "120p_1", "480p_1"];
          break;

        case "480p_3":
        case "480p_6":
          t = ["120p_3", "120p_3", "480p_3"];
          break;

        case "480p_8":
        case "480p_9":
          t = ["120p_4", "120p_4", "480p_8"];
          break;

        case "720p":
        case "720p_1":
        case "720p_2":
        case "720p_3":
          t = ["90p_1", "90p_1", "720p_1"];
          break;

        case "720p_5":
        case "720p_6":
          t = ["120p_1", "120p_1", "720p_5"];
          break;

        case "1080p":
        case "1080p_1":
        case "1080p_2":
        case "1080p_3":
        case "1080p_5":
          t = ["90p_1", "90p_1", "1080p_1"];
          break;

        case "1440p":
        case "1440p_1":
        case "1440p_2":
          t = ["90p_1", "90p_1", "1440p_1"];
          break;

        case "4k":
        case "4k_1":
        case "4k_3":
          t = ["90p_1", "90p_1", "4k_1"];
          break;

        default:
          t = ["120p_1", "120p_1", "360p_7"];
      }

      return Object(p.isOpera)() ? [e, 15, 50] : Object(p.isFireFox)() ? [t[1], 15, 100] : Object(p.isSafari)() ? [t[2], 15, 50] : [t[0], 15, 50];
    },
        Me = {
      1001: "FRAMERATE_INPUT_TOO_LOW",
      1002: "FRAMERATE_SENT_TOO_LOW",
      1003: "SEND_VIDEO_BITRATE_TOO_LOW",
      1005: "RECV_VIDEO_DECODE_FAILED",
      2001: "AUDIO_INPUT_LEVEL_TOO_LOW",
      2002: "AUDIO_OUTPUT_LEVEL_TOO_LOW",
      2003: "SEND_AUDIO_BITRATE_TOO_LOW",
      2005: "RECV_AUDIO_DECODE_FAILED",
      3001: "FRAMERATE_INPUT_TOO_LOW_RECOVER",
      3002: "FRAMERATE_SENT_TOO_LOW_RECOVER",
      3003: "SEND_VIDEO_BITRATE_TOO_LOW_RECOVER",
      3005: "RECV_VIDEO_DECODE_FAILED_RECOVER",
      4001: "AUDIO_INPUT_LEVEL_TOO_LOW_RECOVER",
      4002: "AUDIO_OUTPUT_LEVEL_TOO_LOW_RECOVER",
      4003: "SEND_AUDIO_BITRATE_TOO_LOW_RECOVER",
      4005: "RECV_AUDIO_DECODE_FAILED_RECOVER"
    },
        Pe = {
      FramerateInput: 1001,
      FramerateSent: 1002,
      SendVideoBitrate: 1003,
      VideoDecode: 1005,
      AudioIntputLevel: 2001,
      AudioOutputLevel: 2002,
      SendAudioBitrate: 2003,
      AudioDecode: 2005
    },
        Le = function Le(e) {
      var t = {
        remoteStreamStorage: {},
        localStreamStorage: {}
      };
      return t.gatewayClient = e, t.checkAudioOutputLevel = function (e) {
        return !(e && parseInt(e.audioRecvBytesDelta) > 0 && parseInt(e.audioDecodingNormalDelta) > 0 && 0 === parseInt(e.audioOutputLevel));
      }, t.checkAudioIntputLevel = function (e) {
        return !e || 0 !== parseInt(e.audioInputLevel);
      }, t.checkFramerateInput = function (e, t) {
        if (!e || !t.attributes) return !0;
        var n = parseInt(t.attributes.maxFrameRate),
            i = parseInt(e.googFrameRateInput);
        return !n || !i || !(n > 10 && i < 5 || n < 10 && n >= 5 && i <= 1);
      }, t.checkFramerateSent = function (e) {
        return !(e && parseInt(e.googFrameRateInput) > 5 && parseInt(e.googFrameRateSent) <= 1);
      }, t.checkSendVideoBitrate = function (e) {
        return !e || 0 !== parseInt(e.videoSendBytesDelta);
      }, t.checkSendAudioBitrate = function (e) {
        return !e || 0 !== parseInt(e.audioSendBytesDelta);
      }, t.checkVideoDecode = function (e) {
        return !e || 0 === parseInt(e.videoRecvBytesDelta) || 0 !== parseInt(e.googFrameRateDecoded);
      }, t.checkAudioDecode = function (e) {
        return !e || 0 === parseInt(e.audioRecvBytesDelta) || 0 !== parseInt(e.audioDecodingNormalDelta);
      }, t.record = function (e, n, i, o, a) {
        i[e] || (i[e] = {
          isPrevNormal: !0,
          record: []
        });
        var r = i[e],
            s = t["check" + e](n, a);

        if (r.record.push(s), r.record.length >= 5) {
          r.isCurNormal = r.record.includes(!0);
          var d = Pe[e];
          r.isPrevNormal && !r.isCurNormal && t.gatewayClient.dispatchEvent({
            type: "exception",
            code: d,
            msg: Me[d],
            uid: o
          }), !r.isPrevNormal && r.isCurNormal && t.gatewayClient.dispatchEvent({
            type: "exception",
            code: d + 2e3,
            msg: Me[d + 2e3],
            uid: o
          }), r.isPrevNormal = r.isCurNormal, r.record = [];
        }
      }, t.setLocalStats = function (e) {
        var n = {};
        Object.keys(e).map(function (i) {
          var o = e[i],
              a = t.gatewayClient.localStreams[parseInt(i)],
              r = t.localStreamStorage[i] || {};
          a && a.hasVideo() && (t.record("SendVideoBitrate", o.videoStats, r, i), t.record("FramerateInput", o.videoStats, r, i, a), t.record("FramerateSent", o.videoStats, r, i)), a && a.hasAudio() && (t.record("AudioIntputLevel", o.audioStats, r, i), t.record("SendAudioBitrate", o.audioStats, r, i)), n[i] = r;
        }), t.localStreamStorage = n;
      }, t.setRemoteStats = function (n) {
        var i = {};
        Object.keys(n).map(function (o) {
          var a = n[o],
              r = e.remoteStreams[o],
              s = t.remoteStreamStorage[o] || {};
          r && r.hasVideo() && r.isPlaying() && t.record("VideoDecode", a.videoStats, s, o), r && r.hasAudio() && r.isPlaying() && (t.record("AudioOutputLevel", a.audioStats, s, o), t.record("AudioDecode", a.audioStats, s, o)), i[o] = s;
        }), t.remoteStreamStorage = i;
      }, t;
    },
        xe = new function () {
      var e = r();
      return e.states = {
        UNINIT: "UNINIT",
        INITING: "INITING",
        INITED: "INITED"
      }, e.state = e.states.UNINIT, e.type = null, e.lastConnectedAt = null, e.lastDisconnectedAt = null, e.lastTypeChangedAt = null, e.networkChangeTimer = null, e._init = function (t, n) {
        if (e.state = e.states.INITING, navigator.connection && navigator.connection.addEventListener) {
          var i = e._getNetworkInfo();

          e.type = i && i.type, e.state = e.states.INITED, t && t();
        } else e.state = e.states.UNINIT, n && n("DO_NOT_SUPPORT");
      }, e._getNetworkInfo = function () {
        return navigator.connection;
      }, e._reloadNetworkInfo = function () {
        var t = e._getNetworkInfo(),
            n = t && t.type || "UNSUPPORTED",
            i = Date.now();

        if (n !== e.type) {
          e.lastTypeChangedAt = i, "none" == n ? e.lastDisconnectedAt = i : "none" == e.type && (e.lastConnectedAt = i), e.type = n;
          var o = {
            type: "networkTypeChanged",
            networkType: n
          };
          e.dispatchEvent(o);
        }
      }, e.getStats = function (t, n) {
        var i = {},
            o = e._getNetworkInfo();

        o && (i.NetworkType = o.type || "UNSUPPORTED"), setTimeout(function () {
          t(i);
        }, 0);
      }, e._init(function () {
        navigator.connection.addEventListener("change", function () {
          e._reloadNetworkInfo();
        }), e.networkChangeTimer = setInterval(function () {
          e._reloadNetworkInfo();
        }, 5e3);
      }, function (e) {}), e;
    }(),
        Ve = function Ve(e) {
      var t = {
        key: void 0,
        highStream: null,
        lowStream: null,
        lowStreamParameter: null,
        isDualStream: !1,
        highStreamState: 2,
        lowStreamState: 2,
        proxyServer: null,
        turnServer: {},
        useProxyServer: !1
      };
      t.mode = e.mode, t.clientId = Object(G.b)().slice(0, 5);
      e = I()({}, e);
      return t.aespassword = null, t.aesmode = "none", t.hasPublished = !1, t.getConnectionState = function () {
        var n = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.getConnectionState",
          options: arguments,
          tag: "tracer"
        }),
            i = De.connetionStateMap[t.gatewayClient.state];
        return n(), i;
      }, t.setClientRole = function (n, i) {
        var r = a.b.reportApiInvoke(e.sessionId, {
          callback: i,
          name: "Client.setClientRole",
          options: arguments,
          tag: "tracer"
        });

        if (Y(n, "setClientRole", ["host", "audience"]), "rtc" === t.mode) {
          var s = "RTC mode can not use setClientRole";
          return o.default.warning("[".concat(t.clientId, "] ").concat(s)), r && r(s);
        }

        t.gatewayClient && t.gatewayClient.state === De.CONNECTED ? ("audience" === n && (0 === this.highStreamState ? this._unpublish(this.highStream, function () {
          r && r(null, {
            role: n
          });
        }, function (e) {
          r && r(e);
        }) : t.gatewayClient.setClientRole("audience", r)), "host" === n && t.gatewayClient.setClientRole("host", r)) : (t.gatewayClient.role = n, r && r(null, {
          role: n
        }));
      }, t.getGatewayInfo = function (e) {
        if (t.gatewayClient.state !== De.CONNECTED) {
          var n = "Client is not in connected state";
          return o.default.error("[".concat(t.clientId, "] ").concat(n)), void e(n);
        }

        t.gatewayClient.getGatewayInfo(function (t) {
          e(null, t);
        }, e);
      }, t.renewToken = function (n, i, r) {
        var s = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return r && r(e);
            i && i(t);
          },
          name: "Client.renewToken",
          options: arguments,
          tag: "tracer"
        });
        if (!ne(n)) throw new Error("Invalid token: Token is of the string type .Length of the string: [1,255]. ASCII characters only.");
        t.gatewayClient || (o.default.error("[".concat(t.clientId, "] renewToken Failed. GatewayClient not Exist")), s(A.INVALID_OPERATION)), t.key ? (t.key = n, t.gatewayClient.renewToken(n, function (e) {
          return s(null, e);
        }, s)) : (o.default.error("[".concat(t.clientId, "] renewToken should not be called before user join")), s(A.INVALID_OPERATION));
      }, t.setLowStreamParameter = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setLowStreamParameter",
          options: arguments,
          tag: "tracer"
        });
        q(n, "param");
        var r = n.width,
            s = n.height,
            d = n.framerate,
            c = n.bitrate;
        re(r) || X(r, "width"), re(s) || X(s, "height"), re(d) || X(d, "framerate"), re(c) || X(c, "bitrate", 1, 1e7), (!r && s || r && !s) && o.default.warning("[".concat(t.clientId, "] The width and height parameters take effect only when both are set")), t.lowStreamParameter = n, i();
      }, t.init = function (n, i, r) {
        var s = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return r && r(e);
            i && i(t);
          },
          name: "Client.init",
          options: arguments,
          tag: "tracer"
        });
        Q(n), Object(p.isChromeKernel)() && Object(p.getChromeKernelVersion)() <= 48 ? r ? s(A.BAD_ENVIRONMENT) : Object(G.f)() : (o.default.info("[".concat(t.clientId, "] Initializing AgoraRTC client, appId: ").concat(n, ".")), e.appId = n, e.sessionId = Object(G.b)(), s());
      }, t.setTurnServer = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setTurnServer",
          options: arguments,
          tag: "tracer"
        });
        if (t.gatewayClient && t.gatewayClient.state !== De.DISCONNECTED) throw new Error("Set turn server before join channel");
        if (t.useProxyServer) throw new Error("You have already set the proxy");
        q(n, "turnServer");
        var r = n.turnServerURL,
            s = n.username,
            d = n.password,
            c = n.udpport,
            u = n.forceturn,
            l = n.tcpport;
        Q(r, "turnServerURL"), Q(s, "username"), Q(d, "password"), Q(c, "udpport"), re(u) || $(u, "forceturn"), t.turnServer.url = r, t.turnServer.udpport = c, t.turnServer.username = s, t.turnServer.credential = d, t.turnServer.forceturn = u || !1, re(l) || (Q(l, "tcpport"), t.turnServer.tcpport = l, o.default.info("[".concat(t.clientId, "] Set turnserver tcpurl. ").concat(t.turnServer.url, ":").concat(t.turnServer.tcpport))), o.default.info("[".concat(t.clientId, "] Set turnserver udpurl. ").concat(t.turnServer.url, ":").concat(t.turnServer.udpport, ",username: ").concat(t.turnServer.uername, ",password: ").concat(t.turnServer.credential)), i();
      }, t.setProxyServer = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setProxyServer",
          options: arguments,
          tag: "tracer"
        });
        if (t.gatewayClient && t.gatewayClient.state !== De.DISCONNECTED) throw new Error("Set proxy server before join channel");
        if (!n) throw new Error("Do not set the proxyServer parameter as empty");
        if (t.useProxyServer) throw new Error("You have already set the proxy");
        Q(n, "proxyServer"), t.proxyServer = n, a.b.setProxyServer(n), o.default.setProxyServer(n), i();
      }, t.startProxyServer = function () {
        var n = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.startProxyServer",
          options: arguments,
          tag: "tracer"
        });
        if (t.gatewayClient && t.gatewayClient.state !== De.DISCONNECTED) throw new Error("Start proxy server before join channel");
        if (t.proxyServer || t.turnServer.url) throw new Error("You have already set the proxy");
        t.useProxyServer = !0, n();
      }, t.stopProxyServer = function () {
        var n = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.stopProxyServer",
          options: arguments,
          tag: "tracer"
        });
        if (t.gatewayClient && t.gatewayClient.state !== De.DISCONNECTED) throw new Error("Stop proxy server after leave channel");
        a.b.setProxyServer(), o.default.setProxyServer(), t.turnServer = {}, t.proxyServer = null, t.useProxyServer = !1, n();
      }, t.setEncryptionSecret = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setEncryptionSecret",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "password"), t.aespassword = n, i();
      }, t.setEncryptionMode = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setEncryptionMode",
          options: arguments,
          tag: "tracer"
        });
        if (Q(n, "encryptionMode"), !le.includes(n)) throw new Error('Invalid encryptionMode: encryptionMode should be "aes-128-xts" | "aes-256-xts" | "aes-128-ecb"');
        t.aesmode = n, i();
      }, t.configPublisher = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.configPublisher",
          options: arguments,
          tag: "tracer"
        });
        q(n, "config");
        var o = n.width,
            r = n.height,
            s = n.framerate,
            d = n.bitrate,
            c = n.publisherUrl;
        X(o, "width"), X(r, "height"), X(s, "framerate"), X(d, "bitrate", 1, 1e7), c && Q(c, "publisherUrl"), t.gatewayClient.configPublisher(n), i();
      }, t.enableDualStream = function (n, i) {
        var r = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Client.enableDualStream",
          options: arguments,
          tag: "tracer"
        });
        return "iOS" === Object(p.getBrowserOS)() ? (a.b.streamSwitch(e.sessionId, {
          lts: new Date().getTime(),
          isdual: !0,
          succ: !1
        }), r(A.IOS_NOT_SUPPORT)) : Object(p.isWeChatBrowser)() ? (a.b.streamSwitch(e.sessionId, {
          lts: new Date().getTime(),
          isdual: !0,
          succ: !1
        }), r(A.WECHAT_NOT_SUPPORT)) : (a.b.streamSwitch(e.sessionId, {
          lts: new Date().getTime(),
          isdual: !0,
          succ: !0
        }), t.isDualStream = !0, void (0 === t.highStreamState ? t._publishLowStream(function (e) {
          return r(null, e);
        }, function (e) {
          o.default.warning("[".concat(t.clientId, "]"), e), r(A.ENABLE_DUALSTREAM_FAILED);
        }) : 1 === t.highStreamState ? r(A.STILL_ON_PUBLISHING) : r(null)));
      }, t.disableDualStream = function (n, i) {
        var r = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Client.disableDualStream",
          options: arguments,
          tag: "tracer"
        });
        a.b.streamSwitch(e.sessionId, {
          lts: new Date().getTime(),
          isdual: !1,
          succ: !0
        }), t.isDualStream = !1, 0 === t.highStreamState ? t._unpublishLowStream(function () {
          t.highStream.lowStream = null, r();
        }, function (e) {
          o.default.warning("[".concat(t.clientId, "]"), e), r(A.DISABLE_DUALSTREAM_FAILED);
        }) : 1 === t.highStreamState ? r(A.STILL_ON_PUBLISHING) : r();
      }, t._createLowStream = function (e, n) {
        if (t.highStream && t.highStream.stream) {
          var a = I()({}, t.highStream.params);

          if (a.streamID += 1, a.audio = !1, a.video) {
            var r = t.highStream.stream.getVideoTracks()[0];
            r ? K.getVideoCameraIdByLabel(r.label, function (r) {
              a.cameraId = r;
              var s = new se(a);

              if (s.streamId = t.highStream.getId() + 1, t.lowStreamParameter) {
                var d = I()({}, t.lowStreamParameter);

                if (!d.width || !d.height) {
                  var c = ke(t.highStream.profile),
                      u = i.SUPPORT_RESOLUTION_LIST[c[0]];
                  d.width = u[0], d.height = u[1];
                }

                if (d.framerate = d.framerate || 5, d.bitrate = d.bitrate || 50, Object(p.isSafari)() || Object(p.isOpera)()) {
                  o.default.debug("[".concat(t.clientId, "] Shimming lowStreamParameter"));
                  u = i.SUPPORT_RESOLUTION_LIST[t.highStream.profile];
                  d.width = u[0], d.height = u[1];
                }

                s.setVideoProfileCustomPlus(d);
              } else s.setVideoProfileCustom(ke(t.highStream.profile));

              s.init(function () {
                t.highStream.lowStream = s, t.highStream.userMuteVideo && s.muteVideo(), e && e(s);
              }, n);
            }, n) : n && n(A.HIGH_STREAM_NOT_VIDEO_TRACE);
          } else n && n(A.HIGH_STREAM_NOT_VIDEO_TRACE);
        } else n && n(A.HIGH_STREAM_NOT_VIDEO_TRACE);
      }, t._getLowStream = function (e, n) {
        t.lowStream ? e(t.lowStream) : t._createLowStream(function (n) {
          t.lowStream = n, e(t.lowStream);
        }, n);
      }, t._publishLowStream = function (e, n) {
        return 2 !== t.lowStreamState ? n && n(A.LOW_STREAM_ALREADY_PUBLISHED) : t.highStream && t.highStream.hasScreen() ? n && n(A.SHARING_SCREEN_NOT_SUPPORT) : void t._getLowStream(function (i) {
          t.lowStreamState = 1, t.gatewayClient.publish(i, {
            streamType: 1
          }, function () {
            t.lowStreamState = 0, e && e();
          }, function (e) {
            o.default.debug("[".concat(t.clientId, "] publish low stream failed")), n && n(e);
          });
        }, n);
      }, t._unpublishLowStream = function (e, n) {
        if (0 !== t.lowStreamState) return n && n(A.LOW_STREAM_NOT_YET_PUBLISHED);
        t.lowStream && (t.gatewayClient.unpublish(t.lowStream, {
          streamType: 1
        }, function () {}, function (e) {
          o.default.debug("[".concat(t.clientId, "] unpublish low stream failed")), n && n(e);
        }), t.lowStream.close(), t.lowStream = null, t.lowStreamState = 2, e && e());
      }, t.join = function (n, i, r, s, d) {
        var c,
            u = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return d && d(e);
            s && s(t);
          },
          name: "Client.join",
          options: arguments,
          tag: "tracer"
        });
        if (n && !ne(n)) return o.default.warning("[".concat(t.clientId, "] Param channelKey should be string")), u(A.INVALID_PARAMETER);
        if (!ae(c = i) || !/^[a-zA-Z0-9!#$%&()+-:;<=.>?@[\]^_{}|~,\s]{1,64}$/.test(c)) return o.default.warning("[".concat(t.clientId, "] The length must be within 64 bytes. The supported characters: a-z,A-Z,0-9,space,!, #, $, %, &, (, ), +, -, :, ;, <, =, ., >, ?, @, [, ], ^, _,  {, }, |, ~, ,")), u(A.INVALID_PARAMETER);
        if ("string" == typeof i && "" === i) return o.default.warning("[".concat(t.clientId, "] Param channel should not be empty")), u(A.INVALID_PARAMETER);
        if (r && !Object(G.c)(r) && !Z(r, 1, 255)) return o.default.warning("[".concat(t.clientId, "] [String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]")), u(A.INVALID_PARAMETER);
        if ("string" == typeof r && 0 == r.length) return o.default.warning("[".concat(t.clientId, "] String uid should not be empty")), u(A.INVALID_PARAMETER);
        if ("string" == typeof r && r.length > 256) return o.default.warning("[".concat(t.clientId, "] Length of string uid should be less than 255")), u(A.INVALID_PARAMETER);
        t.highStream = null, t.lowStream = null, t.lowStreamParameter = null, t.isDualStream = !1, t.highStreamState = 2, t.lowStreamState = 2;
        var l = {
          clientId: t.clientId,
          appId: e.appId,
          sid: e.sessionId,
          cname: i,
          uid: r,
          turnServer: t.turnServer,
          proxyServer: t.proxyServer,
          token: n || e.appId,
          useProxyServer: t.useProxyServer
        };
        if ("string" == typeof r && (l.stringUid = r, l.uid = 0), t.aespassword && "none" !== t.aesmode && I()(l, {
          aespassword: t.aespassword,
          aesmode: t.aesmode
        }), a.b.sessionInit(e.sessionId, {
          lts: new Date().getTime(),
          cname: i,
          appid: e.appId,
          mode: e.mode,
          succ: !0
        }), t.onSuccess = function (e) {
          return u(null, e);
        }, t.onFailure = function (e) {
          return u(e);
        }, t.channel = i, t.gatewayClient.state !== De.DISCONNECTED) return o.default.error("[".concat(t.clientId, "] Client already in connecting/connected state")), u(A.INVALID_OPERATION), void a.b.joinGateway(e.sessionId, {
          lts: Date.now(),
          succ: !1,
          ec: A.INVALID_OPERATION,
          addr: null
        });
        t.gatewayClient.state = De.CONNECTING, be(l, function (a, r) {
          o.default.info("[".concat(t.clientId, "] Joining channel: ").concat(i)), t.gatewayClient.dispatchEvent({
            type: "config-distribute",
            config: r,
            joinInfo: l
          }), t.key = n || e.appId, l.cid = a.cid, l.uid = a.uid, a.uni_lbs_ip && a.uni_lbs_ip[1] && (l.uni_lbs_ip = a.uni_lbs_ip[1]), l.gatewayAddr = a.gateway_addr, t.joinInfo = l, t.gatewayClient.join(l, t.key, function (e) {
            o.default.info("[".concat(t.clientId, "] Join channel ").concat(i, " success, join with uid: ").concat(e, ".")), t.onSuccess = null, u(null, e);
          }, function (e) {
            return u(e);
          });
        });
      }, t.renewChannelKey = function (n, i, r) {
        var s = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return r && r(e);
            i && i(t);
          },
          name: "Client.renewChannelKey",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "key", 1, 2047), void 0 === t.key ? (o.default.error("[".concat(t.clientId, "] renewChannelKey should not be called before user join")), s(A.INVALID_OPERATION)) : (t.key = n, t.gatewayClient.key = n, t.gatewayClient.rejoin(), s());
      }, t.leave = function (n, i) {
        var r = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
            n && n(t);
          },
          name: "Client.leave",
          options: arguments,
          tag: "tracer"
        });
        o.default.info("[".concat(t.clientId, "] Leaving channel")), t._renewSession(), t.gatewayClient.leave(function (e) {
          return r(e);
        }, r);
      }, t._renewSession = function () {
        var n = Object(G.b)();
        if (o.default.debug("renewSession ".concat(e.sessionId, " => ").concat(n)), e.sessionId = n, t.joinInfo && (t.joinInfo.sid = n), t.gatewayClient && (t.gatewayClient.joinInfo && (t.gatewayClient.joinInfo.sid = n), t.gatewayClient.localStreams)) for (var i in t.gatewayClient.localStreams) {
          var a = t.gatewayClient.localStreams[i];
          a && (a.sid = n);
        }
      }, t._publish = function (n, i, a) {
        if (2 !== t.highStreamState) return o.default.warning("[".concat(t.clientId, "] Can't publish stream when stream already publish ").concat(n.getId())), a && a(A.STREAM_ALREADY_PUBLISHED);
        o.default.info("[".concat(t.clientId, "] Publishing stream, uid ").concat(n.getId())), t.highStream = n, t.highStreamState = 1, t.highStream.streamId = t.joinInfo.stringUid || t.joinInfo.uid, t.hasPublished = !1;

        var r = function r(n, i, a) {
          t.gatewayClient.publish(n, {
            streamType: 0
          }, function () {
            n.sid = e.sessionId, t.highStreamState = 0, o.default.info("[".concat(t.clientId, "] Publish success, uid: ").concat(n.getId())), t.isDualStream ? t._publishLowStream(function () {
              i && i();
            }, function (e) {
              o.default.warning("[".concat(t.clientId, "] "), e), i && i();
            }) : i && i();
          }, a);
        };

        "audience" === t.gatewayClient.role && "live" === t.mode ? t.gatewayClient.setClientRole("host", function (e) {
          if (e) return a && a(e);
          r(n, i, a);
        }) : r(n, i, a);
      }, t._unpublish = function (e, n, i) {
        if (0 !== t.highStreamState) return o.default.warning("[".concat(t.clientId, "] Can't unpublish stream when stream not publish")), i && i(A.STREAM_NOT_YET_PUBLISHED);
        o.default.info("[".concat(t.clientId, "] Unpublish stream, uid ").concat(e.getId()));

        var a = function a(e, n, i) {
          t.isDualStream && t.lowStream ? (t._unpublishLowStream(null, i), t.gatewayClient.unpublish(e, {
            streamType: 0
          }, null, i), t.highStreamState = 2, o.default.info("[".concat(t.clientId, "] Unpublish stream success, uid: ").concat(e.getId()))) : (t.gatewayClient.unpublish(e, {
            streamType: 0
          }, null, i), t.highStreamState = 2, o.default.info("[".concat(t.clientId, "] Unpublish stream success, uid: ").concat(e.getId()))), n && n();
        };

        "host" === t.gatewayClient.role && "live" === t.mode ? t.gatewayClient.setClientRole("audience", function (t) {
          if (t) return i && i(t);
          a(e, n, i);
        }) : a(e, n, i);
      }, t.publish = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
          },
          name: "Client.publish",
          tag: "tracer",
          options: {
            stream: "too long to show",
            onFailure: !!i
          }
        });
        2 === t.highStreamState ? t._publish(n, function (e) {
          return o(null, e);
        }, function (e) {
          return o(e);
        }) : o(A.STREAM_ALREADY_PUBLISHED);
      }, t.unpublish = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
          },
          name: "Client.unpublish",
          tag: "tracer",
          options: {
            stream: "too long to show",
            onFailure: !!i
          }
        });
        0 === t.highStreamState ? t._unpublish(n, function (e) {
          return o(null, e);
        }, function (e) {
          return o(e);
        }) : o(A.STREAM_NOT_YET_PUBLISHED);
      }, t.subscribe = function (n, i, r) {
        var s = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return r && r(e);
          },
          name: "Client.subscribe",
          tag: "tracer",
          options: {
            stream: "too long to show",
            options: i,
            onFailure: !!r
          }
        });
        "function" == typeof i && (r = i, i = null), q(n, "stream"), re(i) || (q(i, "options"), re(i.video) || $(i.video, "options.video"), re(i.audio) || $(i.audio, "options.audio"));
        var d = {
          video: !0,
          audio: !0
        };

        if (!re(i)) {
          if (Object(p.isSafari)() && (!i.video || !i.audio)) {
            var c = "SAFARI_NOT_SUPPORTED_FOR_TRACK_SUBSCRIPTION";
            return o.default.error("[".concat(t.clientId, "] "), c), void s(c);
          }

          if (!re(i.video) && !te(i.video) || !re(i.audio) && !te(i.audio) || !1 === i.audio && !1 === i.video) {
            c = "INVALID_PARAMETER ".concat(JSON.stringify(i));
            return o.default.error("[".concat(t.clientId, "] "), c), void s(c);
          }
        }

        n.subscribeOptions ? (I()(n.subscribeOptions, d, i), t.gatewayClient.subscribeChange(n, function (e) {
          return s(null, e);
        }, s)) : (n.subscribeOptions = I()({}, d, i), t.gatewayClient.subscribe(n, function (e) {
          return s(null, e);
        }, s));
      }, t.unsubscribe = function (n, i) {
        var r = a.b.reportApiInvoke(e.sessionId, {
          callback: function callback(e, t) {
            if (e) return i && i(e);
          },
          name: "Client.unsubscribe",
          tag: "tracer",
          options: {
            stream: "too long to show",
            onFailure: !!i
          }
        });
        o.default.info("[".concat(t.clientId, "] Unsubscribe stream, uid: ").concat(n.getId())), t.gatewayClient.unsubscribe(n, function (e) {
          return r(null, e);
        }, r);
      }, t.setRemoteVideoStreamType = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setRemoteVideoStreamType",
          tag: "tracer",
          options: {
            stream: "too long to show",
            streamType: i
          }
        });
        Y(i, "streamType", [0, 1]), t.gatewayClient.setRemoteVideoStreamType(n, i), o();
      }, t.setStreamFallbackOption = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setStreamFallbackOption",
          tag: "tracer",
          options: {
            stream: "too long to show",
            fallbackType: i
          }
        });
        Y(i, "fallbackType", [0, 1, 2]), t.gatewayClient.setStreamFallbackOption(n, i), o();
      }, t.startLiveStreaming = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.startLiveStreaming",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "url"), re(i) || $(i, "transcodingEnabled"), t.gatewayClient.startLiveStreaming(n, i), o();
      }, t.stopLiveStreaming = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.stopLiveStreaming",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "url"), t.gatewayClient.stopLiveStreaming(n), i();
      }, t.setLiveTranscoding = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.setLiveTranscoding",
          options: arguments,
          tag: "tracer"
        });
        q(n, "transcoding");
        var o = n.width,
            r = n.height,
            s = n.videoBitrate,
            d = n.videoFramerate,
            c = n.lowLatency,
            u = n.audioSampleRate,
            l = n.audioBitrate,
            p = n.audioChannels,
            f = n.videoGop,
            m = n.videoCodecProfile,
            g = n.userCount,
            v = n.backgroundColor,
            S = n.transcodingUsers;

        if (re(o) || X(o, "width"), re(r) || X(r, "height"), re(s) || X(s, "videoBitrate", 1, 1e6), re(d) || X(d, "videoFramerate"), re(c) || $(c, "lowLatency"), re(u) || Y(u, "audioSampleRate", [32e3, 44100, 48e3]), re(l) || X(l, "audioBitrate", 1, 128), re(p) || Y(p, "audioChannels", [1, 2, 3, 4, 5]), re(f) || X(f, "videoGop"), re(m) || Y(m, "videoCodecProfile", [66, 77, 100]), re(g) || X(g, "userCount", 0, 17), re(v) || X(v, "backgroundColor", 0, 16777215), !re(S)) {
          if (!(S instanceof Array)) throw new Error("[transcodingUsers]: transcodingUsers should be Array");
          if (S.length > 17) throw new Error("The length of transcodingUsers cannot greater than 17");
          S.map(function (e, t) {
            if (!re(e.uid) && !Object(G.c)(e.uid) && !Z(e.uid, 1, 255)) throw new Error("[String uid] Length of the string: [1,255]. ASCII characters only. [Number uid] The value range is [0,10000]");
            if (re(e.x) || X(e.x, "transcodingUser[".concat(t, "].x"), 0, 1e4), re(e.y) || X(e.y, "transcodingUser[".concat(t, "].y"), 0, 1e4), re(e.width) || X(e.width, "transcodingUser[".concat(t, "].width"), 0, 1e4), re(e.height) || X(e.height, "transcodingUser[".concat(t, "].height"), 0, 1e4), re(e.zOrder) || X(e.zOrder, "transcodingUser[".concat(t, "].zOrder"), 0, 100), !(re(e.alpha) || "number" == typeof e.alpha && e.alpha <= 1 && e.alpha >= 0)) throw new Error("transcodingUser[${index}].alpha: The value range is [0, 1]");
          });
        }

        I()(Fe, n), t.gatewayClient.setLiveTranscoding(Fe), i();
      }, t.addInjectStreamUrl = function (n, i) {
        var o = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.addInjectStreamUrl",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "url", 1, 255), q(i, "config"), !re(i && i.width) && X(i.width, "config.width", 0, 1e4), !re(i && i.height) && X(i.height, "config.height", 0, 1e4), !re(i && i.videoGop) && X(i.videoGop, "config.videoGop", 1, 1e4), !re(i && i.videoFramerate) && X(i.videoFramerate, "config.videoFramerate", 1, 1e4), !re(i && i.videoBitrate) && X(i.videoBitrate, "config.videoBitrate", 1, 1e4), !re(i && i.audioSampleRate) && Y(i.audioSampleRate, "config.audioSampleRate", [32e3, 44100, 48e3]), !re(i && i.audioBitrate) && X(i.audioBitrate, "config.audioBitrate", 1, 1e4), !re(i && i.audioChannels) && X(i.audioChannels, "config.audioChannels", 1, 2), I()(Be, i), t.gatewayClient.addInjectStreamUrl(n, Be), o();
      }, t.removeInjectStreamUrl = function (n) {
        var i = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.removeInjectStreamUrl",
          options: arguments,
          tag: "tracer"
        });
        Q(n, "url", 1, 255), t.gatewayClient.removeInjectStreamUrl(n), i();
      }, t.enableAudioVolumeIndicator = function (n, i) {
        var r = a.b.reportApiInvoke(e.sessionId, {
          name: "Client.enableAudioVolumeIndicator",
          options: arguments,
          tag: "tracer"
        });
        n = n || 2e3, X(i = i || 3, "smooth", 1, 100), X(n, "interval", 50, 1e5), t.audioVolumeIndication = t.audioVolumeIndication || {
          enabled: !0
        }, t.audioVolumeIndication.interval = n, t.audioVolumeIndication.smooth = i, t.audioVolumeIndication = {
          interval: n,
          smooth: i
        }, o.default.info("[".concat(t.clientId, "] enableAudioVolumeIndicator interval ").concat(n, " smooth ").concat(i)), t.gatewayClient.enableAudioVolumeIndicator(n, i), r();
      }, t.getNetworkStats = function (e, n) {
        return o.default.deprecate("[".concat(t.clientId, "] client.getNetworkStats is deprecated. Use client.getTransportStats instead.")), xe.getStats(e, n);
      }, t.getSystemStats = function (e, t) {
        return m.getStats(e, t);
      }, t.getRecordingDevices = function (e, t) {
        return K.getRecordingDevices(e, t);
      }, t.getPlayoutDevices = function (e, t) {
        return K.getPlayoutDevices(e, t);
      }, t.getCameras = function (e, t) {
        return K.getCameras(e, t);
      }, t.getRemoteAudioStats = function (e, n) {
        return t.rtcStatsCollector.getRemoteAudioStats(e, n);
      }, t.getLocalAudioStats = function (e, n) {
        return t.rtcStatsCollector.getLocalAudioStats(e, n);
      }, t.getRemoteVideoStats = function (e, n) {
        return t.rtcStatsCollector.getRemoteVideoStats(e, n);
      }, t.getLocalVideoStats = function (e, n) {
        return t.rtcStatsCollector.getLocalVideoStats(e, n);
      }, t._getRemoteVideoQualityStats = function (e, n) {
        return t.rtcStatsCollector.getRemoteVideoQualityStats(e, n);
      }, t._getRemoteAudioQualityStats = function (e, n) {
        return t.rtcStatsCollector.getRemoteAudioQualityStats(e, n);
      }, t.getTransportStats = function (e, n) {
        return t.rtcStatsCollector.getTransportStats(function (t) {
          return xe.getStats(function (n) {
            var i = I()({}, t, n);
            e && e(i);
          }, n);
        }, n);
      }, t.getSessionStats = function (e, n) {
        return t.rtcStatsCollector.getSessionStats(e, n);
      }, t.onNetworkQuality = function () {
        return t.rtcStatsCollector.onNetworkQuality(onSuccess, onFailure);
      }, e.clientId = t.clientId, t.gatewayClient = De(e), t.on = t.gatewayClient.on, t.rtcStatsCollector = function (e) {
        var t = r();
        return t.gatewayClient = e, t.exceptionMonitor = new Le(e), t.localStats = {}, t.remoteStats = {}, t.session = {
          sendBytes: 0,
          recvBytes: 0,
          WSSendBytes: 0,
          WSSendBytesDelta: 0,
          WSRecvBytes: 0,
          WSRecvBytesDelta: 0,
          HTTPSendBytes: 0,
          HTTPSendBytesDelta: 0,
          HTTPRecvBytes: 0,
          HTTPRecvBytesDelta: 0
        }, t.getRemoteAudioStats = function (e) {
          var n = {};

          for (var i in t.remoteStats) {
            var o = {},
                a = t.remoteStats[i];
            J(o, "End2EndDelay", a.peer_delay && a.peer_delay.audio_delay), J(o, "TransportDelay", a.peer_delay && a.peer_delay.e2e_delay), J(o, "PacketLossRate", a.peer_delay && a.peer_delay.e2e_audio_lost_ratio_400ms), J(o, "RecvLevel", a.audioStats && a.audioStats.audioOutputLevel), J(o, "RecvBitrate", a.audioRecvBitrate), J(o, "CodecType", a.audioStats && a.audioStats.googCodecName), J(o, "MuteState", a.audioDisabled), J(o, "TotalFreezeTime", a.audioStats && a.audioStats.audioTotalFreezeTime), J(o, "TotalPlayDuration", a.audioStats && a.audioStats.audioTotalPlayDuration), n[i] = o;
          }

          e && e(n);
        }, t.getLocalAudioStats = function (e) {
          var n = {};

          for (var i in t.localStats) {
            var o = {},
                a = t.localStats[i];
            J(o, "RecordingLevel", a.audioStats && a.audioStats.audioInputLevel), J(o, "SendLevel", a.audioStats && a.audioStats.totalAudioEnergy), J(o, "SamplingRate", a.audioStats && a.audioStats.totalSamplesDuration), J(o, "SendBitrate", a.audioSendBitrate), J(o, "CodecType", a.audioStats && a.audioStats.googCodecName), J(o, "MuteState", a.audioDisabled);
            var r = t.gatewayClient.localStreams[i];
            r && r.isPlaying() && J(o, "MuteState", r.userMuteAudio ? "1" : "0"), n[i] = o;
          }

          e && e(n);
        }, t.getRemoteVideoStats = function (e) {
          var n = {};

          for (var i in t.remoteStats) {
            var o = {},
                a = t.remoteStats[i];
            J(o, "End2EndDelay", a.peer_delay && a.peer_delay.video_delay), J(o, "TransportDelay", a.peer_delay && a.peer_delay.e2e_delay), J(o, "PacketLossRate", a.peer_delay && a.peer_delay.e2e_video_lost_ratio_400ms), J(o, "RecvBitrate", a.videoRecvBitrate), J(o, "RecvResolutionWidth", a.videoStats && a.videoStats.googFrameWidthReceived), J(o, "RecvResolutionHeight", a.videoStats && a.videoStats.googFrameHeightReceived), J(o, "RenderResolutionWidth", a.videoStats && a.videoStats.renderRemoteWidth), J(o, "RenderResolutionHeight", a.videoStats && a.videoStats.renderRemoteHeight), J(o, "RenderFrameRate", a.videoStats && a.videoStats.googFrameRateOutput), J(o, "MuteState", a.videoDisabled), J(o, "TotalFreezeTime", a.videoStats && a.videoStats.videoTotalFreezeTime), J(o, "TotalPlayDuration", a.videoStats && a.videoStats.videoTotalPlayDuration), n[i] = o;
          }

          e && e(n);
        }, t.getLocalVideoStats = function (e) {
          var n = {};

          for (var i in t.localStats) {
            var o = {},
                a = t.localStats[i];
            J(o, "TargetSendBitrate", a.videoTargetSendBitrate), J(o, "SendFrameRate", a.videoStats && a.videoStats.googFrameRateSent), J(o, "SendBitrate", a.videoSendBitrate), J(o, "SendResolutionWidth", a.videoStats && a.videoStats.googFrameWidthSent), J(o, "SendResolutionHeight", a.videoStats && a.videoStats.googFrameHeightSent), J(o, "CaptureResolutionWidth", a.videoStats && a.videoStats.renderLocalWidth), J(o, "CaptureResolutionHeight", a.videoStats && a.videoStats.renderLocalHeight), J(o, "EncodeDelay", a.videoStats && a.videoStats.googAvgEncodeMs), J(o, "MuteState", a.videoDisabled), J(o, "TotalFreezeTime", a.videoStats && a.videoStats.videoTotalFreezeTime), J(o, "TotalDuration", a.videoStats && a.videoStats.videoTotalPlayDuration), J(o, "CaptureFrameRate", a.videoStats && a.videoStats.googFrameRateSent), n[i] = o, e && e(n);
          }
        }, t.getRemoteVideoQualityStats = function (e) {
          var n = {};

          for (var i in t.remoteStats) {
            var o = {},
                a = t.remoteStats[i];
            J(o, "videoReceiveDelay", a.videoStats && a.videoStats.googCurrentDelayMs), J(o, "VideoFreezeRate", a.videoStats && a.videoStats.videoFreezeRate), J(o, "FirstFrameTime", a.firstFrameTime), n[i] = o;
          }

          e && e(n);
        }, t.getRemoteAudioQualityStats = function (e) {
          var n = {};

          for (var i in t.remoteStats) {
            var o = {},
                a = t.remoteStats[i];
            J(o, "audioReceiveDelay", a.audioStats && a.audioStats.googCurrentDelayMs), J(o, "AudioFreezeRate", a.videoStats && a.videoStats.videoFreezeRate), n[i] = o;
          }

          e && e(n);
        }, t.getTransportStats = function (e) {
          var n = {},
              i = {},
              o = t.gatewayClient.traffic_stats,
              a = o.peer_delay;

          if (J(n, "OutgoingAvailableBandwidth", t.gatewayClient.OutgoingAvailableBandwidth / 1e3), J(n, "RTT", o && o.access_delay), a) {
            var r = !0,
                s = !1,
                d = void 0;

            try {
              for (var c, u = a[Symbol.iterator](); !(r = (c = u.next()).done); r = !0) {
                var l = c.value;
                l.downlink_estimate_bandwidth && (i[l.peer_uid] = l.downlink_estimate_bandwidth / 1e3 + "");
              }
            } catch (e) {
              s = !0, d = e;
            } finally {
              try {
                r || null == u.return || u.return();
              } finally {
                if (s) throw d;
              }
            }
          }

          n.IncomingAvailableBandwidth = i, e && e(n);
        }, t.getSessionStats = function (e) {
          var n = {},
              i = t.gatewayClient.traffic_stats,
              o = t.gatewayClient.socket,
              a = 0,
              r = 0;

          for (var s in t.remoteStats) {
            (d = t.remoteStats[s]) && d.videoStats && d.videoStats.videoRecvBytesDelta && (r += parseInt(d.videoStats.videoRecvBytesDelta)), d && d.audioStats && d.audioStats.audioRecvBytesDelta && (r += parseInt(d.audioStats.audioRecvBytesDelta));
          }

          for (var s in t.localStats) {
            var d;
            (d = t.localStats[s]) && d.videoStats && d.videoStats.videoSendBytesDelta && (a += parseInt(d.videoStats.videoSendBytesDelta)), d && d.audioStats && d.audioStats.audioSendBytesDelta && (a += parseInt(d.audioStats.audioSendBytesDelta));
          }

          var c = a + t.session.WSSendBytesDelta + t.session.HTTPSendBytesDelta,
              u = r + t.session.WSRecvBytesDelta + t.session.HTTPRecvBytesDelta,
              l = t.session.sendBytes + Object(fe.b)(),
              p = t.session.recvBytes + Object(fe.a)();
          t.gatewayClient.socket && t.gatewayClient.socket.state === t.gatewayClient.CONNECTED && (l += o.getSendBytes(), p += o.getRecvBytes());
          var f = 1;
          i.peer_delay && (f = i.peer_delay.length, f += 1), J(n, "Duration", o.getDuration()), J(n, "UserCount", f), J(n, "SendBytes", l), J(n, "RecvBytes", p), J(n, "SendBitrate", 8 * c / 1e3), J(n, "RecvBitrate", 8 * u / 1e3), e && e(n);
        }, t.isLocalVideoFreeze = function (e, t) {
          var n = 0,
              i = 0;
          if (!e || !t) return !1;
          if (Object(p.isChrome)() || Object(p.isOpera)()) n = e.googFrameRateInput, i = e.googFrameRateSent;else if (Object(p.isSafari)()) n = parseInt(e.framerateMean), i = parseInt(e.framesEncoded) - parseInt(t.framesEncoded);else {
            if (!Object(p.isFireFox)()) return !1;
            n = parseInt(e.framerateMean), i = parseInt(e.framesEncoded) - parseInt(t.framesEncoded);
          }
          return n > 5 && i < 3;
        }, t.isRemoteVideoFreeze = function (e, t) {
          var n = 0,
              i = 0;
          if (!e || !t) return !1;
          if (Object(p.isChrome)() || Object(p.isOpera)()) n = e.googFrameRateReceived, i = e.googFrameRateDecoded;else if (Object(p.isSafari)()) n = e.framerateMean, i = parseInt(e.framesDecoded) - parseInt(t.framesDecoded);else {
            if (!Object(p.isFireFox)()) return !1;
            n = parseInt(e.framesReceived) - parseInt(t.framesReceived), i = parseInt(e.framesDecoded) - parseInt(t.framesDecoded);
          }
          return n > 5 && n < 10 && i < 3 || n > 10 && n < 20 && i < 4 || n > 20 && i < 5;
        }, t.isAudioFreeze = function (e) {
          if (Object(p.isChrome)() && e) {
            if (e.googDecodingPLC && e.googDecodingPLCCNG && e.googDecodingCTN) return (parseInt(e.googDecodingPLC) + parseInt(e.googDecodingPLCCNG)) / parseInt(e.googDecodingCTN) > .2;
          } else if ((Object(p.isSafari)() || Object(p.isFireFox)()) && e.packetsLost && e.packetsReceived) return parseInt(e.packetsLost) / (parseInt(e.packetsLost) + parseInt(e.packetsReceived)) > .2;

          return !1;
        }, t.isAudioDecodeFailed = function (e) {
          return !!((Object(p.isChrome)() || Object(p.isOpera)()) && e && parseInt(e.bytesReceived) > 0 && 0 === parseInt(e.googDecodingNormal));
        }, t.networkQualityTimer = setInterval(function () {
          var e = t.gatewayClient.traffic_stats;
          t.gatewayClient.dispatchEvent({
            type: "network-quality",
            uplinkNetworkQuality: t.networkQualityTrans(e.uplink_network_quality),
            downlinkNetworkQuality: t.networkQualityTrans(e.downlink_network_quality)
          });
        }, 2e3), t.networkQualityTrans = function (e) {
          return e >= 0 && e < .17 ? 1 : e >= .17 && e < .36 ? 2 : e >= .36 && e < .59 ? 3 : e >= .59 && e <= 1 ? 4 : e > 1 ? 5 : 0;
        }, t.getStatsTimer = setInterval(function () {
          var e = t.gatewayClient.traffic_stats,
              n = Date.now();
          t.gatewayClient.dispatchEvent({
            type: "_testException"
          }), Object.keys(t.localStats).length && t.exceptionMonitor.setLocalStats(t.localStats), Object.keys(t.remoteStats).length && t.exceptionMonitor.setRemoteStats(t.remoteStats);
          var i = {};
          Object.keys(t.gatewayClient.remoteStreams).forEach(function (o) {
            var a = t.gatewayClient.remoteStreams[o],
                r = t.remoteStats[o],
                s = {
              id: o,
              updatedAt: n
            };
            i[o] = s, s.firstFrameTime = a.firstFrameTime, r ? (s.audioTotalPlayDuration = r.audioTotalPlayDuration + 1, s.audioTotalFreezeTime = r.audioTotalFreezeTime, s.isAudioFreeze = !1, s.isAudioDecodeFailed = !1, s.videoTotalPlayDuration = r.videoTotalPlayDuration + 1, s.videoTotalFreezeTime = r.videoTotalFreezeTime, s.isVideoFreeze = !1) : (s.audioTotalPlayDuration = 1, s.audioTotalFreezeTime = 0, s.videoTotalPlayDuration = 1, s.videoTotalFreezeTime = 0);
            var d = e && e.peer_delay && e.peer_delay.find(function (e) {
              return e.peer_uid == o;
            });
            d && (s.peer_delay = d), a && (a.isPlaying() && (s.audioDisabled = a.userMuteAudio ? "1" : "0", s.videoDisabled = a.userMuteVideo ? "1" : "0"), r && r.peer_delay && d && r.peer_delay.stream_type !== d.stream_type && t.gatewayClient.dispatchEvent({
              type: "streamTypeChange",
              uid: o,
              streamType: d.stream_type
            }), a.pc && "established" == a.pc.state && a.pc.getStats(function (e) {
              if (s.pcStats = e, s.audioStats = e.find(function (e) {
                return "audio" == e.mediaType && (e.id.indexOf("_recv") > -1 || e.id.toLowerCase().indexOf("inbound") > -1);
              }), s.videoStats = e.find(function (e) {
                return "video" == e.mediaType && (e.id.indexOf("_recv") > -1 || e.id.toLowerCase().indexOf("inbound") > -1);
              }), r && r.audioStats && s.audioStats) {
                var n = parseInt(s.audioStats.bytesReceived) - parseInt(r.audioStats.bytesReceived),
                    i = parseInt(s.audioStats.googDecodingNormal) - parseInt(r.audioStats.googDecodingNormal);

                if (s.audioStats.audioRecvBytesDelta = n, s.audioStats.audioDecodingNormalDelta = i, t.session.recvBytes += n, isFinite(n) && s.audioStats.timestamp) {
                  var o = s.audioStats.timestamp.getTime() - r.audioStats.timestamp.getTime();
                  s.audioRecvBitrate = Math.floor(8 * n / o);
                }

                t.isAudioFreeze(s.audioStats) && s.audioTotalPlayDuration > 10 && (s.audioTotalFreezeTime++, s.isAudioFreeze = !0), t.isAudioDecodeFailed(s.audioStats) && s.audioTotalPlayDuration > 10 && (s.isAudioDecodeFailed = !0), s.audioStats.audioTotalFreezeTime = s.audioTotalFreezeTime, s.audioStats.audioTotalPlayDuration = s.audioTotalPlayDuration, s.audioStats.audioFreezeRate = Math.ceil(100 * s.audioTotalFreezeTime / s.audioTotalPlayDuration);
              }

              if (r && r.videoStats && s.videoStats) {
                var d = parseInt(s.videoStats.bytesReceived) - parseInt(r.videoStats.bytesReceived);
                s.videoStats.videoRecvBytesDelta = d, t.session.recvBytes += d, isFinite(d) && s.videoStats.timestamp && (o = s.videoStats.timestamp.getTime() - r.videoStats.timestamp.getTime(), s.videoRecvBitrate = Math.floor(8 * d / o)), t.isRemoteVideoFreeze(s.videoStats, r.videoStats) && (s.videoTotalFreezeTime++, s.isVideoFreeze = !0), s.videoStats.videoTotalFreezeTime = s.videoTotalFreezeTime, s.videoStats.videoTotalPlayDuration = s.videoTotalPlayDuration, s.videoStats.videoFreezeRate = Math.ceil(100 * s.videoTotalFreezeTime / s.videoTotalPlayDuration), s.videoStats.renderRemoteWidth = a.videoWidth || s.videoStats.googFrameWidthReceived, s.videoStats.renderRemoteHeight = a.videoHeight || s.videoStats.googFrameHeightReceived;
              }
            }));
          }), t.remoteStats = i;
          var o = {};

          if (Object.keys(t.gatewayClient.localStreams).forEach(function (e) {
            var i = t.gatewayClient.localStreams[e],
                a = t.localStats[e],
                r = {
              id: e,
              updatedAt: n
            };
            o[e] = r, a ? (r.videoTotalPlayDuration = a.videoTotalPlayDuration + 1, r.videoTotalFreezeTime = a.videoTotalFreezeTime, r.isVideoFreeze = !1) : (r.videoTotalPlayDuration = 1, r.videoTotalFreezeTime = 0), i && (i.isPlaying() && (r.audioDisabled = i.userMuteAudio ? "1" : "0", r.videoDisabled = i.userMuteVideo ? "1" : "0"), i.video && i.attributes.maxVideoBW ? r.videoTargetSendBitrate = i.attributes.maxVideoBW : i.video && i.screenAttributes && (r.videoTargetSendBitrate = i.screenAttributes.maxVideoBW), i.pc && "established" == i.pc.state && i.pc.getStats(function (e) {
              if (r.pcStats = e.reverse(), r.audioStats = e.find(function (e) {
                return "audio" == e.mediaType && (e.id.indexOf("_send") > -1 || e.id.toLowerCase().indexOf("outbound") > -1);
              }), r.videoStats = e.find(function (e) {
                return "video" == e.mediaType && (e.id.indexOf("_send") > -1 || e.id.toLowerCase().indexOf("outbound") > -1);
              }), r.audioStats && a && a.audioStats) {
                var n = parseInt(r.audioStats.bytesSent) - parseInt(a.audioStats.bytesSent);

                if (r.audioStats.audioSendBytesDelta = n, t.session.sendBytes += n, isFinite(n) && r.audioStats.timestamp) {
                  var o = r.audioStats.timestamp.getTime() - a.audioStats.timestamp.getTime();
                  r.audioSendBitrate = Math.floor(8 * n / o);
                }
              }

              if (r.videoStats && a && a.videoStats) {
                var s = parseInt(r.videoStats.bytesSent) - parseInt(a.videoStats.bytesSent);
                r.videoStats.videoSendBytesDelta = s, t.session.sendBytes += s, isFinite(s) && r.videoStats.timestamp && (o = r.videoStats.timestamp.getTime() - a.videoStats.timestamp.getTime(), r.videoSendBitrate = Math.floor(8 * s / o)), t.isLocalVideoFreeze(r.videoStats, a.videoStats) && (r.videoTotalFreezeTime++, r.isVideoFreeze = !0), r.videoStats.videoTotalFreezeTime = r.videoTotalFreezeTime, r.videoStats.videoTotalPlayDuration = r.videoTotalPlayDuration, r.videoStats.videoFreezeRate = Math.ceil(100 * r.videoTotalFreezeTime / r.videoTotalPlayDuration), r.videoStats.renderLocalWidth = i.videoWidth || r.videoStats.googFrameWidthSent, r.videoStats.renderLocalHeight = i.videoHeight || r.videoStats.googFrameHeightSent;
              }
            }));
          }), t.localStats = o, t.session.HTTPSendBytesDelta = Object(fe.b)() - t.session.HTTPSendBytes, t.session.HTTPSendBytes = Object(fe.b)(), t.session.HTTPRecvBytesDelta = Object(fe.a)() - t.session.HTTPRecvBytes, t.session.HTTPRecvBytes = Object(fe.a)(), t.gatewayClient.socket && t.gatewayClient.socket.state === t.gatewayClient.CONNECTED) {
            var a = t.gatewayClient.socket;
            t.session.WSSendBytesDelta = a.getSendBytes() - t.session.WSSendBytes, t.session.WSSendBytes = a.getSendBytes(), t.session.WSRecvBytesDelta = a.getRecvBytes() - t.session.WSRecvBytes, t.session.WSRecvBytes = a.getRecvBytes();
          }
        }, 1e3), t.gatewayClient.on("join", function () {
          t.session = {
            sendBytes: 0,
            recvBytes: 0,
            WSSendBytes: 0,
            WSSendBytesDelta: 0,
            WSRecvBytes: 0,
            WSRecvBytesDelta: 0,
            HTTPSendBytes: 0,
            HTTPSendBytesDelta: 0,
            HTTPRecvBytes: 0,
            HTTPRecvBytesDelta: 0
          };
        }), t;
      }(t.gatewayClient), t.configDistributManager = function (e) {
        var t = {};
        return t.client = e, t.client.on("config-distribute", function (n) {
          var o = n.joinInfo,
              r = n.config;

          if (r) {
            re(r.uploadLog) || (Object(i.setParameter)("UPLOAD_LOG", r.uploadLog), a.b.reportApiInvoke(o.sid, {
              name: "_configDistribute",
              options: {
                feature: "uploadLog",
                value: r.uploadLog
              }
            })()), re(r.dualStream) || (e.isDualStream = r.dualStream, a.b.reportApiInvoke(o.sid, {
              name: "_configDistribute",
              options: {
                feature: "dualStream",
                value: r.dualStream
              }
            })()), re(r.streamFallbackOption) || t.client.on("stream-subscribed", function (e) {
              var n = e.stream;
              n ? (t.client.gatewayClient.setStreamFallbackOption(n, r.streamFallbackOption), a.b.reportApiInvoke(o.sid, {
                name: "_configDistribute",
                options: {
                  feature: "streamFallbackOption",
                  value: r.streamFallbackOption,
                  streamId: n.getId()
                }
              })()) : a.b.reportApiInvoke(o.sid, {
                name: "_configDistribute",
                options: {
                  feature: "streamFallbackOption",
                  value: r.streamFallbackOption,
                  streamId: n.getId(),
                  err: "invalid stream"
                }
              })();
            });

            try {
              Object.keys(r).map(function (e) {
                return Object(i.setParameter)(e, r[e]);
              });
            } catch (e) {}
          }
        }), t;
      }(t), re(e.turnServer) || t.setTurnServer(e.turnServer), re(e.proxyServer) || t.setProxyServer(e.proxyServer), "live" === t.mode && (t.gatewayClient.role = "audience"), "rtc" === t.mode && (t.gatewayClient.role = "host"), t.on("onMultiIP", function (e) {
        t.gatewayClient.closeGateway(), t.gatewayClient.socket = void 0, t.gatewayClient.hasChangeBGPAddress = !0, t.joinInfo.multiIP = e.arg.option, t.gatewayClient.state = De.CONNECTING, be(t.joinInfo, function (e) {
          o.default.info("[".concat(t.clientId, "] Joining channel: ").concat(t.channel)), t.joinInfo.cid = e.cid, t.joinInfo.uid = e.uid, t.joinInfo.uni_lbs_ip = e.uni_lbs_ip, t.joinInfo.gatewayAddr = e.gateway_addr, t.onSuccess ? t.gatewayClient.join(t.joinInfo, t.key, function (e) {
            o.default.info("[".concat(t.clientId, "] Join channel ").concat(t.channel, " success"));
            var n = t.onSuccess;
            t.onSuccess = null, t.onFailure = null, n(e);
          }, t.onFailure) : (t.gatewayClient.joinInfo = I()({}, t.joinInfo), t.gatewayClient.rejoin());
        }, t.onFailure);
      }), t.on("rejoin-start", function () {
        t._renewSession(), a.b.sessionInit(e.sessionId, {
          lts: new Date().getTime(),
          extend: {
            rejoin: !0
          },
          cname: t.channel,
          appid: e.appId,
          mode: e.mode,
          succ: !0
        });
      }), t.on("recover", function () {
        t._renewSession(), a.b.sessionInit(e.sessionId, {
          lts: new Date().getTime(),
          extend: {
            recover: !0
          },
          cname: t.channel,
          appid: e.appId,
          mode: e.mode,
          succ: !0
        });
      }), t.on("rejoin", function () {
        var e = 2 === t.highStreamState ? 2 : 0;
        t.highStream && 0 === e && (o.default.info("[".concat(t.clientId, "] publish after rejoin")), t.highStreamState = 2, t.lowStreamState = 2, t.publish(t.highStream, function (e) {
          e && o.default.info("[".concat(t.clientId, "] "), e);
        }));
      }), t.on("streamPublished", function (e) {
        t.hasPublished || (t.hasPublished = !0, t.gatewayClient.dispatchEvent(d({
          type: "stream-published",
          stream: e.stream
        })));
      }), t.on("pubP2PLost", function (e) {
        o.default.debug("[".concat(t.clientId, "] Start reconnect local peerConnection: ").concat(t.highStream.getId())), t.gatewayClient.dispatchEvent({
          type: "stream-reconnect-start",
          uid: t.highStream.getId()
        }), 1 === t.highStreamState && (t.highStreamState = 0, t.lowStreamState = 0), t._unpublish(t.highStream, function () {
          t._publish(t.highStream, function () {
            o.default.debug("[".concat(t.clientId, "] Reconnect local peerConnection success: ").concat(t.highStream.getId())), t.gatewayClient.dispatchEvent({
              type: "stream-reconnect-end",
              uid: t.highStream.getId(),
              success: !0,
              reason: ""
            });
          }, function (e) {
            o.default.debug("[".concat(t.clientId, "] Reconnect local peerConnection failed: ").concat(e)), t.gatewayClient.dispatchEvent({
              type: "stream-reconnect-end",
              uid: t.highStream.getId(),
              success: !1,
              reason: e
            });
          });
        }, function (e) {
          o.default.debug("[".concat(t.clientId, "] Reconnect local peerConnection failed: ").concat(e)), t.gatewayClient.dispatchEvent({
            type: "stream-reconnect-end",
            uid: t.highStream.getId(),
            success: !1,
            reason: e
          });
        });
      }), t.on("subP2PLost", function (e) {
        o.default.debug("[".concat(t.clientId, "] Start reconnect remote peerConnection: ").concat(e.stream.getId())), t.gatewayClient.dispatchEvent({
          type: "stream-reconnect-start",
          uid: e.stream.getId()
        }), t.gatewayClient.unsubscribe(e.stream, function () {
          t.gatewayClient.subscribe(e.stream, function () {
            o.default.debug("[".concat(t.clientId, "] Reconnect remote peerConnection success: ").concat(e.stream.getId())), t.gatewayClient.dispatchEvent({
              type: "stream-reconnect-end",
              uid: e.stream.getId(),
              success: !1,
              reason: ""
            });
          }, function (n) {
            o.default.debug("[".concat(t.clientId, "] Reconnect remote peerConnection failed: "), n), t.gatewayClient.dispatchEvent({
              type: "stream-reconnect-end",
              uid: e.stream.getId(),
              success: !1,
              reason: n
            });
          });
        }, function (n) {
          o.default.debug("[".concat(t.clientId, "] \" + 'Reconnect remote peerConnection failed: "), n), t.gatewayClient.dispatchEvent({
            type: "stream-reconnect-end",
            uid: e.stream.getId(),
            success: !1,
            reason: n
          });
        });
      }), xe.on("networkTypeChanged", function (e) {
        t.gatewayClient && t.gatewayClient.dispatchEvent(e);
        var n = I()({}, e, {
          type: "network-type-changed"
        });
        t.gatewayClient.dispatchEvent(n);
      }), K.on("recordingDeviceChanged", function (e) {
        t.gatewayClient && t.gatewayClient.dispatchEvent(e);
        var n = I()({}, e, {
          type: "recording-device-changed"
        });
        t.gatewayClient.dispatchEvent(n);
      }), K.on("playoutDeviceChanged", function (e) {
        t.gatewayClient && t.gatewayClient.dispatchEvent(e);
        var n = I()({}, e, {
          type: "playout-device-changed"
        });
        t.gatewayClient.dispatchEvent(n);
      }), K.on("cameraChanged", function (e) {
        t.gatewayClient && t.gatewayClient.dispatchEvent(e);
        var n = I()({}, e, {
          type: "camera-changed"
        });
        t.gatewayClient.dispatchEvent(n);
      }), t.gatewayClient.on("streamTypeChange", function (n) {
        var i = I()({}, n, {
          type: "stream-type-changed"
        });
        t.gatewayClient.dispatchEvent(i), a.b.reportApiInvoke(e.sessionId, {
          name: "streamTypeChange"
        })(null, JSON.stringify(n));
      }), t;
    },
        Fe = {
      width: 640,
      height: 360,
      videoBitrate: 400,
      videoFramerate: 15,
      lowLatency: !1,
      audioSampleRate: 48e3,
      audioBitrate: 48,
      audioChannels: 1,
      videoGop: 30,
      videoCodecProfile: 100,
      userCount: 0,
      userConfigExtraInfo: {},
      backgroundColor: 0,
      transcodingUsers: []
    },
        Be = {
      width: 0,
      height: 0,
      videoGop: 30,
      videoFramerate: 15,
      videoBitrate: 400,
      audioSampleRate: 44100,
      audioBitrate: 48,
      audioChannels: 1
    },
        Ue = K.getDevices,
        je = F;

    t.default = {
      TranscodingUser: {
        uid: 0,
        x: 0,
        y: 0,
        width: 0,
        height: 0,
        zOrder: 0,
        alpha: 1
      },
      LiveTranscoding: Fe,
      createClient: function createClient(e) {
        var t = a.b.reportApiInvoke(null, {
          name: "createClient",
          options: arguments,
          tag: "tracer"
        });
        (e = I()({}, e || {})).codec || (e.codec = function (e) {
          switch (e) {
            case "h264_interop":
              return "h264";

            default:
              return "vp8";
          }
        }(e.mode));

        var n = function (e) {
          return ce.includes(e.mode) ? ue.includes(e.codec) ? "h264_interop" == e.mode && "h264" !== e.codec && A.CLIENT_MODE_CODEC_MISMATCH : A.INVALID_CLIENT_CODEC : A.INVALID_CLIENT_MODE;
        }(e);

        if (n) throw o.default.error("Invalid parameter setting MODE: ".concat(e.mode, " CODEC: ").concat(e.codec, " ERROR ").concat(n)), t(n), new Error(n);
        return o.default.info("Creating client, MODE: ".concat(e.mode, " CODEC: ").concat(e.codec)), function (e) {
          switch (e.mode) {
            case "interop":
            case "h264_interop":
              e.mode = "live";
              break;

            case "web-only":
              e.mode = "rtc";
          }
        }(e), t(null, e), Ve(e);
      },
      createStream: function createStream(e) {
        var t = a.b.reportApiInvoke(null, {
          name: "createStream",
          options: arguments,
          tag: "tracer"
        });
        q(e, "StreamSpec");
        var n = e.streamID,
            i = e.audio,
            r = e.video,
            s = e.screen,
            d = (e.audioSource, e.videoSource, e.cameraId),
            c = e.microphoneId,
            u = e.mirror,
            l = e.extensionId,
            p = e.mediaSource,
            f = e.audioProcessing;
        if (!re(n) && !Object(G.c)(n) && !Z(n, 1, 255)) throw new Error("[String streamID] Length of the string: [1,255]. ASCII characters only. [Number streamID] The value range is [0,10000]");

        if ($(i, "audio"), $(r, "video"), re(s) || $(s, "screen"), re(d) || Q(d, "cameraId", 0, 255, !1), re(c) || Q(c, "microphoneId", 0, 255, !1), re(l) || Q(l, "extensionId"), re(p) || Y(p, "mediaSource", ["screen", "application", "window"]), re(u) || $(u, "mirror"), !re(f)) {
          var m = f.AGC,
              g = f.AEC,
              v = f.ANS;
          re(m) || $(m, "AGC"), re(g) || $(g, "AEC"), re(v) || $(v, "ANS");
        }

        o.default.debug("Create stream");
        var S = se(e);
        return t(), S;
      },
      Logger: o.default,
      getDevices: Ue,
      getScreenSources: je,
      getParameter: i.getParameter,
      setParameter: i.setParameter,
      checkSystemRequirements: function checkSystemRequirements() {
        var e = a.b.reportApiInvoke(null, {
          name: "checkSystemRequirements",
          options: arguments,
          tag: "tracer"
        }),
            t = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection,
            n = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.msGetUserMedia || navigator.mozGetUserMedia || navigator.mediaDevices && navigator.mediaDevices.getUserMedia,
            i = window.WebSocket,
            r = !!t && !!n && !!i,
            s = !1;
        o.default.debug(p.getBrowserInfo(), "isAPISupport:" + r), p.isChrome() && p.getBrowserVersion() >= 58 && "iOS" !== p.getBrowserOS() && (s = !0), p.isFireFox() && p.getBrowserVersion() >= 56 && (s = !0), p.isOpera() && p.getBrowserVersion() >= 45 && (s = !0), p.isSafari() && p.getBrowserVersion() >= 11 && (s = !0), (p.isWeChatBrowser() || p.isQQBrowser()) && "iOS" !== p.getBrowserOS() && (s = !0), p.isSupportedPC() || p.isSupportedMobile() || (s = !1);
        var d = r && s;
        return e(null, d), d;
      },
      getSupportedCodec: de.getSupportedCodec,
      VERSION: i.VERSION,
      BUILD: i.BUILD,
      AUDIO_SAMPLE_RATE_32000: 32e3,
      AUDIO_SAMPLE_RATE_44100: 44100,
      AUDIO_SAMPLE_RATE_48000: 48e3,
      VIDEO_CODEC_PROFILE_BASELINE: 66,
      VIDEO_CODEC_PROFILE_MAIN: 77,
      VIDEO_CODEC_PROFILE_HIGH: 100,
      REMOTE_VIDEO_STREAM_HIGH: 0,
      REMOTE_VIDEO_STREAM_LOW: 1,
      REMOTE_VIDEO_STREAM_MEDIUM: 2
    };
  }]).default;
});
},{}],"src/webZmrtc.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WebZmRtc = void 0;

var _rtcKit = require("./rtcKit");

var _util = require("./util");

require("./libs/erizo.js");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var AgoraRTC = require('./libs/AgoraRTCSDK-2.6.1');

var client = null;
var streams_map = {};

var WebZmRtc =
/*#__PURE__*/
function (_RtcKit) {
  _inherits(WebZmRtc, _RtcKit);

  function WebZmRtc(options) {
    var _this;

    _classCallCheck(this, WebZmRtc);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WebZmRtc).call(this, options));
    _this.rtcName = 'web zmrtc';
    _this.loggerColor = 'darkmagenta';
    _this._subscribeToStreams_ = _this._subscribeToStreams_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(WebZmRtc, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      if (!AgoraRTC.checkSystemRequirements()) {
        this.rtcCb({
          name: 'error',
          data: {
            msg: '初始化失败浏览器不支持WebRTC',
            code: this._code_enum_.MESSAGE_CODE_INIT
          }
        });
        return;
      }

      if (client) {
        this.rtcCb({
          name: 'error',
          data: {
            msg: '请不要重复实例化',
            code: this._code_enum_.MESSAGE_CODE_INIT
          }
        });
        return;
      }

      var localCid = localStorage.getItem('ss.media.video_source_id');
      var localMid = localStorage.getItem('ss.media.audio_source_id');
      AgoraRTC.getDevices(function (devices) {
        if (devices) {
          for (var i = 0; i < devices.length; i++) {
            _this2.logger("deviceId ".concat(devices[i].deviceId));

            if (devices[i].deviceId === localCid) _this2.cameraId = localCid;
            if (devices[i].deviceId === localMid) _this2.microphoneId = localMid;
          }
        }

        _this2.logger('cameraId,microphoneId:', _this2.cameraId, _this2.microphoneId); // {
        //     optional : [{ sourceId: this.microphoneId }]
        // }


        var initConfig = {
          audio: true,
          video: true,
          data: true,
          videoSize: [320, 240, 320, 240],
          videoFrameRate: [10, 20]
        };
        var sOptions = Object.assign({}, initConfig, {
          attributes: {
            uid: "".concat(_this2.uid)
          }
        });
        console.log('sOptions', sOptions);
        var localStream = Erizo.Stream(sOptions);
        streams_map[_this2.uid] = localStream;
        client = Erizo.Room({
          token: _this2.roomId
        });
        client.addEventListener('room-connected', function (roomEvent) {
          _this2.logger('room-connected');

          _this2.rtcCb({
            name: 'room joined',
            data: {
              code: _this2._code_enum_.MESSAGE_CODE_ROOM
            }
          });

          var options = {
            metadata: {
              type: 'publisher'
            },
            attr: {
              hahah: 'true'
            }
          }; // 监课不推流

          !_this2.isWatcher && client.publish(localStream, options);

          _this2._subscribeToStreams_(roomEvent.streams);
        }); // 与服务器断开链接

        client.addEventListener("room-disconnected", function (e) {
          _this2.logger('room-disconnected');

          _this2.rtcCb({
            name: 'leave channel',
            data: {
              code: _this2._code_enum_.MESSAGE_CODE_ROOM
            }
          });
        }); // 流媒体订阅成功

        client.addEventListener('stream-subscribed', function (streamEvent) {
          _this2.logger('stream-subscribed', streamEvent);

          var stream = streamEvent.stream;

          var _ref = stream.getAttributes() || {},
              mobile = _ref.mobile,
              uid = _ref.uid;

          streams_map[uid] = stream;

          _this2.playById(uid);

          _this2.rtcCb({
            name: 'stream-subscribed',
            data: {
              uid: uid,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        }); // 有新流媒体加入

        client.addEventListener('stream-added', function (streamEvent) {
          _this2.logger('stream-added');

          _this2.rtcCb({
            name: 'stream-added',
            data: {
              uid: streamEvent.stream && streamEvent.stream.getID(),
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });

          _this2._subscribeToStreams_([streamEvent.stream]);
        }); // 新流媒体撤出

        client.addEventListener('stream-removed', function (streamEvent) {
          _this2.logger('stream-removed', streamEvent.stream);

          var _ref2 = streamEvent.stream.getAttributes() || {},
              mobile = _ref2.mobile,
              uid = _ref2.uid;

          _this2.rtcCb({
            name: 'stream-removed',
            data: {
              uid: uid,
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        }); // 流媒体传输失败

        client.addEventListener('stream-failed', function () {
          _this2.logger('stream-failed');

          _this2.rtcCb({
            name: 'error',
            data: {
              msg: '流媒体传输失败',
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        }); // 本地流媒体获取成功

        localStream.addEventListener('access-accepted', function (event) {
          _this2.logger('access-accepted', event);

          client.connect();

          _this2.playById(_this2.uid);

          _this2.rtcCb({
            name: 'accessAllowed',
            data: {
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });
        localStream.addEventListener('access-denied', function (event) {
          _this2.logger('access-denied', event);

          client.connect();

          _this2.rtcCb({
            name: 'accessDenied',
            data: {
              code: _this2._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        });

        _this2.joinRoom();
      });
    }
  }, {
    key: "_subscribeToStreams_",
    value: function _subscribeToStreams_(_streams) {
      var _this3 = this;

      var streams = _streams.filter(function (item) {
        return item;
      });

      this.logger('subscribe-streams', streams);

      for (var index in streams) {
        var stream = streams[index];

        if (streams_map[this.uid].getID() !== stream.getID()) {
          client.subscribe(stream, {
            slideShowMode: false,
            metadata: {
              type: 'subscriber'
            }
          });
          stream.addEventListener('bandwidth-alert', function (evt) {
            return _this3.logger(evt);
          });
        } else {// addLocalVolumnLevelListener.bind(thisContext)(localStream);
          // socket.on('muteVoice', (data) => localStream.muteAudio(data.flag, noop));
          // appInfo.closeZmRtc = () => {
          //     room.disconnect();
          //     localStream.stop();
          //     localStream.close();
          //     initZmRtc._init = false;
          // }
        }
      }
    }
  }, {
    key: "joinRoom",
    value: function joinRoom() {
      var userId = this.uid;
      var roomId = this.roomId;
      var isWatcher = this.isWatcher;
      this.logger("\u7528\u6237:".concat(userId, " isWatcher:").concat(!!isWatcher, " \u6B63\u5728\u89C6\u56FE\u52A0\u5165\u623F\u95F4:").concat(roomId, "\u4E2D..."));
      isWatcher ? client.connect() : streams_map[userId].init();
    }
  }, {
    key: "leaveRoom",
    value: function leaveRoom() {
      client && client.disconnect();
    }
  }, {
    key: "playById",
    value: function playById(id) {
      var _this4 = this;

      (0, _util.waitFor)(function () {
        return streams_map[id] && _this4.document.getElementById("".concat(id));
      }).then(function () {
        if (streams_map[id].showing) {
          streams_map[id].stop();
        }

        streams_map[id].show("".concat(id));
      });
    }
  }, {
    key: "disableVideo",
    value: function disableVideo(_ref3) {
      var id = _ref3.id,
          flag = _ref3.flag;
      var stream = streams_map[id];

      if (flag) {
        stream.muteVideo(false);
      } else {
        stream.muteVideo(true);
      }
    }
  }, {
    key: "disableAudio",
    value: function disableAudio(_ref4) {
      var id = _ref4.id,
          flag = _ref4.flag;
      var stream = streams_map[id];

      if (flag) {
        stream.muteAudio();
      } else {
        stream.muteAudio();
      }
    }
  }, {
    key: "hideVideoById",
    value: function hideVideoById(id) {}
  }, {
    key: "showVideoById",
    value: function showVideoById(id) {}
  }]);

  return WebZmRtc;
}(_rtcKit.RtcKit);

exports.WebZmRtc = WebZmRtc;
},{"./rtcKit":"src/rtcKit.js","./util":"src/util.js","./libs/erizo.js":"src/libs/erizo.js","./libs/AgoraRTCSDK-2.6.1":"src/libs/AgoraRTCSDK-2.6.1.js"}],"../../../../usr/lib/node_modules/parcel-bundler/node_modules/os-browserify/browser.js":[function(require,module,exports) {
exports.endianness = function () { return 'LE' };

exports.hostname = function () {
    if (typeof location !== 'undefined') {
        return location.hostname
    }
    else return '';
};

exports.loadavg = function () { return [] };

exports.uptime = function () { return 0 };

exports.freemem = function () {
    return Number.MAX_VALUE;
};

exports.totalmem = function () {
    return Number.MAX_VALUE;
};

exports.cpus = function () { return [] };

exports.type = function () { return 'Browser' };

exports.release = function () {
    if (typeof navigator !== 'undefined') {
        return navigator.appVersion;
    }
    return '';
};

exports.networkInterfaces
= exports.getNetworkInterfaces
= function () { return {} };

exports.arch = function () { return 'javascript' };

exports.platform = function () { return 'browser' };

exports.tmpdir = exports.tmpDir = function () {
    return '/tmp';
};

exports.EOL = '\n';

exports.homedir = function () {
	return '/'
};

},{}],"../../../../usr/lib/node_modules/parcel-bundler/node_modules/process/browser.js":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"node_modules/zmNativeBridge/lib/index.js":[function(require,module,exports) {
var __dirname = "/mnt/d/app/zmrtckit/node_modules/zmNativeBridge/lib";
var process = require("process");
'use strict';

exports.__esModule = true;
exports.getRemote = getRemote;
exports.getWinManager = getWinManager;
exports.addCustomListener = addCustomListener;
exports.windowNativeMethod = windowNativeMethod;
exports.xpNativeMethod = xpNativeMethod;
exports.windowNativeMethodSync = windowNativeMethodSync;
exports.getZmlearnPlugin = getZmlearnPlugin;
exports.hasMethod = hasMethod;
exports.macNativeClassInit = macNativeClassInit;
exports.macNativeMethod = macNativeMethod;
exports.macSendWinHandle = macSendWinHandle;
exports.macInitModule = macInitModule;
exports.getClientVersion = getClientVersion;
exports.getCurrentWin = getCurrentWin;
exports.getCurentWinSize = getCurentWinSize;
exports.focusCurrentWindow = focusCurrentWindow;
exports.getShareDataByName = getShareDataByName;
exports.setShareDataByName = setShareDataByName;
exports.getPlatform = getPlatform;
exports.isMac = isMac;
exports.isWin = isWin;
exports.isWeb = isWeb;
exports.isXp = isXp;
exports.isXpNative = isXpNative;
exports.createClassRoomWin = createClassRoomWin;
exports.closeClassRoomWin = closeClassRoomWin;
exports.generateUUID = generateUUID;
exports.nativeEmit = nativeEmit;
exports.nativeOn = nativeOn;
exports.nativeOff = nativeOff;
exports.formatNativeViewPoi = formatNativeViewPoi;
var acc_id = 0;
var acc_map = {};
var zmlearnPlugin = null;
var custom_name_map = {};
var initNativeListenerInited = false;
//获取electron remote
function getRemote() {
    var _window$require = window.require('electron'),
        remote = _window$require.remote;

    return remote;
}
//获取electron 窗口管理对象
function getWinManager() {
    var windowManager = getRemote().require('electron-window-manager');
    return windowManager;
}
//添加自定义事件
function addCustomListener(name, callback) {
    if (!custom_name_map[name]) {
        custom_name_map[name] = [callback];
        getWinManager().bridge.on(name, function () {
            var _console;

            for (var _len = arguments.length, data = Array(_len), _key = 0; _key < _len; _key++) {
                data[_key] = arguments[_key];
            }

            var len = custom_name_map[name].length;
            (_console = console).log.apply(_console, ['addCustomListener name', name, custom_name_map[name], len].concat(data));
            for (var i = 0; i < len; i++) {
                var _custom_name_map$name;

                (_custom_name_map$name = custom_name_map[name])[i].apply(_custom_name_map$name, data);
            }
        });
    } else {
        custom_name_map[name].push(callback);
    }
}
//windows 原生桥接事件
function windowNativeMethod(funcname, params) {
    try {
        if (isXp()) {
            xpNativeMethod(funcname, params);
        } else {
            getWinManager().bridge.emit('nativemethodexec', { funcname: funcname, params: params });
        }
    } catch (e) {
        return '-1';
    }
}
// xp os 原生桥接事件
function xpNativeMethod(funcname, params) {
    var _zmlearnPlugin;

    if (zmlearnPlugin === null) zmlearnPlugin = window.require('./zmlearn');
    (_zmlearnPlugin = zmlearnPlugin)[funcname].apply(_zmlearnPlugin, params);
}

// windows  原生桥接同步
function windowNativeMethodSync(funcname, params) {
    try {
        var _zmlearnPlugin2;

        if (zmlearnPlugin === null) zmlearnPlugin = getZmlearnPlugin();
        return (_zmlearnPlugin2 = zmlearnPlugin)[funcname].apply(_zmlearnPlugin2, params);
    } catch (e) {
        return "-1";
    }
}

function getZmlearnPlugin() {
    if (getClientVersion() >= '2.4.21') {
        var path = window.require("path");
        return getRemote().require(path.join(getRemote().app.getAppPath(), '../../zmlearn'));
    } else {
        return getRemote().require('./zmlearn');
    }
}

// 是否存在某个方法
function hasMethod(name) {
    try {
        if (isWin()) {
            if (zmlearnPlugin === null) zmlearnPlugin = getZmlearnPlugin();;
            return !!zmlearnPlugin[name];
        } else if (isMac()) {
            var nodobjc = window.require('nodobjc');
            var dirPath = getRemote().app.getAppPath();
            nodobjc.importFramework(dirPath + '/videochatplugin.framework');
            var c = nodobjc.AgoraVideo;
            var methods = c.getInstanceMethods();
            var flag = false;
            for (var i = 0; i < methods.length; i++) {
                var item = methods[i].split(":")[0];
                if (item === name) {
                    flag = true;
                    break;
                }
            }
            return flag;
        } else {
            return false;
        }
    } catch (e) {
        return false;
    }
}

// mac os 原生同步实例化
function macNativeClassInit(className) {
    try {
        if (getShareDataByName(className)) {
            return getShareDataByName(className);
        } else {
            var nodobjc1 = getRemote().require('nodobjc');
            nodobjc1.import(__dirname + '/videochatplugin.framework');
            var b = nodobjc1[className]('alloc')('init');
            setShareDataByName(className, b);
            return b;
        }
    } catch (e) {
        return -1;
    }
}

//mac os 原生桥接事件
function macNativeMethod(params) {
    try {
        getWinManager().bridge.emit('nativemethodexec', { params: params });
    } catch (e) {
        return '-1';
    }
}
// 公用原生事件传输
function nativeMethod(data) {
    try {
        getWinManager().bridge.emit('nativemethodexec', data);
    } catch (e) {
        return '-1';
    }
}
//mac 窗口句柄
function macSendWinHandle(myView) {
    getWinManager().bridge.emit('createwinhandle', { myView: myView, name: 'classroomwin' });
}
//mac 原生插件初始化
function macInitModule(channelType) {
    getWinManager().bridge.emit('InitModule', { channelType: channelType });
}

//获取客户端版本号
function getClientVersion() {
    try {
        if (window.nw && window.nw.App) {
            var vers = 'xp' + window.nw.App.manifest.version;
            return vers;
        } else {
            return getRemote().app.getVersion();
        }
    } catch (e) {
        return '0.0.0';
    }
}

//获取当前窗口
function getCurrentWin() {
    return getRemote().getCurrentWindow();
}

//获取当前窗口大小
function getCurentWinSize() {
    var currentWin = getCurrentWin();
    return [currentWin.getContentBounds().width, currentWin.getContentBounds().height];
}

// 聚焦当前窗口
function focusCurrentWindow() {
    var currentWin = getCurrentWin();
    return currentWin.focus();
}

//获取共享数据
function getShareDataByName(name) {
    return getWinManager().sharedData.fetch(name);
}

//设置共享数据
function setShareDataByName(name, data) {
    getWinManager().sharedData.set(name, data);
}

//获取当前原生平台
function getPlatform() {
    return window.process ? window.process.platform : 'web';
}

//isMac
function isMac() {
    return getPlatform() === 'darwin';
}

//isWin
function isWin() {
    return getPlatform() === 'win32';
}

//isWeb
function isWeb() {
    return getPlatform() === 'web';
}

//isXp
function isXp() {
    return window.nw && window.nw.App;
}

//isXpNative
function isXpNative() {
    return isXp() && window.nw.App.manifest.version > '2.0.2';
}

//新窗口
function createClassRoomWin(options) {
    var newClassRoomWin = getWinManager().get(options.name);
    if (!newClassRoomWin) {
        newClassRoomWin = getWinManager().createNew(options.name, '', options.url, false, { width: options.width, height: options.height, minimizable: options.ismin, maximizable: options.ismax,
            resizable: options.isresize, backgroundColor: '#2e2c29' });
        newClassRoomWin.open();
        newClassRoomWin.focus();
    }
    newClassRoomWin.open();
    newClassRoomWin.focus();
}

//关闭新窗口
function closeClassRoomWin(roomname) {
    if (isWin()) {
        windowNativeMethod('LeaveRoom', ['LeaveRoom']);
    } else if (isMac()) {
        macNativeMethod(['LeaveRoom']);
    }
    window.onbeforeunload = null;
    getWinManager().close(roomname);
}

//获取mac地址
function generateUUID() {
    try {
        generateUUID.tail = generateUUID.tail || function (nics) {
            var nic, index, addr, retn;
            for (nic in nics) {
                for (index in nics[nic]) {
                    addr = nics[nic][index];
                    if (!addr.internal) {
                        if (addr.address.indexOf('fe80::') === 0) {
                            // found scope-local
                            retn = retn || addr.address.slice(6).split(/:/).map(function (v, i, a) {
                                return parseInt(v, 16);
                            });
                        }
                    }
                }
            }
            if (!retn) {
                // no IPv6 so generate random MAC with multicast bit set
                index = Math.pow(2, 16);
                retn = [];
                retn.push(Math.floor(Math.random() * index) | 0x1000); // set multicast bit
                retn.push(Math.floor(Math.random() * index));
                retn.push(Math.floor(Math.random() * index));
                retn.push(Math.floor(Math.random() * index));
            }
            retn[3] = 0x10000 | retn[3];
            retn[2] = 0x10000 | retn[1] & 0xff00 | retn[2] & 0x00ff; // eliminate FFFE from xxxx:xxFF:FExx:xxxx
            retn[1] = 0x10000 | retn[0] ^ 0x0200; // invert bit#41
            retn[0] = 0x18000 | process.pid & 0x3fff;
            retn = retn.map(function (v, i, a) {
                return v.toString(16).slice(1);
            });
            return retn[0] + '-' + retn[1] + retn[2] + retn[3];
        }(require('os').networkInterfaces());

        var head = process.hrtime(),
            now = Math.floor(Date.now() / 1000);
        head[1] = Math.floor(head[1] * 0.268435456); // 2^28 / 10^9
        head[2] = (0x11000 | head[1] & 0x0fff).toString(16).slice(1);
        head[1] = (0x10000 | head[1] >>> 12 & 0xffff).toString(16).slice(1);
        head[0] = (4294967296 + now).toString(16).slice(1);
        return head.concat(generateUUID.tail).join('-');
    } catch (e) {
        return '';
    }
};

//通用原生回调方法
function nativeEmit(method) {
    var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var callback = arguments[2];
    var className = arguments[3];

    if (!method) {
        alert("方法名不能为空");
        return;
    }
    var send_data = { funcName: method, params: params, className: className };
    if (callback) {
        acc_id = acc_id + 1;
        var current_id = acc_id;
        send_data['cbStr'] = current_id;
        initNativeListener();
        acc_map[current_id] = callback;
        nativeMethod(send_data);
    } else {
        nativeMethod(send_data);
    }
}
//通用原生方法调用
function nativeOn(method) {
    var cb = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    acc_id = acc_id + 1;
    var current_id = method + ':' + acc_id;
    initNativeListener();
    acc_map[current_id] = cb;
    //acc_map[data.cbStr]&&acc_map[data.cbStr](data)
}

function nativeOff(method, cb) {
    var keys = Object.keys(acc_map);
    var len = keys.length;
    for (var i = 0; i < len; i++) {
        if (keys[i].indexOf(method + ':') === 0 && (acc_map[keys[i]] === cb || !cb)) {
            delete acc_map[keys[i]];
        }
    }
}

//init nativeLister
function initNativeListener() {
    if (!initNativeListenerInited) {
        initNativeListenerInited = true;
        addCustomListener('nativeCallBack', function (data) {
            if (data.cbStr) {
                if (acc_map[data.cbStr]) {
                    try {
                        acc_map[data.cbStr](data);
                    } catch (e) {
                        console.log('call back error');
                    }
                    delete acc_map[data.cbStr];
                }
            } else {
                var keys = Object.keys(acc_map);
                var len = keys.length;
                for (var i = 0; i < len; i++) {
                    //console.log('keys[i]',keys[i],`${data.MsgType}:`,keys[i].indexOf(`${data.MsgType}:`));
                    if (keys[i].indexOf(data.MsgType + ':') === 0) {
                        acc_map[keys[i]](data);
                    }
                }
            }
        });
    }
}

function formatNativeViewPoi(dataWithPoi) {
    var x = dataWithPoi.x,
        y = dataWithPoi.y,
        w = dataWithPoi.w,
        h = dataWithPoi.h;

    if (isWin()) {
        var bounds = getCurrentWin().getContentBounds();
        var scale = window.devicePixelRatio;
        var x1 = parseInt((x + bounds.x) * scale);
        var y1 = parseInt((y + bounds.y) * scale);
        var w1 = parseInt(w * scale);
        var h1 = parseInt(h * scale);
        return { x: x1, y: y1, w: w1, h: h1 };
    } else if (isMac()) {
        var _bounds = getCurrentWin().getContentBounds();
        var _x3 = parseInt(x);
        var _w = parseInt(w);
        var _h = parseInt(h);
        var _y = parseInt(_bounds.height - _h - y);
        return { x: _x3, y: _y, w: _w, h: _h };
    } else {
        return dataWithPoi;
    }
}
},{"os":"../../../../usr/lib/node_modules/parcel-bundler/node_modules/os-browserify/browser.js","process":"../../../../usr/lib/node_modules/parcel-bundler/node_modules/process/browser.js"}],"src/winAgora.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WinAgora = void 0;

var _rtcKit = require("./rtcKit");

var _zmNativeBridge = require("zmNativeBridge");

var _util = require("./util");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var WinAgora =
/*#__PURE__*/
function (_RtcKit) {
  _inherits(WinAgora, _RtcKit);

  function WinAgora(options) {
    var _this;

    _classCallCheck(this, WinAgora);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WinAgora).call(this, options));
    _this.rtcName = 'window agora';
    _this.loggerColor = 'blue';
    _this.isSupportBeauty = true;
    _this._uids_ = [];
    _this._timeId_ = null;
    _this._focTimeId_ = null;
    _this._hiddenUids_ = [];
    _this._remoteJoin_ = _this._remoteJoin_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._moveFunc_ = _this._moveFunc_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._moveById_ = _this._moveById_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._getSupportBeaty_ = _this._getSupportBeaty_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._onFirstLocalVideoFrame_ = _this._onFirstLocalVideoFrame_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._initModule_ = _this._initModule_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._callBackEvents_ = ['RemoteJoin', 'RemoteLeave', 'onFirstLocalVideoFrame', 'UpdateDevice', 'agora speech analysis', 'deviceChange', 'AudioVolumeChange', 'volumn level', 'WinDoubleClick', 'onFirstLocalAudioFrame', 'CurrentSystemData', 'mute_remote_video', 'rtcStatus', 'ConnectionLost'];
    _this._eventCallBackLogic_ = _this._eventCallBackLogic_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._isFirstLocalFrameInited_ = false; // this._callBackEvents_ = ['RemoteJoin','RemoteLeave','onFirstLocalVideoFrame',
    //     'start push stream','device info','UpdateDevice','writingPad','agora speech analysis',
    //     'RobotPen Pos','deviceChange','AudioVolumeChange','tencent room create','volumn level',
    //     'tencent join room succ','WinDoubleClick','onFirstLocalAudioFrame','CurrentSystemData',
    //     'mute_remote_video','rtcStatus','ConnectionLost','RobotPen Mode'
    // ]

    return _this;
  }

  _createClass(WinAgora, [{
    key: "_eventCallBackLogic_",
    value: function _eventCallBackLogic_(data) {
      var MsgType = data.MsgType;

      switch (MsgType) {
        case 'RemoteJoin':
          this._remoteJoin_(data);

          break;

        case 'onFirstLocalVideoFrame':
          this._isFirstLocalFrameInited_ = true;

          this._onFirstLocalVideoFrame_(data);

          break;

        default:
          break;
      }

      this.rtcCb({
        name: MsgType,
        data: Object.assign({}, data, {
          code: this._code_enum_.MESSAGE_CODE_STREAM
        })
      });
      this.logger('_eventCallBackLogic_', data, performance.now());
    }
  }, {
    key: "_moveFunc_",
    value: function _moveFunc_() {
      var _this2 = this;

      if (this._timeId_) {
        clearTimeout(this._timeId_);
        this._timeId_ = null;
      }

      this._timeId_ = setTimeout(function () {
        _this2._uids_.filter(function (id) {
          return !_this2._hiddenUids_.includes(id);
        }).forEach(function (id) {
          _this2._moveById_(id);
        });
      }, 200);
    }
  }, {
    key: "_remoteJoin_",
    value: function _remoteJoin_(data) {
      var uid = data.uid;

      this._updateUids_(uid);

      (0, _zmNativeBridge.windowNativeMethod)('showRemoteVideoWin', [-1000, -1000, 0, 0, uid]);

      this._moveFunc_();
    }
  }, {
    key: "_updateUids_",
    value: function _updateUids_(id) {
      var kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'add';
      id = "".concat(id);

      if (kind === 'add') {
        if (!this._uids_.includes(id)) {
          this._uids_.push(id);
        }
      } else if (kind === 'miu') {
        var index = this._uids_.indexOf(id);

        this._uids_.splice(index, 1);
      }
    }
  }, {
    key: "_updateHidderUids_",
    value: function _updateHidderUids_(id) {
      var kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'add';
      id = "".concat(id);

      if (kind === 'add') {
        if (!this._hiddenUids_.includes(id)) {
          this._hiddenUids_.push(id);
        }
      } else if (kind === 'miu') {
        if (this._hiddenUids_.includes(id)) {
          var index = this._hiddenUids_.indexOf(id);

          this._hiddenUids_.splice(index, 1);
        }
      }
    }
  }, {
    key: "_onFirstLocalVideoFrame_",
    value: function _onFirstLocalVideoFrame_() {
      this._moveFunc_();
    }
  }, {
    key: "_initModule_",
    value: function _initModule_() {
      var cWin = (0, _zmNativeBridge.getCurrentWin)();
      var myView = cWin.getNativeWindowHandle();
      (0, _zmNativeBridge.windowNativeMethod)('setClassRoomWinHandler', [myView]);
    }
  }, {
    key: "init",
    value: function init() {
      var _this3 = this;

      if (this._client_) return;

      this._updateUids_(this.uid);

      var cWin = (0, _zmNativeBridge.getCurrentWin)();

      this._initModule_();

      cWin.removeListener('move', this._moveFunc_);
      cWin.on('move', this._moveFunc_);
      var len = this._callBackEvents_.length;

      for (var i = 0; i < len; i++) {
        //nativeOff(this._callBackEvents_[i],this._eventCallBackLogic_)
        (0, _zmNativeBridge.nativeOn)(this._callBackEvents_[i], this._eventCallBackLogic_);
      }

      this.logger('this is inited');
      this.rtcCb({
        name: 'inited',
        data: {
          code: this._code_enum_.MESSAGE_CODE_INIT
        }
      });
      this.joinRoom();
      this._client_ = {};
      setTimeout(function () {
        if (!_this3._isFirstLocalFrameInited_ && !_this3.isWatcher) {
          _this3.rtcCb({
            name: 'error',
            data: {
              msg: '本地加载视频第一帧失败',
              name: 'onFirstLocalVideoFrame',
              code: _this3._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        }
      }, 10000);
    }
  }, {
    key: "joinRoom",
    value: function joinRoom() {
      var roleType = (0, _util.getRoleType)(this.role, this.isWatcher);
      var classType = 0; //1对1

      var channelType = (0, _util.getChanelType)(this.channel);
      var roomId = this.roomId;
      var userId = this.uid;
      var lessonId = this.roomId;
      var isFace = this.isFace;
      var duration = this.duration;
      var mobile = this.mobile;
      var bu = '';
      var data = {
        roleType: roleType,
        classType: classType,
        channelType: channelType,
        roomId: roomId,
        userId: userId,
        duration: duration,
        isFace: isFace,
        mobile: mobile,
        lessonId: lessonId,
        bu: bu
      };
      (0, _zmNativeBridge.windowNativeMethod)('EnterRoom', [JSON.stringify(data)]);
      (0, _zmNativeBridge.windowNativeMethod)('moveVideoWin', [0, 0, 0, 0, userId]);
    }
  }, {
    key: "leaveRoom",
    value: function leaveRoom() {
      (0, _zmNativeBridge.windowNativeMethod)('LeaveRoom', ['LeaveRoom']);
    }
  }, {
    key: "playById",
    value: function playById(id) {}
  }, {
    key: "disableVideo",
    value: function disableVideo(_ref) {
      var id = _ref.id,
          flag = _ref.flag;
      (0, _zmNativeBridge.windowNativeMethod)('MuteVideo', [JSON.stringify({
        "mute": flag,
        "uid": id
      })]);
    }
  }, {
    key: "disableAudio",
    value: function disableAudio(_ref2) {
      var id = _ref2.id,
          flag = _ref2.flag;
      (0, _zmNativeBridge.windowNativeMethod)('MuteVoice', [JSON.stringify({
        "mute": flag,
        "uid": id
      })]);
    }
  }, {
    key: "hideVideoById",
    value: function hideVideoById(id) {
      id = "".concat(id);
      (0, _zmNativeBridge.windowNativeMethod)('moveVideoWin', [0, 0, 0, 0, id]);

      this._updateHidderUids_(id, 'add');
    }
  }, {
    key: "showVideoById",
    value: function showVideoById(id) {
      this._moveById_(id);

      this._updateHidderUids_(id, 'miu');
    }
  }, {
    key: "setFaceValue",
    value: function setFaceValue(value) {
      (0, _zmNativeBridge.windowNativeMethod)('FaceValue', [JSON.stringify({
        value: value
      })]);
    }
  }, {
    key: "_moveById_",
    value: function _moveById_(id) {
      id = "".concat(id);
      var win = (0, _zmNativeBridge.getCurrentWin)();

      var _win$getContentBounds = win.getContentBounds(),
          x = _win$getContentBounds.x,
          y = _win$getContentBounds.y;

      var scale = window.devicePixelRatio;
      var dom = this.document.getElementById(id);

      if (dom) {
        var bound = dom.getBoundingClientRect();
        var x1 = parseInt((x + bound.left) * scale);
        var y1 = parseInt((y + bound.top) * scale);
        var w = parseInt(bound.width * scale);
        var h = parseInt(bound.height * scale);
        this.logger("window move ".concat(x1, ",").concat(y1, ", ").concat(w, ", ").concat(h, ", ").concat(id));
        (0, _zmNativeBridge.windowNativeMethod)('moveVideoWin', [x1, y1, w, h, id]);

        if (this._focTimeId_) {
          clearTimeout(this._focTimeId_);
          this._focTimeId_ = null;
        }

        this._focTimeId_ = setTimeout(function () {
          if (!win.isMinimized()) (0, _zmNativeBridge.focusCurrentWindow)();
        }, 500);
      }
    }
  }, {
    key: "_getSupportBeaty_",
    value: function _getSupportBeaty_() {
      try {
        var nativeBeaty = (0, _zmNativeBridge.windowNativeMethodSync)('getFaceInfo', [JSON.stringify({
          courseType: 1
        })]);

        if (nativeBeaty !== '-1') {
          var data = JSON.parse(nativeBeaty).datas;
          return data.includes(this.channel);
        } else {
          return false;
        }
      } catch (e) {
        return false;
      }
    }
  }]);

  return WinAgora;
}(_rtcKit.RtcKit);

exports.WinAgora = WinAgora;
},{"./rtcKit":"src/rtcKit.js","zmNativeBridge":"node_modules/zmNativeBridge/lib/index.js","./util":"src/util.js"}],"src/winZego.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WinZego = void 0;

var _winAgora = require("./winAgora");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var WinZego =
/*#__PURE__*/
function (_WinAgora) {
  _inherits(WinZego, _WinAgora);

  function WinZego(options) {
    var _this;

    _classCallCheck(this, WinZego);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WinZego).call(this, options));
    _this.rtcName = 'window zego';
    _this.loggerColor = 'darkblue';
    _this.isSupportBeauty = _this._getSupportBeaty_();
    return _this;
  }

  _createClass(WinZego, [{
    key: "init",
    value: function init() {
      _get(_getPrototypeOf(WinZego.prototype), "init", this).call(this); // this.rtcCb({
      //     name: 'onFirstLocalVideoFrame',
      //     data: {
      //         code: this._code_enum_.MESSAGE_CODE_STREAM,
      //     }
      // })
      // this._isFirstLocalFrameInited_ = true;

    }
  }]);

  return WinZego;
}(_winAgora.WinAgora);

exports.WinZego = WinZego;
},{"./winAgora":"src/winAgora.js"}],"src/winTencentOne.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WinTencentOne = void 0;

var _winAgora = require("./winAgora");

var _util = require("./util");

var _zmNativeBridge = require("zmNativeBridge");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var WinTencentOne =
/*#__PURE__*/
function (_WinAgora) {
  _inherits(WinTencentOne, _WinAgora);

  function WinTencentOne(options) {
    var _this;

    _classCallCheck(this, WinTencentOne);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WinTencentOne).call(this, options));
    var tencentSign = options.tencentSign;
    _this.rtcName = 'window tencent1';
    _this.loggerColor = 'lightpink';
    _this.isSupportBeauty = false;
    _this.tencentSign = tencentSign;
    _this._onTencentRoomCreate_ = _this._onTencentRoomCreate_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._onTencentJoinRoomSucc_ = _this._onTencentJoinRoomSucc_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.tencentRoomCreate = _this.tencentRoomCreate.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.pushTencentStream = _this.pushTencentStream.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.createRoom = _this.createRoom.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(WinTencentOne, [{
    key: "_onTencentRoomCreate_",
    value: function _onTencentRoomCreate_(data) {
      this.rtcCb({
        name: 'tencent room create',
        data: data
      });
    }
  }, {
    key: "_onTencentJoinRoomSucc_",
    value: function _onTencentJoinRoomSucc_(data) {
      this.rtcCb({
        name: 'tencent join room succ',
        data: {}
      });
    }
  }, {
    key: "createRoom",
    value: function createRoom(roomId) {
      (0, _zmNativeBridge.windowNativeMethod)('OnTencentRoomNum', ["".concat(roomId)]);
    }
  }, {
    key: "tencentRoomCreate",
    value: function tencentRoomCreate(data) {
      (0, _zmNativeBridge.windowNativeMethod)('OnTencentRoomCreate', [data.roomId]);
    }
  }, {
    key: "pushTencentStream",
    value: function pushTencentStream() {
      (0, _zmNativeBridge.windowNativeMethod)('pushTencentStream', []);
    }
  }, {
    key: "init",
    value: function init() {
      _get(_getPrototypeOf(WinTencentOne.prototype), "init", this).call(this);

      (0, _zmNativeBridge.nativeOff)('tencent room create', this._onTencentRoomCreate_);
      (0, _zmNativeBridge.nativeOn)('tencent room create', this._onTencentRoomCreate_);
      (0, _zmNativeBridge.nativeOff)('tencent join room succ', this._onTencentJoinRoomSucc_);
      (0, _zmNativeBridge.nativeOn)('tencent join room succ', this._onTencentJoinRoomSucc_);
      this._isFirstLocalFrameInited_ = true;
    }
  }, {
    key: "joinRoom",
    value: function joinRoom() {
      var roleType = (0, _util.getRoleType)(this.role, this.isWatcher);
      var classType = 0; //1对1

      var channelType = (0, _util.getChanelType)(this.channel);
      var roomId = this.roomId;
      var userId = this.uid;
      var lessonId = this.lessonId;
      var isFace = 0;
      var duration = this.duration;
      var mobile = this.mobile;
      var tencentSign = this.tencentSign;
      var bu = '';
      var data = {
        roleType: roleType,
        classType: classType,
        channelType: channelType,
        roomId: roomId,
        userId: userId,
        duration: duration,
        isFace: isFace,
        mobile: mobile,
        lessonId: lessonId,
        tencentSign: tencentSign,
        bu: bu
      };
      (0, _zmNativeBridge.windowNativeMethod)('EnterRoom', [JSON.stringify(data)]);
      (0, _zmNativeBridge.windowNativeMethod)('moveVideoWin', [0, 0, 0, 0, userId]);
      this.rtcCb({
        name: 'onFirstLocalVideoFrame',
        data: {
          code: this._code_enum_.MESSAGE_CODE_STREAM
        }
      });
    }
  }]);

  return WinTencentOne;
}(_winAgora.WinAgora);

exports.WinTencentOne = WinTencentOne;
},{"./winAgora":"src/winAgora.js","./util":"src/util.js","zmNativeBridge":"node_modules/zmNativeBridge/lib/index.js"}],"src/macAgora.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MacAgora = void 0;

var _winAgora = require("./winAgora");

var _zmNativeBridge = require("zmNativeBridge");

var _constants = require("./constants");

var _util = require("./util");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var MacAgora =
/*#__PURE__*/
function (_WinAgora) {
  _inherits(MacAgora, _WinAgora);

  function MacAgora(options) {
    var _this;

    _classCallCheck(this, MacAgora);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MacAgora).call(this, options));
    _this.rtcName = 'mac agora';
    _this.loggerColor = 'lawngreen';
    _this.isSupportBeauty = false;
    return _this;
  }

  _createClass(MacAgora, [{
    key: "_initModule_",
    value: function _initModule_() {
      var cWin = (0, _zmNativeBridge.getCurrentWin)();
      var myView = cWin.getNativeWindowHandle();
      (0, _zmNativeBridge.macSendWinHandle)(myView);
      (0, _zmNativeBridge.macInitModule)(this.channel);
    }
  }, {
    key: "_remoteJoin_",
    value: function _remoteJoin_(data) {
      var uid = data.data;

      this._updateUids_(uid);

      this._moveFunc_();
    }
  }, {
    key: "init",
    value: function init() {
      _get(_getPrototypeOf(MacAgora.prototype), "init", this).call(this);
    }
  }, {
    key: "_moveById_",
    value: function _moveById_(id) {
      id = "".concat(id);

      var _getCurrentWin$getCon = (0, _zmNativeBridge.getCurrentWin)().getContentBounds(),
          width = _getCurrentWin$getCon.width,
          height = _getCurrentWin$getCon.height;

      var size = [width, height];
      var dom = this.document.getElementById(id);

      if (dom) {
        var bound = dom.getBoundingClientRect();
        var left = bound.left,
            top = bound.top,
            _height = bound.height,
            _width = bound.width;
        var x1 = parseInt(left);
        var y1 = parseInt(size[1] - top - _height);
        var w = parseInt(_width);
        var h = parseInt(_height);
        this.logger("macwin move ".concat(x1, ",").concat(y1, ", ").concat(w, ", ").concat(h, ", ").concat(id));
        (0, _zmNativeBridge.macNativeMethod)(['changeWinViewById', id, 'x', x1, 'y', y1, 'w', w, 'h', h]);
      }
    }
  }, {
    key: "joinRoom",
    value: function joinRoom() {
      var watcherType = (0, _util.getRoleType)(this.role, this.isWatcher);
      (0, _zmNativeBridge.macNativeMethod)(['initModule', 'getNativeWin-classroomwin', 'appid', _constants.APP_ID, 'roomid', this.roomId, 'uid', this.uid, 'watcherflag', watcherType]);
      (0, _zmNativeBridge.macNativeMethod)(['joinRoom', this.roomId, 'uid', this.uid]);
      (0, _zmNativeBridge.macNativeMethod)(['changeWinViewById', this.uid, 'x', 0, 'y', 0, 'w', 0, 'h', 0]);
    }
  }, {
    key: "leaveRoom",
    value: function leaveRoom() {
      (0, _zmNativeBridge.macNativeMethod)(['LeaveRoom']);
    }
  }, {
    key: "playById",
    value: function playById(id) {}
  }, {
    key: "disableVideo",
    value: function disableVideo(_ref) {
      var id = _ref.id,
          flag = _ref.flag;

      if ("".concat(id) === "".concat(this.uid)) {
        (0, _zmNativeBridge.macNativeMethod)(['muteVideo', flag]);
      } else {
        (0, _zmNativeBridge.macNativeMethod)(['muteVideoById', id, 'flag', flag]);
      }
    }
  }, {
    key: "disableAudio",
    value: function disableAudio(_ref2) {
      var id = _ref2.id,
          flag = _ref2.flag;

      if ("".concat(id) === "".concat(this.uid)) {
        (0, _zmNativeBridge.macNativeMethod)(['muteVoice', flag]);
      } else {
        (0, _zmNativeBridge.macNativeMethod)(['muteVoiceById', id, 'flag', flag]);
      }
    }
  }, {
    key: "hideVideoById",
    value: function hideVideoById(id) {
      id = "".concat(id);
      (0, _zmNativeBridge.macNativeMethod)(['changeWinViewById', id, 'x', 0, 'y', 0, 'w', 0, 'h', 0]);

      this._updateHidderUids_(id, 'add');
    }
  }, {
    key: "showVideoById",
    value: function showVideoById(id) {
      _get(_getPrototypeOf(MacAgora.prototype), "showVideoById", this).call(this, id);
    }
  }]);

  return MacAgora;
}(_winAgora.WinAgora);

exports.MacAgora = MacAgora;
},{"./winAgora":"src/winAgora.js","zmNativeBridge":"node_modules/zmNativeBridge/lib/index.js","./constants":"src/constants.js","./util":"src/util.js"}],"src/macTencentOne.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MacTencentOne = void 0;

var _macAgora = require("./macAgora");

var _util = require("./util");

var _constants = require("./constants");

var _zmNativeBridge = require("zmNativeBridge");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var MacTencentOne =
/*#__PURE__*/
function (_MacAgora) {
  _inherits(MacTencentOne, _MacAgora);

  function MacTencentOne(options) {
    var _this;

    _classCallCheck(this, MacTencentOne);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MacTencentOne).call(this, options));
    var tencentSign = options.tencentSign;
    _this.rtcName = 'mac tencent1';
    _this.loggerColor = 'cornflowerblue';
    _this.tencentSign = tencentSign;
    _this._onTencentRoomCreate_ = _this._onTencentRoomCreate_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._onTencentJoinRoomSucc_ = _this._onTencentJoinRoomSucc_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.tencentRoomCreate = _this.tencentRoomCreate.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.pushTencentStream = _this.pushTencentStream.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.createRoom = _this.createRoom.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    return _this;
  }

  _createClass(MacTencentOne, [{
    key: "init",
    value: function init() {
      _get(_getPrototypeOf(MacTencentOne.prototype), "init", this).call(this);

      this._isFirstLocalFrameInited_ = true;
    }
  }, {
    key: "_onTencentRoomCreate_",
    value: function _onTencentRoomCreate_(data) {
      this.rtcCb({
        name: 'tencent room create',
        data: data
      });
    }
  }, {
    key: "_onTencentJoinRoomSucc_",
    value: function _onTencentJoinRoomSucc_(data) {
      this.rtcCb({
        name: 'tencent join room succ',
        data: {}
      });
    }
  }, {
    key: "tencentRoomCreate",
    value: function tencentRoomCreate(data) {
      (0, _zmNativeBridge.macNativeMethod)(['joinRoom', data.roomId, 'rolename', 'LiveMaster']);
    }
  }, {
    key: "createRoom",
    value: function createRoom(roomId) {
      (0, _zmNativeBridge.macNativeMethod)(['createRoom', roomId]);
    }
  }, {
    key: "pushTencentStream",
    value: function pushTencentStream() {
      (0, _zmNativeBridge.macNativeMethod)(['startPushStream']);
    }
  }, {
    key: "_initModule_",
    value: function _initModule_() {
      var watcherType = (0, _util.getRoleType)(this.role, this.isWatcher);
      (0, _zmNativeBridge.macNativeMethod)(['initModule', 'getNativeWin-classroomwin', 'appid', _constants.TENCENT_APP_ID, 'apptype', _constants.TENCENT_APP_TYPE, 'roomid', this.roomId, 'uid', "".concat(this.uid), 'password', '', 'sig', this.tencentSign, 'watcherflag', watcherType]);
      this.rtcCb({
        name: 'onFirstLocalVideoFrame',
        data: {
          code: this._code_enum_.MESSAGE_CODE_STREAM
        }
      });
    }
  }]);

  return MacTencentOne;
}(_macAgora.MacAgora);

exports.MacTencentOne = MacTencentOne;
},{"./macAgora":"src/macAgora.js","./util":"src/util.js","./constants":"src/constants.js","zmNativeBridge":"node_modules/zmNativeBridge/lib/index.js"}],"src/winTencentTwo.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WinTencentTwo = void 0;

var _winAgora = require("./winAgora");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var WinTencentTwo =
/*#__PURE__*/
function (_WinAgora) {
  _inherits(WinTencentTwo, _WinAgora);

  function WinTencentTwo(options) {
    var _this;

    _classCallCheck(this, WinTencentTwo);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WinTencentTwo).call(this, options));
    _this.rtcName = 'window tencent2';
    _this.loggerColor = 'lightsalmon';
    _this.isSupportBeauty = _this._getSupportBeaty_();
    return _this;
  }

  _createClass(WinTencentTwo, [{
    key: "init",
    value: function init() {
      _get(_getPrototypeOf(WinTencentTwo.prototype), "init", this).call(this); // this.rtcCb({
      //     name: 'onFirstLocalVideoFrame',
      //     data: {
      //         code: this._code_enum_.MESSAGE_CODE_STREAM,
      //     }
      // })
      // this._isFirstLocalFrameInited_ = true;

    }
  }]);

  return WinTencentTwo;
}(_winAgora.WinAgora);

exports.WinTencentTwo = WinTencentTwo;
},{"./winAgora":"src/winAgora.js"}],"src/winZmRtc.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.WinZmRtc = void 0;

var _winAgora = require("./winAgora");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var WinZmRtc =
/*#__PURE__*/
function (_WinAgora) {
  _inherits(WinZmRtc, _WinAgora);

  function WinZmRtc(options) {
    var _this;

    _classCallCheck(this, WinZmRtc);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(WinZmRtc).call(this, options));
    _this.rtcName = 'window zmrtc';
    _this.loggerColor = 'lightcoral';
    _this.isSupportBeauty = _this._getSupportBeaty_();
    return _this;
  }

  _createClass(WinZmRtc, [{
    key: "init",
    value: function init() {
      _get(_getPrototypeOf(WinZmRtc.prototype), "init", this).call(this);

      this.rtcCb({
        name: 'onFirstLocalVideoFrame',
        data: {
          code: this._code_enum_.MESSAGE_CODE_STREAM
        }
      });
      this._isFirstLocalFrameInited_ = true;
    }
  }]);

  return WinZmRtc;
}(_winAgora.WinAgora);

exports.WinZmRtc = WinZmRtc;
},{"./winAgora":"src/winAgora.js"}],"src/electronAgora.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ElectronAgora = void 0;

var _rtcKit = require("./rtcKit");

var _util = require("./util");

var _constants = require("./constants");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var ElectronAgora =
/*#__PURE__*/
function (_RtcKit) {
  _inherits(ElectronAgora, _RtcKit);

  function ElectronAgora(options) {
    var _this;

    _classCallCheck(this, ElectronAgora);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ElectronAgora).call(this, options));
    _this.rtcName = 'electron agora';
    _this.loggerColor = 'darkyellow';
    _this.isSupportBeauty = false;
    _this._getSupportBeaty_ = _this._getSupportBeaty_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._initModule_ = _this._initModule_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._isFirstLocalFrameInited_ = false;
    _this.getChanelType = _this.getChanelType.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.avsEngine = null;
    _this.ZmAvsSDK = null;
    _this.APP_ID = _constants.APP_ID;
    _this.appSign = '';
    return _this;
  }

  _createClass(ElectronAgora, [{
    key: "getChanelType",
    value: function getChanelType() {
      switch (this.channel) {
        case _constants.VIDEO_CHANEL_AGORA:
          return this.ZmAvsSDK.ChannelType.CHANNEL_AGORA;

        case _constants.VIDEO_CHANEL_ZEGO:
          return this.ZmAvsSDK.ChannelType.CHANNEL_ZEGO;

        default:
          return this.ZmAvsSDK.ChannelType.CHANNEL_AGORA;
      }
    }
  }, {
    key: "_initModule_",
    value: function _initModule_() {
      var _this2 = this;

      // 通道类型
      var channelType = this.getChanelType(); // 声网

      console.log('channelType', channelType); // 加入房间之前通道初始化

      this.avsEngine.initialize(this.APP_ID, this.appSign, channelType);
      var width = 320;
      var height = 240;
      var fps = 15;
      var bitrate = 0;
      var minBitrate = -1;
      var orientationMode = this.ZmAvsSDK.OrientationMode.ORIENTATION_MODE_FIXED_LANDSCAPE;
      this.avsEngine.setVideoEncoderConfiguration(width, height, fps, bitrate, minBitrate, orientationMode);
      this.avsEngine.on(this.ZmAvsSDK.RtcEvent.RTC_EVENT_FIRST_LOCAL_VIDEO_FRAME, function (width, height, elapsed) {
        console.log(_this2.ZmAvsSDK.RtcEvent.RTC_EVENT_FIRST_LOCAL_VIDEO_FRAME, width, height, elapsed);
        _this2._isFirstLocalFrameInited_ = true;

        _this2.rtcCb({
          name: 'onFirstLocalVideoFrame',
          data: Object.assign({}, {}, {
            code: _this2._code_enum_.MESSAGE_CODE_STREAM
          })
        });
      });
      this.avsEngine.on(this.ZmAvsSDK.RtcEvent.RTC_EVENT_FIRST_REMOTE_VIDEO_DECODEED, function (uid, width, height, elapsed) {
        console.log(_this2.ZmAvsSDK.RtcEvent.RTC_EVENT_FIRST_REMOTE_VIDEO_DECODEED, uid, width, height, elapsed);

        _this2.rtcCb({
          name: 'onFirstLocalVideoFrame',
          data: Object.assign({}, {
            uid: uid
          }, {
            code: _this2._code_enum_.MESSAGE_CODE_STREAM
          })
        });
      });
    }
  }, {
    key: "init",
    value: function init(avsEngine, ZmAvsSDK) {
      var _this3 = this;

      var classType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      this.avsEngine = avsEngine;
      this.ZmAvsSDK = ZmAvsSDK;
      if (this._client_) return;
      this.rtcCb({
        name: 'inited',
        data: {
          code: this._code_enum_.MESSAGE_CODE_INIT
        }
      });

      this._initModule_();

      this.joinRoom(classType);
      this._client_ = {};
      setTimeout(function () {
        if (!_this3._isFirstLocalFrameInited_ && !_this3.isWatcher) {
          _this3.rtcCb({
            name: 'error',
            data: {
              msg: '本地加载视频第一帧失败',
              name: 'onFirstLocalVideoFrame',
              code: _this3._code_enum_.MESSAGE_CODE_STREAM
            }
          });
        }
      }, 10000);
    }
  }, {
    key: "joinRoom",
    value: function joinRoom(classType) {
      var roleType = (0, _util.getRoleType)(this.role, this.isWatcher);
      var roomId = this.roomId;
      var userId = this.uid;
      this.avsEngine.joinChannel(classType, roomId, '', roleType, userId);
    }
  }, {
    key: "leaveRoom",
    value: function leaveRoom() {
      this.avsEngine.leaveChannel();
    }
  }, {
    key: "playById",
    value: function playById(id) {
      var _this4 = this;

      (0, _util.waitFor)(function () {
        return document.getElementById("".concat(id));
      }).then(function () {
        var dom = document.getElementById("".concat(id));
        var key = _this4.uid === id ? 'local' : id;

        _this4.avsEngine.initRender(key, dom);

        _this4.avsEngine.setupViewContentMode(key, 1);

        _this4.logger("playById ".concat(id));
      });
    }
  }, {
    key: "disableVideo",
    value: function disableVideo(_ref) {
      var id = _ref.id,
          flag = _ref.flag;

      if (id === this.uid) {
        this.avsEngine.muteLocalVideo(flag);
      } else {
        this.avsEngine.muteRemoteVideo(id, flag);
      }
    }
  }, {
    key: "disableAudio",
    value: function disableAudio(_ref2) {
      var id = _ref2.id,
          flag = _ref2.flag;

      if (id === this.uid) {
        this.avsEngine.muteLocalAudio(flag);
      } else {
        this.avsEngine.muteRemoteAudio(id, flag);
      }
    }
  }, {
    key: "setFaceValue",
    value: function setFaceValue(value) {//windowNativeMethod('FaceValue', [JSON.stringify({value})])
    }
  }, {
    key: "_getSupportBeaty_",
    value: function _getSupportBeaty_() {
      try {
        return false;
      } catch (e) {
        return false;
      }
    }
  }]);

  return ElectronAgora;
}(_rtcKit.RtcKit);

exports.ElectronAgora = ElectronAgora;
},{"./rtcKit":"src/rtcKit.js","./util":"src/util.js","./constants":"src/constants.js"}],"src/electronZego.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ElectronZego = void 0;

var _rtcKit = require("./rtcKit");

var _util = require("./util");

var _constants = require("./constants");

var _electronAgora = require("./electronAgora");

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

var ElectronZego =
/*#__PURE__*/
function (_ElectronAgora) {
  _inherits(ElectronZego, _ElectronAgora);

  function ElectronZego(options) {
    var _this;

    _classCallCheck(this, ElectronZego);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(ElectronZego).call(this, options));
    _this.rtcName = 'electron zego';
    _this.loggerColor = 'lightpink';
    _this.APP_ID = _constants.APP_ID;
    _this.appSign = '';
    return _this;
  }

  return ElectronZego;
}(_electronAgora.ElectronAgora);

exports.ElectronZego = ElectronZego;
},{"./rtcKit":"src/rtcKit.js","./util":"src/util.js","./constants":"src/constants.js","./electronAgora":"src/electronAgora.js"}],"node_modules/@zm-fe/zm-bridge/bridge.js":[function(require,module,exports) {
var define;
var global = arguments[3];
!function(t,n){"object"==typeof exports&&"undefined"!=typeof module?module.exports=n():"function"==typeof define&&define.amd?define(n):(t=t||self).ZMBridge=n()}(this,(function(){"use strict";var t="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function n(t,n){return t(n={exports:{}},n.exports),n.exports}var e,r,o,i,c=function(t){return t&&t.Math==Math&&t},a=c("object"==typeof globalThis&&globalThis)||c("object"==typeof window&&window)||c("object"==typeof self&&self)||c("object"==typeof t&&t)||Function("return this")(),u=function(t){try{return!!t()}catch(t){return!0}},l=!u((function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})),f={}.propertyIsEnumerable,s=Object.getOwnPropertyDescriptor,d={f:s&&!f.call({1:2},1)?function(t){var n=s(this,t);return!!n&&n.enumerable}:f},p=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}},g={}.toString,v=function(t){return g.call(t).slice(8,-1)},h="".split,y=u((function(){return!Object("z").propertyIsEnumerable(0)}))?function(t){return"String"==v(t)?h.call(t,""):Object(t)}:Object,b=function(t){if(null==t)throw TypeError("Can't call method on "+t);return t},m=function(t){return y(b(t))},w=function(t){return"object"==typeof t?null!==t:"function"==typeof t},S=function(t,n){if(!w(t))return t;var e,r;if(n&&"function"==typeof(e=t.toString)&&!w(r=e.call(t)))return r;if("function"==typeof(e=t.valueOf)&&!w(r=e.call(t)))return r;if(!n&&"function"==typeof(e=t.toString)&&!w(r=e.call(t)))return r;throw TypeError("Can't convert object to primitive value")},x={}.hasOwnProperty,O=function(t,n){return x.call(t,n)},A=a.document,j=w(A)&&w(A.createElement),E=!l&&!u((function(){return 7!=Object.defineProperty((t="div",j?A.createElement(t):{}),"a",{get:function(){return 7}}).a;var t})),I=Object.getOwnPropertyDescriptor,P={f:l?I:function(t,n){if(t=m(t),n=S(n,!0),E)try{return I(t,n)}catch(t){}if(O(t,n))return p(!d.f.call(t,n),t[n])}},T=function(t){if(!w(t))throw TypeError(String(t)+" is not an object");return t},_=Object.defineProperty,C={f:l?_:function(t,n,e){if(T(t),n=S(n,!0),T(e),E)try{return _(t,n,e)}catch(t){}if("get"in e||"set"in e)throw TypeError("Accessors not supported");return"value"in e&&(t[n]=e.value),t}},V=l?function(t,n,e){return C.f(t,n,p(1,e))}:function(t,n,e){return t[n]=e,t},M=function(t,n){try{V(a,t,n)}catch(e){a[t]=n}return n},k=a["__core-js_shared__"]||M("__core-js_shared__",{}),J=n((function(t){(t.exports=function(t,n){return k[t]||(k[t]=void 0!==n?n:{})})("versions",[]).push({version:"3.4.1",mode:"global",copyright:"© 2019 Denis Pushkarev (zloirock.ru)"})})),B=J("native-function-to-string",Function.toString),R=a.WeakMap,W="function"==typeof R&&/native code/.test(B.call(R)),N=0,$=Math.random(),z=function(t){return"Symbol("+String(void 0===t?"":t)+")_"+(++N+$).toString(36)},F=J("keys"),L={},Z=a.WeakMap;if(W){var q=new Z,D=q.get,H=q.has,Q=q.set;e=function(t,n){return Q.call(q,t,n),n},r=function(t){return D.call(q,t)||{}},o=function(t){return H.call(q,t)}}else{var G=F[i="state"]||(F[i]=z(i));L[G]=!0,e=function(t,n){return V(t,G,n),n},r=function(t){return O(t,G)?t[G]:{}},o=function(t){return O(t,G)}}var K={set:e,get:r,has:o,enforce:function(t){return o(t)?r(t):e(t,{})},getterFor:function(t){return function(n){var e;if(!w(n)||(e=r(n)).type!==t)throw TypeError("Incompatible receiver, "+t+" required");return e}}},U=n((function(t){var n=K.get,e=K.enforce,r=String(B).split("toString");J("inspectSource",(function(t){return B.call(t)})),(t.exports=function(t,n,o,i){var c=!!i&&!!i.unsafe,u=!!i&&!!i.enumerable,l=!!i&&!!i.noTargetGet;"function"==typeof o&&("string"!=typeof n||O(o,"name")||V(o,"name",n),e(o).source=r.join("string"==typeof n?n:"")),t!==a?(c?!l&&t[n]&&(u=!0):delete t[n],u?t[n]=o:V(t,n,o)):u?t[n]=o:M(n,o)})(Function.prototype,"toString",(function(){return"function"==typeof this&&n(this).source||B.call(this)}))})),Y=a,X=function(t){return"function"==typeof t?t:void 0},tt=function(t,n){return arguments.length<2?X(Y[t])||X(a[t]):Y[t]&&Y[t][n]||a[t]&&a[t][n]},nt=Math.ceil,et=Math.floor,rt=function(t){return isNaN(t=+t)?0:(t>0?et:nt)(t)},ot=Math.min,it=function(t){return t>0?ot(rt(t),9007199254740991):0},ct=Math.max,at=Math.min,ut=function(t){return function(n,e,r){var o,i=m(n),c=it(i.length),a=function(t,n){var e=rt(t);return e<0?ct(e+n,0):at(e,n)}(r,c);if(t&&e!=e){for(;c>a;)if((o=i[a++])!=o)return!0}else for(;c>a;a++)if((t||a in i)&&i[a]===e)return t||a||0;return!t&&-1}},lt={includes:ut(!0),indexOf:ut(!1)}.indexOf,ft=function(t,n){var e,r=m(t),o=0,i=[];for(e in r)!O(L,e)&&O(r,e)&&i.push(e);for(;n.length>o;)O(r,e=n[o++])&&(~lt(i,e)||i.push(e));return i},st=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"],dt=st.concat("length","prototype"),pt={f:Object.getOwnPropertyNames||function(t){return ft(t,dt)}},gt={f:Object.getOwnPropertySymbols},vt=tt("Reflect","ownKeys")||function(t){var n=pt.f(T(t)),e=gt.f;return e?n.concat(e(t)):n},ht=function(t,n){for(var e=vt(n),r=C.f,o=P.f,i=0;i<e.length;i++){var c=e[i];O(t,c)||r(t,c,o(n,c))}},yt=/#|\.prototype\./,bt=function(t,n){var e=wt[mt(t)];return e==xt||e!=St&&("function"==typeof n?u(n):!!n)},mt=bt.normalize=function(t){return String(t).replace(yt,".").toLowerCase()},wt=bt.data={},St=bt.NATIVE="N",xt=bt.POLYFILL="P",Ot=bt,At=P.f,jt=function(t,n){var e,r,o,i,c,u=t.target,l=t.global,f=t.stat;if(e=l?a:f?a[u]||M(u,{}):(a[u]||{}).prototype)for(r in n){if(i=n[r],o=t.noTargetGet?(c=At(e,r))&&c.value:e[r],!Ot(l?r:u+(f?".":"#")+r,t.forced)&&void 0!==o){if(typeof i==typeof o)continue;ht(i,o)}(t.sham||o&&o.sham)&&V(i,"sham",!0),U(e,r,i,t)}},Et=Object.keys||function(t){return ft(t,st)},It=function(t){return Object(b(t))},Pt=Object.assign,Tt=!Pt||u((function(){var t={},n={},e=Symbol();return t[e]=7,"abcdefghijklmnopqrst".split("").forEach((function(t){n[t]=t})),7!=Pt({},t)[e]||"abcdefghijklmnopqrst"!=Et(Pt({},n)).join("")}))?function(t,n){for(var e=It(t),r=arguments.length,o=1,i=gt.f,c=d.f;r>o;)for(var a,u=y(arguments[o++]),f=i?Et(u).concat(i(u)):Et(u),s=f.length,p=0;s>p;)a=f[p++],l&&!c.call(u,a)||(e[a]=u[a]);return e}:Pt;jt({target:"Object",stat:!0,forced:Object.assign!==Tt},{assign:Tt});var _t=!!Object.getOwnPropertySymbols&&!u((function(){return!String(Symbol())})),Ct=a.Symbol,Vt=J("wks"),Mt=function(t){return Vt[t]||(Vt[t]=_t&&Ct[t]||(_t?Ct:z)("Symbol."+t))},kt=Mt("toStringTag"),Jt="Arguments"==v(function(){return arguments}()),Bt={};Bt[Mt("toStringTag")]="z";var Rt="[object z]"!==String(Bt)?function(){return"[object "+(void 0===(t=this)?"Undefined":null===t?"Null":"string"==typeof(e=function(t,n){try{return t[n]}catch(t){}}(n=Object(t),kt))?e:Jt?v(n):"Object"==(r=v(n))&&"function"==typeof n.callee?"Arguments":r)+"]";var t,n,e,r}:Bt.toString,Wt=Object.prototype;Rt!==Wt.toString&&U(Wt,"toString",Rt,{unsafe:!0});var Nt=function(){var t=T(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.dotAll&&(n+="s"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n},$t=RegExp.prototype,zt=$t.toString,Ft=u((function(){return"/a/b"!=zt.call({source:"a",flags:"b"})})),Lt="toString"!=zt.name;(Ft||Lt)&&U(RegExp.prototype,"toString",(function(){var t=T(this),n=String(t.source),e=t.flags;return"/"+n+"/"+String(void 0===e&&t instanceof RegExp&&!("flags"in $t)?Nt.call(t):e)}),{unsafe:!0});var Zt,qt,Dt="当前不在掌门APP内",Ht="当前Bridge不支持此方法",Qt="方法未传入",Gt=Array.isArray||function(t){return"Array"==v(t)},Kt=function(t,n,e){var r=S(n);r in t?C.f(t,r,p(0,e)):t[r]=e},Ut=Mt("species"),Yt=function(t,n){var e;return Gt(t)&&("function"!=typeof(e=t.constructor)||e!==Array&&!Gt(e.prototype)?w(e)&&null===(e=e[Ut])&&(e=void 0):e=void 0),new(void 0===e?Array:e)(0===n?0:n)},Xt=tt("navigator","userAgent")||"",tn=a.process,nn=tn&&tn.versions,en=nn&&nn.v8;en?qt=(Zt=en.split("."))[0]+Zt[1]:Xt&&(!(Zt=Xt.match(/Edge\/(\d+)/))||Zt[1]>=74)&&(Zt=Xt.match(/Chrome\/(\d+)/))&&(qt=Zt[1]);var rn,on=qt&&+qt,cn=Mt("species"),an=Mt("isConcatSpreadable"),un=on>=51||!u((function(){var t=[];return t[an]=!1,t.concat()[0]!==t})),ln=(rn="concat",on>=51||!u((function(){var t=[];return(t.constructor={})[cn]=function(){return{foo:1}},1!==t[rn](Boolean).foo}))),fn=function(t){if(!w(t))return!1;var n=t[an];return void 0!==n?!!n:Gt(t)};jt({target:"Array",proto:!0,forced:!un||!ln},{concat:function(t){var n,e,r,o,i,c=It(this),a=Yt(c,0),u=0;for(n=-1,r=arguments.length;n<r;n++)if(i=-1===n?c:arguments[n],fn(i)){if(u+(o=it(i.length))>9007199254740991)throw TypeError("Maximum allowed index exceeded");for(e=0;e<o;e++,u++)e in i&&Kt(a,u,i[e])}else{if(u>=9007199254740991)throw TypeError("Maximum allowed index exceeded");Kt(a,u++,i)}return a.length=u,a}});var sn,dn,pn=RegExp.prototype.exec,gn=String.prototype.replace,vn=pn,hn=(sn=/a/,dn=/b*/g,pn.call(sn,"a"),pn.call(dn,"a"),0!==sn.lastIndex||0!==dn.lastIndex),yn=void 0!==/()??/.exec("")[1];(hn||yn)&&(vn=function(t){var n,e,r,o,i=this;return yn&&(e=new RegExp("^"+i.source+"$(?!\\s)",Nt.call(i))),hn&&(n=i.lastIndex),r=pn.call(i,t),hn&&r&&(i.lastIndex=i.global?r.index+r[0].length:n),yn&&r&&r.length>1&&gn.call(r[0],e,(function(){for(o=1;o<arguments.length-2;o++)void 0===arguments[o]&&(r[o]=void 0)})),r});var bn=vn,mn=Mt("species"),wn=!u((function(){var t=/./;return t.exec=function(){var t=[];return t.groups={a:"7"},t},"7"!=="".replace(t,"$<a>")})),Sn=!u((function(){var t=/(?:)/,n=t.exec;t.exec=function(){return n.apply(this,arguments)};var e="ab".split(t);return 2!==e.length||"a"!==e[0]||"b"!==e[1]})),xn=function(t,n,e,r){var o=Mt(t),i=!u((function(){var n={};return n[o]=function(){return 7},7!=""[t](n)})),c=i&&!u((function(){var n=!1,e=/a/;return"split"===t&&((e={}).constructor={},e.constructor[mn]=function(){return e},e.flags="",e[o]=/./[o]),e.exec=function(){return n=!0,null},e[o](""),!n}));if(!i||!c||"replace"===t&&!wn||"split"===t&&!Sn){var a=/./[o],l=e(o,""[t],(function(t,n,e,r,o){return n.exec===bn?i&&!o?{done:!0,value:a.call(n,e,r)}:{done:!0,value:t.call(e,n,r)}:{done:!1}})),f=l[0],s=l[1];U(String.prototype,t,f),U(RegExp.prototype,o,2==n?function(t,n){return s.call(t,this,n)}:function(t){return s.call(t,this)}),r&&V(RegExp.prototype[o],"sham",!0)}},On=function(t){return function(n,e){var r,o,i=String(b(n)),c=rt(e),a=i.length;return c<0||c>=a?t?"":void 0:(r=i.charCodeAt(c))<55296||r>56319||c+1===a||(o=i.charCodeAt(c+1))<56320||o>57343?t?i.charAt(c):r:t?i.slice(c,c+2):o-56320+(r-55296<<10)+65536}},An={codeAt:On(!1),charAt:On(!0)}.charAt,jn=function(t,n,e){return n+(e?An(t,n).length:1)},En=function(t,n){var e=t.exec;if("function"==typeof e){var r=e.call(t,n);if("object"!=typeof r)throw TypeError("RegExp exec method returned something other than an Object or null");return r}if("RegExp"!==v(t))throw TypeError("RegExp#exec called on incompatible receiver");return bn.call(t,n)},In=Math.max,Pn=Math.min,Tn=Math.floor,_n=/\$([$&'`]|\d\d?|<[^>]*>)/g,Cn=/\$([$&'`]|\d\d?)/g;xn("replace",2,(function(t,n,e){return[function(e,r){var o=b(this),i=null==e?void 0:e[t];return void 0!==i?i.call(e,o,r):n.call(String(o),e,r)},function(t,o){var i=e(n,t,this,o);if(i.done)return i.value;var c=T(t),a=String(this),u="function"==typeof o;u||(o=String(o));var l=c.global;if(l){var f=c.unicode;c.lastIndex=0}for(var s=[];;){var d=En(c,a);if(null===d)break;if(s.push(d),!l)break;""===String(d[0])&&(c.lastIndex=jn(a,it(c.lastIndex),f))}for(var p,g="",v=0,h=0;h<s.length;h++){d=s[h];for(var y=String(d[0]),b=In(Pn(rt(d.index),a.length),0),m=[],w=1;w<d.length;w++)m.push(void 0===(p=d[w])?p:String(p));var S=d.groups;if(u){var x=[y].concat(m,b,a);void 0!==S&&x.push(S);var O=String(o.apply(void 0,x))}else O=r(y,a,b,m,S,o);b>=v&&(g+=a.slice(v,b)+O,v=b+y.length)}return g+a.slice(v)}];function r(t,e,r,o,i,c){var a=r+t.length,u=o.length,l=Cn;return void 0!==i&&(i=It(i),l=_n),n.call(c,l,(function(n,c){var l;switch(c.charAt(0)){case"$":return"$";case"&":return t;case"`":return e.slice(0,r);case"'":return e.slice(a);case"<":l=i[c.slice(1,-1)];break;default:var f=+c;if(0===f)return n;if(f>u){var s=Tn(f/10);return 0===s?n:s<=u?void 0===o[s-1]?c.charAt(1):o[s-1]+c.charAt(1):n}l=o[f-1]}return void 0===l?"":l}))}}));var Vn={viewAppear:{ios:"5.6",android:"5.7"},viewDisappear:{ios:"5.6",android:"5.7"},pageCanShareCallJs:{},sharePageCallJs:{},audioVideoCBCallJS:{}},Mn={consolePrefix:"zm-bridge:  "};function kn(t){console&&console.error&&console.error(Mn.consolePrefix,t)}function Jn(t,n){return!!Vn[t]||(!!n||(kn("".concat(Ht,"，").concat(t)),!1))}function Bn(t){return!!t&&"Object"===function(t){var n=Object.prototype.toString.call(t);return"[object Array]"===n?"Array":"[object Object]"==n?"Object":""}(t)}function Rn(){var t={};if(window&&window.navigator){var n=navigator.userAgent;for(var e in t={isAndroid:n.indexOf("Android")>-1||n.indexOf("Adr")>-1,isIPhone:n.indexOf("iPhone")>-1,isIPad:n.indexOf("iPad")>-1,isWeixin:n.indexOf("MicroMessenger")>-1,isQQ:" qq"==n.match(/\sQQ/i)})t[e]||delete t[e]}return t}xn("match",1,(function(t,n,e){return[function(n){var e=b(this),r=null==n?void 0:n[t];return void 0!==r?r.call(n,e):new RegExp(n)[t](String(e))},function(t){var r=e(n,t,this);if(r.done)return r.value;var o=T(t),i=String(this);if(!o.global)return En(o,i);var c=o.unicode;o.lastIndex=0;for(var a,u=[],l=0;null!==(a=En(o,i));){var f=String(a[0]);u[l]=f,""===f&&(o.lastIndex=jn(i,it(o.lastIndex),c)),l++}return 0===l?null:u}]}));var Wn=[].slice,Nn=function(t){return function(n,e){var r=arguments.length>2,o=r?Wn.call(arguments,2):void 0;return t(r?function(){("function"==typeof n?n:Function(n)).apply(this,o)}:n,e)}};function $n(t){window&&window.WebViewJavascriptBridge?t(WebViewJavascriptBridge):document.addEventListener("WebViewJavascriptBridgeReady",(function(){t(WebViewJavascriptBridge)}),!1)}function zn(t){if(window.WebViewJavascriptBridge)return t(WebViewJavascriptBridge);if(window.WVJBCallbacks)return window.WVJBCallbacks.push(t);window.WVJBCallbacks=[t];var n=document.createElement("iframe");n.style.display="none",n.src="https://__bridge_loaded__",document.documentElement.appendChild(n),setTimeout((function(){document.documentElement.removeChild(n)}),0)}function Fn(t,n,e){return t?this.isInZmApp()?("function"==typeof n&&(e=n,n=void 0),void function(t,n,e){Rn().isAndroid?$n((function(){window.WebViewJavascriptBridge.callHandler(t,n,(function(t){var n;try{n=JSON.parse(t)}catch(e){n=t}e&&e(n)}))})):(Rn().isIPhone||Rn().isIPad)&&zn((function(r){r.callHandler(t,n,(function(t){var n;try{n=JSON.parse(t)}catch(e){n=t}e&&e(n)}))}))}(t,n,e)):(kn(Dt),!1):(kn(Qt),!1)}jt({global:!0,bind:!0,forced:/MSIE .\./.test(Xt)},{setTimeout:Nn(a.setTimeout),setInterval:Nn(a.setInterval)});var Ln={getJSBridgeVersion:function(){return"1.0.3"},isInZmApp:function(){return!(!window||!window.navigator)&&/Zmlearn/i.test(navigator.userAgent)},getAppInfo:function(t){Fn.call(this,"getAppInfo",t)},getAppVersion:function(t){Fn.call(this,"getAppVersion",t)},getNetType:function(t){Fn.call(this,"getNetType",t)},getCurrentOS:function(t){Fn.call(this,"getCurrentOS",(function(n){var e={};Bn(n)&&(e=Object.assign(Rn(),n)),t&&t(e)}))},setTitle:function(t){t?Fn.call(this,"setTitle",t):kn("参数错误")},toast:function(t){t?Fn.call(this,"toast",t):kn("参数错误")},isSupport:function(t){return t?this.isInZmApp()?Jn(t,!!this[t]):(kn(Dt),!1):(kn(Qt),!1)},pageCanShare:function(t){void 0!==t?"0"!==(t=t.toString()||"0")&&"1"!==t||Fn.call(this,"pageCanShare",t):kn("参数错误")},sharePage:function(t,n){t&&Bn(t)?Fn.call(this,"sharePage",t,n):kn("参数错误")},broadcast:function(t){var n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},e=arguments.length>2?arguments[2]:void 0;Rn().isIPhone||Rn().isIPad?(Object.assign(n,{_broadcast_key:t}),Fn.call(this,"broadcast",n,e)):Fn.call(this,"broadcast==".concat(t),n,e)},registerNativeCalledJS:function(t,n){this.isInZmApp()?"undefined"!=typeof window&&Vn[t]?(console.log("call =>>>> :",t),function(t,n,e){Jn(t,!!Ln[t])&&("function"==typeof n&&(e=n,n=void 0),Rn().isAndroid?$n((function(n){n.registerHandler(t,e)})):zn((function(n){n.registerHandler(t,e)})))}(t,n)):kn(Ht):kn(Dt)},createView:function(t,n){t&&Bn(t)?Fn.call(this,"create_view",t,n):kn("参数错误")},removeView:function(t,n){t&&Bn(t)?Fn.call(this,"remove_view",t,n):kn("参数错误")},updateView:function(t,n){t&&Bn(t)?Fn.call(this,"update_view",t,n):kn("参数错误")},getView:function(t,n){t&&Bn(t)?Fn.call(this,"get_view",t,n):kn("参数错误")},clearAll:function(t){Fn.call(this,"clear_all",t)},addAnimation:function(t,n){t&&Bn(t)?Fn.call(this,"add_animation",t,n):kn("参数错误")},openAudioVideo:function(t,n){t&&Bn(t)?Fn.call(this,"openAudioVideo",t,n):kn("参数错误")},closeAudioVideo:function(t,n){t&&Bn(t)?Fn.call(this,"closeAudioVideo",t,n):kn("参数错误")}};return Ln}));

},{}],"src/mobileAgora.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.MobileAgora = void 0;

var _rtcKit = require("./rtcKit");

var _zmBridge = _interopRequireDefault(require("@zm-fe/zm-bridge"));

var _constants = require("./constants");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

//window.JSBridge = JSBridge;
var MobileAgora =
/*#__PURE__*/
function (_RtcKit) {
  _inherits(MobileAgora, _RtcKit);

  function MobileAgora(options) {
    var _this;

    _classCallCheck(this, MobileAgora);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(MobileAgora).call(this, options));
    _this.rtcName = 'mobile agora';
    _this.loggerColor = 'darkgreen';
    _this.isSupportBeauty = false;
    _this._getSupportBeaty_ = _this._getSupportBeaty_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._initModule_ = _this._initModule_.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._isFirstLocalFrameInited_ = true;
    _this.avsEngine = null;
    _this.ZmAvsSDK = null;
    _this.APP_ID = _constants.APP_ID;
    _this.appSign = '';
    return _this;
  }

  _createClass(MobileAgora, [{
    key: "_initModule_",
    value: function _initModule_() {// 通道类型
    }
  }, {
    key: "init",
    value: function init() {
      var classType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '1v1';
      if (this._client_) return;
      this.rtcCb({
        name: 'inited',
        data: {
          code: this._code_enum_.MESSAGE_CODE_INIT
        }
      });

      this._initModule_();

      this.joinRoom(classType);
      this._client_ = {};
    }
  }, {
    key: "joinRoom",
    value: function joinRoom(classType) {
      var class_type = classType;
      var bu_type = classType;
      var bu_class_type = classType;
      var channel_name = this.channel;
      var uid = this.uid;
      var role = this.role;
      var lesson_uid = this.roomId;
      var room_id = this.roomId;
      var data = {
        lesson_uid: lesson_uid,
        room_id: room_id,
        channel_name: channel_name,
        "lesson_info": "regular",
        class_type: 'one_to_one',
        bu_type: bu_type,
        bu_class_type: bu_class_type,
        "user_info": [{
          uid: uid,
          "phone": uid,
          role: role
        }],
        "frame": {
          "x": 1,
          "y": 2,
          "width": 80,
          "height": 22
        }
      };
      data = {
        "lesson_uid": "7c5e930c685e4d4bb933ebe090e7b843",
        "room_id": "7c5e930c685e4d4bb933ebe090e7b843",
        "channel_name": "agora",
        "lesson_info": "regular",
        "class_type": "one_to_one",
        "bu_type": "1v1",
        "bu_class_type": "1v1",
        "user_info": [{
          "uid": "901681112",
          "phone": "18901681112",
          "role": "student"
        }, {
          "uid": "666665203",
          "phone": "18666665203",
          "role": "teacher"
        }],
        "frame": {
          "x": 1,
          "y": 2,
          "width": 80,
          "height": 22
        }
      };
      var div = document.getElementById("1");
      div.innerHTML = div.innerHTML + '<br>' + JSON.stringify(data);

      _zmBridge.default.openAudioVideo(data, function (res) {
        div.innerHTML = div.innerHTML + '<br>' + JSON.stringify(res);
      }); // const roleType = getRoleType(this.role, this.isWatcher);
      // const roomId = this.roomId;
      // const userId = this.uid;
      // this.avsEngine.joinChannel(classType, roomId, '', roleType, userId);

    }
  }, {
    key: "leaveRoom",
    value: function leaveRoom() {// this.avsEngine.leaveChannel()
    }
  }, {
    key: "playById",
    value: function playById(id) {// waitFor(() => document.getElementById(`${id}`))
      //     .then(() => {
      //         const dom = document.getElementById(`${id}`);
      //         const key = this.uid === id?'local':id;
      //         this.avsEngine.initRender(key, dom);
      //         this.avsEngine.setupViewContentMode(key, 1);
      //         this.logger(`playById ${id}`);
      //     });
    }
  }, {
    key: "disableVideo",
    value: function disableVideo(_ref) {// if(id === this.uid){
      //     this.avsEngine.muteLocalVideo(flag)
      // }else{
      //     this.avsEngine.muteRemoteVideo(id, flag);
      // }

      var id = _ref.id,
          flag = _ref.flag;
    }
  }, {
    key: "disableAudio",
    value: function disableAudio(_ref2) {// if(id === this.uid){
      //     this.avsEngine.muteLocalAudio(flag)
      // }else{
      //     this.avsEngine.muteRemoteAudio(id, flag);
      // }

      var id = _ref2.id,
          flag = _ref2.flag;
    }
  }, {
    key: "setFaceValue",
    value: function setFaceValue(value) {}
  }, {
    key: "_getSupportBeaty_",
    value: function _getSupportBeaty_() {
      return false;
    }
  }]);

  return MobileAgora;
}(_rtcKit.RtcKit);

exports.MobileAgora = MobileAgora;
},{"./rtcKit":"src/rtcKit.js","@zm-fe/zm-bridge":"node_modules/@zm-fe/zm-bridge/bridge.js","./constants":"src/constants.js"}],"src/channelFactory.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.makeChannelInstance = makeChannelInstance;

var _constants = require("./constants");

var _webAgora = require("./webAgora");

var _webZmrtc = require("./webZmrtc");

var _winAgora = require("./winAgora");

var _winZego = require("./winZego");

var _winTencentOne = require("./winTencentOne");

var _macTencentOne = require("./macTencentOne");

var _zmNativeBridge = require("zmNativeBridge");

var _winTencentTwo = require("./winTencentTwo");

var _winZmRtc = require("./winZmRtc");

var _macAgora = require("./macAgora");

var _electronAgora = require("./electronAgora");

var _electronZego = require("./electronZego");

var _mobileAgora = require("./mobileAgora");

function makeChannelInstance(channel) {
  var kind = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'oldpc';
  var isNativeSupport = (0, _zmNativeBridge.hasMethod)('LeaveRoom');
  console.log('kind', kind);

  if (kind === 'oldpc') {
    switch (channel) {
      case _constants.VIDEO_CHANEL_AGORA:
        if ((0, _zmNativeBridge.isWeb)()) {
          return _webAgora.WebAgora;
        } else if ((0, _zmNativeBridge.isWin)() && !(0, _zmNativeBridge.isXp)() && isNativeSupport) {
          return _winAgora.WinAgora;
        } else if ((0, _zmNativeBridge.isMac)()) {
          return _macAgora.MacAgora;
        } else {
          return _webAgora.WebAgora;
        }

      case _constants.VIDEO_CHANEL_ZEGO:
        return _winZego.WinZego;

      case _constants.VIDEO_CHANEL_TENCENT2:
        return _winTencentTwo.WinTencentTwo;

      case _constants.VIDEO_CHANEL_TENCENT1:
        if ((0, _zmNativeBridge.isWin)()) {
          return _winTencentOne.WinTencentOne;
        } else if ((0, _zmNativeBridge.isMac)()) {
          return _macTencentOne.MacTencentOne;
        } else {
          return _winTencentOne.WinTencentOne;
        }

      case _constants.VIDEO_CHANEL_ZMRTC:
        if ((0, _zmNativeBridge.isWeb)()) {
          return _webZmrtc.WebZmRtc;
        } else if ((0, _zmNativeBridge.isMac)()) {
          return _webZmrtc.WebZmRtc;
        } else if ((0, _zmNativeBridge.isXp)()) {
          return _webZmrtc.WebZmRtc;
        } else if ((0, _zmNativeBridge.isWin)() && isNativeSupport) {
          return _winZmRtc.WinZmRtc;
        } else {
          return _webZmrtc.WebZmRtc;
        }

      default:
        return _webAgora.WebAgora;
    }
  } else if (kind === 'newpc') {
    switch (channel) {
      case _constants.VIDEO_CHANEL_AGORA:
        return _electronAgora.ElectronAgora;

      case _constants.VIDEO_CHANEL_ZEGO:
        return _electronZego.ElectronZego;

      default:
        return _electronAgora.ElectronAgora;
    }
  } else if (kind === 'mobile') {
    switch (channel) {
      case _constants.VIDEO_CHANEL_AGORA:
        return _mobileAgora.MobileAgora;

      default:
        return _mobileAgora.MobileAgora;
    }
  }
}
},{"./constants":"src/constants.js","./webAgora":"src/webAgora.js","./webZmrtc":"src/webZmrtc.js","./winAgora":"src/winAgora.js","./winZego":"src/winZego.js","./winTencentOne":"src/winTencentOne.js","./macTencentOne":"src/macTencentOne.js","zmNativeBridge":"node_modules/zmNativeBridge/lib/index.js","./winTencentTwo":"src/winTencentTwo.js","./winZmRtc":"src/winZmRtc.js","./macAgora":"src/macAgora.js","./electronAgora":"src/electronAgora.js","./electronZego":"src/electronZego.js","./mobileAgora":"src/mobileAgora.js"}],"src/index.js":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.makeUidFromMobile = makeUidFromMobile;

var _channelFactory = require("./channelFactory");

var _util = require("./util");

function init(options) {
  var channel = options.channel,
      kind = options.kind,
      avsEngine = options.avsEngine,
      ZmAvsSDK = options.ZmAvsSDK,
      classType = options.classType;
  var RtcClass = (0, _channelFactory.makeChannelInstance)(channel, kind);
  var rtc = new RtcClass(options);
  rtc.init(avsEngine, ZmAvsSDK, classType);
  return rtc;
}

function makeUidFromMobile(mobile) {
  return (0, _util.makeUid)(mobile);
}
},{"./channelFactory":"src/channelFactory.js","./util":"src/util.js"}],"test.js":[function(require,module,exports) {
"use strict";

var _index = require("./src/index");

console.log('begin');
window.init = _index.init;
var a = (0, _index.init)({
  uid: 1,
  roomId: 'hongmomanu',
  channel: 'agora',
  role: 'teacher',
  kind: 'mobile'
});
},{"./src/index":"src/index.js"}],"../../../../usr/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js":[function(require,module,exports) {
var global = arguments[3];
var OVERLAY_ID = '__parcel__error__overlay__';
var OldModule = module.bundle.Module;

function Module(moduleName) {
  OldModule.call(this, moduleName);
  this.hot = {
    data: module.bundle.hotData,
    _acceptCallbacks: [],
    _disposeCallbacks: [],
    accept: function (fn) {
      this._acceptCallbacks.push(fn || function () {});
    },
    dispose: function (fn) {
      this._disposeCallbacks.push(fn);
    }
  };
  module.bundle.hotData = null;
}

module.bundle.Module = Module;
var parent = module.bundle.parent;

if ((!parent || !parent.isParcelRequire) && typeof WebSocket !== 'undefined') {
  var hostname = "" || location.hostname;
  var protocol = location.protocol === 'https:' ? 'wss' : 'ws';
  var ws = new WebSocket(protocol + '://' + hostname + ':' + "63150" + '/');

  ws.onmessage = function (event) {
    var data = JSON.parse(event.data);

    if (data.type === 'update') {
      console.clear();
      data.assets.forEach(function (asset) {
        hmrApply(global.parcelRequire, asset);
      });
      data.assets.forEach(function (asset) {
        if (!asset.isNew) {
          hmrAccept(global.parcelRequire, asset.id);
        }
      });
    }

    if (data.type === 'reload') {
      ws.close();

      ws.onclose = function () {
        location.reload();
      };
    }

    if (data.type === 'error-resolved') {
      console.log('[parcel] ✨ Error resolved');
      removeErrorOverlay();
    }

    if (data.type === 'error') {
      console.error('[parcel] 🚨  ' + data.error.message + '\n' + data.error.stack);
      removeErrorOverlay();
      var overlay = createErrorOverlay(data);
      document.body.appendChild(overlay);
    }
  };
}

function removeErrorOverlay() {
  var overlay = document.getElementById(OVERLAY_ID);

  if (overlay) {
    overlay.remove();
  }
}

function createErrorOverlay(data) {
  var overlay = document.createElement('div');
  overlay.id = OVERLAY_ID; // html encode message and stack trace

  var message = document.createElement('div');
  var stackTrace = document.createElement('pre');
  message.innerText = data.error.message;
  stackTrace.innerText = data.error.stack;
  overlay.innerHTML = '<div style="background: black; font-size: 16px; color: white; position: fixed; height: 100%; width: 100%; top: 0px; left: 0px; padding: 30px; opacity: 0.85; font-family: Menlo, Consolas, monospace; z-index: 9999;">' + '<span style="background: red; padding: 2px 4px; border-radius: 2px;">ERROR</span>' + '<span style="top: 2px; margin-left: 5px; position: relative;">🚨</span>' + '<div style="font-size: 18px; font-weight: bold; margin-top: 20px;">' + message.innerHTML + '</div>' + '<pre>' + stackTrace.innerHTML + '</pre>' + '</div>';
  return overlay;
}

function getParents(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return [];
  }

  var parents = [];
  var k, d, dep;

  for (k in modules) {
    for (d in modules[k][1]) {
      dep = modules[k][1][d];

      if (dep === id || Array.isArray(dep) && dep[dep.length - 1] === id) {
        parents.push(k);
      }
    }
  }

  if (bundle.parent) {
    parents = parents.concat(getParents(bundle.parent, id));
  }

  return parents;
}

function hmrApply(bundle, asset) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (modules[asset.id] || !bundle.parent) {
    var fn = new Function('require', 'module', 'exports', asset.generated.js);
    asset.isNew = !modules[asset.id];
    modules[asset.id] = [fn, asset.deps];
  } else if (bundle.parent) {
    hmrApply(bundle.parent, asset);
  }
}

function hmrAccept(bundle, id) {
  var modules = bundle.modules;

  if (!modules) {
    return;
  }

  if (!modules[id] && bundle.parent) {
    return hmrAccept(bundle.parent, id);
  }

  var cached = bundle.cache[id];
  bundle.hotData = {};

  if (cached) {
    cached.hot.data = bundle.hotData;
  }

  if (cached && cached.hot && cached.hot._disposeCallbacks.length) {
    cached.hot._disposeCallbacks.forEach(function (cb) {
      cb(bundle.hotData);
    });
  }

  delete bundle.cache[id];
  bundle(id);
  cached = bundle.cache[id];

  if (cached && cached.hot && cached.hot._acceptCallbacks.length) {
    cached.hot._acceptCallbacks.forEach(function (cb) {
      cb();
    });

    return true;
  }

  return getParents(global.parcelRequire, id).some(function (id) {
    return hmrAccept(global.parcelRequire, id);
  });
}
},{}]},{},["../../../../usr/lib/node_modules/parcel-bundler/src/builtins/hmr-runtime.js","test.js"], null)
//# sourceMappingURL=/test.e98b79dd.map